# coding: binary
# Generated by generate-specs

#################### null_nilkey_nilvalue ####################

shared_examples_for 'null_nilkey_nilvalue' do
  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = ''
    store[0] = nil
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = ''
    store[nil] = nil
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = nil
    store[0] = ''
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = nil
    store[nil] = ''
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = 0
    store[0] = false
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = 0
    store[nil] = false
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = false
    store[0] = 0
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = false
    store[nil] = 0
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, false, options).should == false
  end
end

#################### store_nilkey_nilvalue ####################

shared_examples_for 'store_nilkey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store[nil] = ''
    store[nil].should == ''
    store.load(nil).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = ''
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(nil, value).should equal(value)
    store[nil].should == ''
    store.load(nil).should == ''
  end

  it 'stores values after clear' do
    store[nil] = ''
    store[0] = nil
    store.clear.should equal(store)
    store[nil] = ''
    store[nil].should == ''
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = ''
    store.delete(nil).should == ''
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = ''
    store[nil].should == ''
    store[nil] = nil
    store[nil].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == ''
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = ''
    store[nil].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[0] = ''
    store[0].should == ''
    store.load(0).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[0] = ''
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(0, value).should equal(value)
    store[0].should == ''
    store.load(0).should == ''
  end

  it 'stores values after clear' do
    store[0] = ''
    store[nil] = nil
    store.clear.should equal(store)
    store[0] = ''
    store[0].should == ''
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = ''
    store.delete(0).should == ''
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = ''
    store[0].should == ''
    store[0] = nil
    store[0].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[0] = value).should equal(value)
    store[0].should == ''
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = ''
    store[0].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = nil
    store[nil].should == nil
    store.load(nil).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = nil
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(nil, value).should equal(value)
    store[nil].should == nil
    store.load(nil).should == nil
  end

  it 'stores values after clear' do
    store[nil] = nil
    store[0] = ''
    store.clear.should equal(store)
    store[nil] = nil
    store[nil].should == nil
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = nil
    store.delete(nil).should == nil
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = nil
    store[nil].should == nil
    store[nil] = ''
    store[nil].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == nil
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = nil
    store[nil].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[0] = nil
    store[0].should == nil
    store.load(0).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[0] = nil
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(0, value).should equal(value)
    store[0].should == nil
    store.load(0).should == nil
  end

  it 'stores values after clear' do
    store[0] = nil
    store[nil] = ''
    store.clear.should equal(store)
    store[0] = nil
    store[0].should == nil
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = nil
    store.delete(0).should == nil
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = nil
    store[0].should == nil
    store[0] = ''
    store[0].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[0] = value).should equal(value)
    store[0].should == nil
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = nil
    store[0].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = 0
    store[nil].should == 0
    store.load(nil).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = 0
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(nil, value).should equal(value)
    store[nil].should == 0
    store.load(nil).should == 0
  end

  it 'stores values after clear' do
    store[nil] = 0
    store[0] = false
    store.clear.should equal(store)
    store[nil] = 0
    store[nil].should == 0
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = 0
    store.delete(nil).should == 0
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = 0
    store[nil].should == 0
    store[nil] = false
    store[nil].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == 0
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = 0
    store[nil].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[0] = 0
    store[0].should == 0
    store.load(0).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[0] = 0
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(0, value).should equal(value)
    store[0].should == 0
    store.load(0).should == 0
  end

  it 'stores values after clear' do
    store[0] = 0
    store[nil] = false
    store.clear.should equal(store)
    store[0] = 0
    store[0].should == 0
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = 0
    store.delete(0).should == 0
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = 0
    store[0].should == 0
    store[0] = false
    store[0].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[0] = value).should equal(value)
    store[0].should == 0
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = 0
    store[0].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = false
    store[nil].should == false
    store.load(nil).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = false
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(nil, value).should equal(value)
    store[nil].should == false
    store.load(nil).should == false
  end

  it 'stores values after clear' do
    store[nil] = false
    store[0] = 0
    store.clear.should equal(store)
    store[nil] = false
    store[nil].should == false
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = false
    store.delete(nil).should == false
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = false
    store[nil].should == false
    store[nil] = 0
    store[nil].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == false
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = false
    store[nil].should == false
  end

  it 'writes values to keys that like a Hash' do
    store[0] = false
    store[0].should == false
    store.load(0).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[0] = false
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(0, value).should equal(value)
    store[0].should == false
    store.load(0).should == false
  end

  it 'stores values after clear' do
    store[0] = false
    store[nil] = 0
    store.clear.should equal(store)
    store[0] = false
    store[0].should == false
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = false
    store.delete(0).should == false
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = false
    store[0].should == false
    store[0] = 0
    store[0].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[0] = value).should equal(value)
    store[0].should == false
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = false
    store[0].should == false
  end
end

#################### persist_nilkey_nilvalue ####################

shared_examples_for 'persist_nilkey_nilvalue' do
  it 'persists values' do
    store[nil] = ''
    store.close
    @store = nil
    store[nil].should == ''
  end

  it 'persists values' do
    store[0] = ''
    store.close
    @store = nil
    store[0].should == ''
  end

  it 'persists values' do
    store[nil] = nil
    store.close
    @store = nil
    store[nil].should == nil
  end

  it 'persists values' do
    store[0] = nil
    store.close
    @store = nil
    store[0].should == nil
  end

  it 'persists values' do
    store[nil] = 0
    store.close
    @store = nil
    store[nil].should == 0
  end

  it 'persists values' do
    store[0] = 0
    store.close
    @store = nil
    store[0].should == 0
  end

  it 'persists values' do
    store[nil] = false
    store.close
    @store = nil
    store[nil].should == false
  end

  it 'persists values' do
    store[0] = false
    store.close
    @store = nil
    store[0].should == false
  end
end

#################### null_nilkey_integervalue ####################

shared_examples_for 'null_nilkey_integervalue' do
  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = 41
    store[0] = -12
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = 41
    store[nil] = -12
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = -12
    store[0] = 41
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = -12
    store[nil] = 41
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, -12, options).should == -12
  end
end

#################### store_nilkey_integervalue ####################

shared_examples_for 'store_nilkey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store[nil] = 41
    store[nil].should == 41
    store.load(nil).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = 41
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(nil, value).should equal(value)
    store[nil].should == 41
    store.load(nil).should == 41
  end

  it 'stores values after clear' do
    store[nil] = 41
    store[0] = -12
    store.clear.should equal(store)
    store[nil] = 41
    store[nil].should == 41
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = 41
    store.delete(nil).should == 41
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = 41
    store[nil].should == 41
    store[nil] = -12
    store[nil].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == 41
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = 41
    store[nil].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = 41
    store.fetch(nil, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = 41
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = 41
    store[0].should == 41
    store.load(0).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[0] = 41
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(0, value).should equal(value)
    store[0].should == 41
    store.load(0).should == 41
  end

  it 'stores values after clear' do
    store[0] = 41
    store[nil] = -12
    store.clear.should equal(store)
    store[0] = 41
    store[0].should == 41
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = 41
    store.delete(0).should == 41
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = 41
    store[0].should == 41
    store[0] = -12
    store[0].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[0] = value).should equal(value)
    store[0].should == 41
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = 41
    store[0].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = 41
    store.fetch(0, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = 41
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = -12
    store[nil].should == -12
    store.load(nil).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = -12
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(nil, value).should equal(value)
    store[nil].should == -12
    store.load(nil).should == -12
  end

  it 'stores values after clear' do
    store[nil] = -12
    store[0] = 41
    store.clear.should equal(store)
    store[nil] = -12
    store[nil].should == -12
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = -12
    store.delete(nil).should == -12
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = -12
    store[nil].should == -12
    store[nil] = 41
    store[nil].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == -12
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = -12
    store[nil].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = -12
    store.fetch(nil, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = -12
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = -12
    store[0].should == -12
    store.load(0).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[0] = -12
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(0, value).should equal(value)
    store[0].should == -12
    store.load(0).should == -12
  end

  it 'stores values after clear' do
    store[0] = -12
    store[nil] = 41
    store.clear.should equal(store)
    store[0] = -12
    store[0].should == -12
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = -12
    store.delete(0).should == -12
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = -12
    store[0].should == -12
    store[0] = 41
    store[0].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[0] = value).should equal(value)
    store[0].should == -12
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = -12
    store[0].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = -12
    store.fetch(0, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = -12
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_nilkey_integervalue ####################

shared_examples_for 'persist_nilkey_integervalue' do
  it 'persists values' do
    store[nil] = 41
    store.close
    @store = nil
    store[nil].should == 41
  end

  it 'persists values' do
    store[0] = 41
    store.close
    @store = nil
    store[0].should == 41
  end

  it 'persists values' do
    store[nil] = -12
    store.close
    @store = nil
    store[nil].should == -12
  end

  it 'persists values' do
    store[0] = -12
    store.close
    @store = nil
    store[0].should == -12
  end
end

#################### null_nilkey_numbervalue ####################

shared_examples_for 'null_nilkey_numbervalue' do
  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = 123.456
    store[0] = -98.7
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = 123.456
    store[nil] = -98.7
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = -98.7
    store[0] = 123.456
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = -98.7
    store[nil] = 123.456
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = 340282366920938463463374607431768211456
    store[0] = 33
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = 340282366920938463463374607431768211456
    store[nil] = 33
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = 33
    store[0] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = 33
    store[nil] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, 33, options).should == 33
  end
end

#################### store_nilkey_numbervalue ####################

shared_examples_for 'store_nilkey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store[nil] = 123.456
    store[nil].should == 123.456
    store.load(nil).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = 123.456
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(nil, value).should equal(value)
    store[nil].should == 123.456
    store.load(nil).should == 123.456
  end

  it 'stores values after clear' do
    store[nil] = 123.456
    store[0] = -98.7
    store.clear.should equal(store)
    store[nil] = 123.456
    store[nil].should == 123.456
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = 123.456
    store.delete(nil).should == 123.456
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = 123.456
    store[nil].should == 123.456
    store[nil] = -98.7
    store[nil].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == 123.456
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = 123.456
    store[nil].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = 123.456
    store.fetch(nil, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = 123.456
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = 123.456
    store[0].should == 123.456
    store.load(0).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[0] = 123.456
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(0, value).should equal(value)
    store[0].should == 123.456
    store.load(0).should == 123.456
  end

  it 'stores values after clear' do
    store[0] = 123.456
    store[nil] = -98.7
    store.clear.should equal(store)
    store[0] = 123.456
    store[0].should == 123.456
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = 123.456
    store.delete(0).should == 123.456
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = 123.456
    store[0].should == 123.456
    store[0] = -98.7
    store[0].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[0] = value).should equal(value)
    store[0].should == 123.456
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = 123.456
    store[0].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = 123.456
    store.fetch(0, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = 123.456
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = -98.7
    store[nil].should == -98.7
    store.load(nil).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = -98.7
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(nil, value).should equal(value)
    store[nil].should == -98.7
    store.load(nil).should == -98.7
  end

  it 'stores values after clear' do
    store[nil] = -98.7
    store[0] = 123.456
    store.clear.should equal(store)
    store[nil] = -98.7
    store[nil].should == -98.7
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = -98.7
    store.delete(nil).should == -98.7
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = -98.7
    store[nil].should == -98.7
    store[nil] = 123.456
    store[nil].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == -98.7
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = -98.7
    store[nil].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = -98.7
    store.fetch(nil, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = -98.7
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = -98.7
    store[0].should == -98.7
    store.load(0).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[0] = -98.7
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(0, value).should equal(value)
    store[0].should == -98.7
    store.load(0).should == -98.7
  end

  it 'stores values after clear' do
    store[0] = -98.7
    store[nil] = 123.456
    store.clear.should equal(store)
    store[0] = -98.7
    store[0].should == -98.7
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = -98.7
    store.delete(0).should == -98.7
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = -98.7
    store[0].should == -98.7
    store[0] = 123.456
    store[0].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[0] = value).should equal(value)
    store[0].should == -98.7
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = -98.7
    store[0].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = -98.7
    store.fetch(0, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = -98.7
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = 340282366920938463463374607431768211456
    store[nil].should == 340282366920938463463374607431768211456
    store.load(nil).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = 340282366920938463463374607431768211456
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(nil, value).should equal(value)
    store[nil].should == 340282366920938463463374607431768211456
    store.load(nil).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[nil] = 340282366920938463463374607431768211456
    store[0] = 33
    store.clear.should equal(store)
    store[nil] = 340282366920938463463374607431768211456
    store[nil].should == 340282366920938463463374607431768211456
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = 340282366920938463463374607431768211456
    store.delete(nil).should == 340282366920938463463374607431768211456
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = 340282366920938463463374607431768211456
    store[nil].should == 340282366920938463463374607431768211456
    store[nil] = 33
    store[nil].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = 340282366920938463463374607431768211456
    store[nil].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = 340282366920938463463374607431768211456
    store.fetch(nil, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = 340282366920938463463374607431768211456
    store[0].should == 340282366920938463463374607431768211456
    store.load(0).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[0] = 340282366920938463463374607431768211456
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(0, value).should equal(value)
    store[0].should == 340282366920938463463374607431768211456
    store.load(0).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[0] = 340282366920938463463374607431768211456
    store[nil] = 33
    store.clear.should equal(store)
    store[0] = 340282366920938463463374607431768211456
    store[0].should == 340282366920938463463374607431768211456
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = 340282366920938463463374607431768211456
    store.delete(0).should == 340282366920938463463374607431768211456
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = 340282366920938463463374607431768211456
    store[0].should == 340282366920938463463374607431768211456
    store[0] = 33
    store[0].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[0] = value).should equal(value)
    store[0].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = 340282366920938463463374607431768211456
    store[0].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = 340282366920938463463374607431768211456
    store.fetch(0, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = 33
    store[nil].should == 33
    store.load(nil).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = 33
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(nil, value).should equal(value)
    store[nil].should == 33
    store.load(nil).should == 33
  end

  it 'stores values after clear' do
    store[nil] = 33
    store[0] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[nil] = 33
    store[nil].should == 33
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = 33
    store.delete(nil).should == 33
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = 33
    store[nil].should == 33
    store[nil] = 340282366920938463463374607431768211456
    store[nil].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == 33
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = 33
    store[nil].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = 33
    store.fetch(nil, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = 33
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = 33
    store[0].should == 33
    store.load(0).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[0] = 33
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(0, value).should equal(value)
    store[0].should == 33
    store.load(0).should == 33
  end

  it 'stores values after clear' do
    store[0] = 33
    store[nil] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[0] = 33
    store[0].should == 33
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = 33
    store.delete(0).should == 33
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = 33
    store[0].should == 33
    store[0] = 340282366920938463463374607431768211456
    store[0].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[0] = value).should equal(value)
    store[0].should == 33
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = 33
    store[0].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = 33
    store.fetch(0, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = 33
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_nilkey_numbervalue ####################

shared_examples_for 'persist_nilkey_numbervalue' do
  it 'persists values' do
    store[nil] = 123.456
    store.close
    @store = nil
    store[nil].should == 123.456
  end

  it 'persists values' do
    store[0] = 123.456
    store.close
    @store = nil
    store[0].should == 123.456
  end

  it 'persists values' do
    store[nil] = -98.7
    store.close
    @store = nil
    store[nil].should == -98.7
  end

  it 'persists values' do
    store[0] = -98.7
    store.close
    @store = nil
    store[0].should == -98.7
  end

  it 'persists values' do
    store[nil] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[nil].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[0] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[0].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[nil] = 33
    store.close
    @store = nil
    store[nil].should == 33
  end

  it 'persists values' do
    store[0] = 33
    store.close
    @store = nil
    store[0].should == 33
  end
end

#################### null_nilkey_booleanvalue ####################

shared_examples_for 'null_nilkey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = true
    store[0] = false
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = true
    store[nil] = false
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = false
    store[0] = true
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = false
    store[nil] = true
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, false, options).should == false
  end
end

#################### store_nilkey_booleanvalue ####################

shared_examples_for 'store_nilkey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store[nil] = true
    store[nil].should == true
    store.load(nil).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = true
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(nil, value).should equal(value)
    store[nil].should == true
    store.load(nil).should == true
  end

  it 'stores values after clear' do
    store[nil] = true
    store[0] = false
    store.clear.should equal(store)
    store[nil] = true
    store[nil].should == true
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = true
    store.delete(nil).should == true
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = true
    store[nil].should == true
    store[nil] = false
    store[nil].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == true
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = true
    store[nil].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = true
    store.fetch(nil, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = true
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = true
    store[0].should == true
    store.load(0).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[0] = true
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(0, value).should equal(value)
    store[0].should == true
    store.load(0).should == true
  end

  it 'stores values after clear' do
    store[0] = true
    store[nil] = false
    store.clear.should equal(store)
    store[0] = true
    store[0].should == true
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = true
    store.delete(0).should == true
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = true
    store[0].should == true
    store[0] = false
    store[0].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[0] = value).should equal(value)
    store[0].should == true
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = true
    store[0].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = true
    store.fetch(0, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = true
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = false
    store[nil].should == false
    store.load(nil).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = false
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(nil, value).should equal(value)
    store[nil].should == false
    store.load(nil).should == false
  end

  it 'stores values after clear' do
    store[nil] = false
    store[0] = true
    store.clear.should equal(store)
    store[nil] = false
    store[nil].should == false
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = false
    store.delete(nil).should == false
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = false
    store[nil].should == false
    store[nil] = true
    store[nil].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == false
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = false
    store[nil].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = false
    store.fetch(nil, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = false
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = false
    store[0].should == false
    store.load(0).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[0] = false
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(0, value).should equal(value)
    store[0].should == false
    store.load(0).should == false
  end

  it 'stores values after clear' do
    store[0] = false
    store[nil] = true
    store.clear.should equal(store)
    store[0] = false
    store[0].should == false
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = false
    store.delete(0).should == false
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = false
    store[0].should == false
    store[0] = true
    store[0].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[0] = value).should equal(value)
    store[0].should == false
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = false
    store[0].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = false
    store.fetch(0, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = false
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_nilkey_booleanvalue ####################

shared_examples_for 'persist_nilkey_booleanvalue' do
  it 'persists values' do
    store[nil] = true
    store.close
    @store = nil
    store[nil].should == true
  end

  it 'persists values' do
    store[0] = true
    store.close
    @store = nil
    store[0].should == true
  end

  it 'persists values' do
    store[nil] = false
    store.close
    @store = nil
    store[nil].should == false
  end

  it 'persists values' do
    store[0] = false
    store.close
    @store = nil
    store[0].should == false
  end
end

#################### null_nilkey_stringvalue ####################

shared_examples_for 'null_nilkey_stringvalue' do
  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = "strval1"
    store[0] = "strval2"
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = "strval1"
    store[nil] = "strval2"
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = "strval2"
    store[0] = "strval1"
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = "strval2"
    store[nil] = "strval1"
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, "strval2", options).should == "strval2"
  end
end

#################### store_nilkey_stringvalue ####################

shared_examples_for 'store_nilkey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store[nil] = "strval1"
    store[nil].should == "strval1"
    store.load(nil).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = "strval1"
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(nil, value).should equal(value)
    store[nil].should == "strval1"
    store.load(nil).should == "strval1"
  end

  it 'stores values after clear' do
    store[nil] = "strval1"
    store[0] = "strval2"
    store.clear.should equal(store)
    store[nil] = "strval1"
    store[nil].should == "strval1"
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = "strval1"
    store.delete(nil).should == "strval1"
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = "strval1"
    store[nil].should == "strval1"
    store[nil] = "strval2"
    store[nil].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[nil] = value).should equal(value)
    store[nil].should == "strval1"
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = "strval1"
    store[nil].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = "strval1"
    store.fetch(nil, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = "strval1"
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = "strval1"
    store[0].should == "strval1"
    store.load(0).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[0] = "strval1"
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(0, value).should equal(value)
    store[0].should == "strval1"
    store.load(0).should == "strval1"
  end

  it 'stores values after clear' do
    store[0] = "strval1"
    store[nil] = "strval2"
    store.clear.should equal(store)
    store[0] = "strval1"
    store[0].should == "strval1"
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = "strval1"
    store.delete(0).should == "strval1"
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = "strval1"
    store[0].should == "strval1"
    store[0] = "strval2"
    store[0].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[0] = value).should equal(value)
    store[0].should == "strval1"
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = "strval1"
    store[0].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = "strval1"
    store.fetch(0, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = "strval1"
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = "strval2"
    store[nil].should == "strval2"
    store.load(nil).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = "strval2"
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(nil, value).should equal(value)
    store[nil].should == "strval2"
    store.load(nil).should == "strval2"
  end

  it 'stores values after clear' do
    store[nil] = "strval2"
    store[0] = "strval1"
    store.clear.should equal(store)
    store[nil] = "strval2"
    store[nil].should == "strval2"
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = "strval2"
    store.delete(nil).should == "strval2"
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = "strval2"
    store[nil].should == "strval2"
    store[nil] = "strval1"
    store[nil].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[nil] = value).should equal(value)
    store[nil].should == "strval2"
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = "strval2"
    store[nil].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = "strval2"
    store.fetch(nil, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = "strval2"
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = "strval2"
    store[0].should == "strval2"
    store.load(0).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[0] = "strval2"
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(0, value).should equal(value)
    store[0].should == "strval2"
    store.load(0).should == "strval2"
  end

  it 'stores values after clear' do
    store[0] = "strval2"
    store[nil] = "strval1"
    store.clear.should equal(store)
    store[0] = "strval2"
    store[0].should == "strval2"
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = "strval2"
    store.delete(0).should == "strval2"
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = "strval2"
    store[0].should == "strval2"
    store[0] = "strval1"
    store[0].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[0] = value).should equal(value)
    store[0].should == "strval2"
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = "strval2"
    store[0].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = "strval2"
    store.fetch(0, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = "strval2"
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_nilkey_stringvalue ####################

shared_examples_for 'returndifferent_nilkey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[nil] = value
    store[nil].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[0] = value
    store[0].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[nil] = value
    store[nil].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[0] = value
    store[0].should_not be_equal(value)
  end
end

#################### returnsame_nilkey_stringvalue ####################

shared_examples_for 'returnsame_nilkey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[nil] = value
    store[nil].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[0] = value
    store[0].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[nil] = value
    store[nil].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[0] = value
    store[0].should be_equal(value)
  end
end

#################### persist_nilkey_stringvalue ####################

shared_examples_for 'persist_nilkey_stringvalue' do
  it 'persists values' do
    store[nil] = "strval1"
    store.close
    @store = nil
    store[nil].should == "strval1"
  end

  it 'persists values' do
    store[0] = "strval1"
    store.close
    @store = nil
    store[0].should == "strval1"
  end

  it 'persists values' do
    store[nil] = "strval2"
    store.close
    @store = nil
    store[nil].should == "strval2"
  end

  it 'persists values' do
    store[0] = "strval2"
    store.close
    @store = nil
    store[0].should == "strval2"
  end
end

#################### null_nilkey_binaryvalue ####################

shared_examples_for 'null_nilkey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = "ber"
    store[0] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = "ber"
    store[nil] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = "\xAA\xBB\xCC"
    store[0] = "ber"
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = "\xAA\xBB\xCC"
    store[nil] = "ber"
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_nilkey_binaryvalue ####################

shared_examples_for 'store_nilkey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store[nil] = "ber"
    store[nil].should == "ber"
    store.load(nil).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = "ber"
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(nil, value).should equal(value)
    store[nil].should == "ber"
    store.load(nil).should == "ber"
  end

  it 'stores values after clear' do
    store[nil] = "ber"
    store[0] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[nil] = "ber"
    store[nil].should == "ber"
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = "ber"
    store.delete(nil).should == "ber"
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = "ber"
    store[nil].should == "ber"
    store[nil] = "\xAA\xBB\xCC"
    store[nil].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[nil] = value).should equal(value)
    store[nil].should == "ber"
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = "ber"
    store[nil].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = "ber"
    store.fetch(nil, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = "ber"
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = "ber"
    store[0].should == "ber"
    store.load(0).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[0] = "ber"
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(0, value).should equal(value)
    store[0].should == "ber"
    store.load(0).should == "ber"
  end

  it 'stores values after clear' do
    store[0] = "ber"
    store[nil] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[0] = "ber"
    store[0].should == "ber"
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = "ber"
    store.delete(0).should == "ber"
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = "ber"
    store[0].should == "ber"
    store[0] = "\xAA\xBB\xCC"
    store[0].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[0] = value).should equal(value)
    store[0].should == "ber"
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = "ber"
    store[0].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = "ber"
    store.fetch(0, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = "ber"
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = "\xAA\xBB\xCC"
    store[nil].should == "\xAA\xBB\xCC"
    store.load(nil).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = "\xAA\xBB\xCC"
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(nil, value).should equal(value)
    store[nil].should == "\xAA\xBB\xCC"
    store.load(nil).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[nil] = "\xAA\xBB\xCC"
    store[0] = "ber"
    store.clear.should equal(store)
    store[nil] = "\xAA\xBB\xCC"
    store[nil].should == "\xAA\xBB\xCC"
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = "\xAA\xBB\xCC"
    store.delete(nil).should == "\xAA\xBB\xCC"
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = "\xAA\xBB\xCC"
    store[nil].should == "\xAA\xBB\xCC"
    store[nil] = "ber"
    store[nil].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[nil] = value).should equal(value)
    store[nil].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = "\xAA\xBB\xCC"
    store[nil].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = "\xAA\xBB\xCC"
    store.fetch(nil, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = "\xAA\xBB\xCC"
    store[0].should == "\xAA\xBB\xCC"
    store.load(0).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[0] = "\xAA\xBB\xCC"
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(0, value).should equal(value)
    store[0].should == "\xAA\xBB\xCC"
    store.load(0).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[0] = "\xAA\xBB\xCC"
    store[nil] = "ber"
    store.clear.should equal(store)
    store[0] = "\xAA\xBB\xCC"
    store[0].should == "\xAA\xBB\xCC"
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = "\xAA\xBB\xCC"
    store.delete(0).should == "\xAA\xBB\xCC"
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = "\xAA\xBB\xCC"
    store[0].should == "\xAA\xBB\xCC"
    store[0] = "ber"
    store[0].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[0] = value).should equal(value)
    store[0].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = "\xAA\xBB\xCC"
    store[0].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = "\xAA\xBB\xCC"
    store.fetch(0, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_nilkey_binaryvalue ####################

shared_examples_for 'returndifferent_nilkey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[nil] = value
    store[nil].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[0] = value
    store[0].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[nil] = value
    store[nil].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[0] = value
    store[0].should_not be_equal(value)
  end
end

#################### returnsame_nilkey_binaryvalue ####################

shared_examples_for 'returnsame_nilkey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[nil] = value
    store[nil].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[0] = value
    store[0].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[nil] = value
    store[nil].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[0] = value
    store[0].should be_equal(value)
  end
end

#################### persist_nilkey_binaryvalue ####################

shared_examples_for 'persist_nilkey_binaryvalue' do
  it 'persists values' do
    store[nil] = "ber"
    store.close
    @store = nil
    store[nil].should == "ber"
  end

  it 'persists values' do
    store[0] = "ber"
    store.close
    @store = nil
    store[0].should == "ber"
  end

  it 'persists values' do
    store[nil] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[nil].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store[0] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[0].should == "\xAA\xBB\xCC"
  end
end

#################### null_nilkey_hashvalue ####################

shared_examples_for 'null_nilkey_hashvalue' do
  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = {"hashval1"=>["array1", 1]}
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = {"hashval1"=>["array1", 1]}
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_nilkey_hashvalue ####################

shared_examples_for 'store_nilkey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store[nil] = {"hashval1"=>["array1", 1]}
    store[nil].should == {"hashval1"=>["array1", 1]}
    store.load(nil).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = {"hashval1"=>["array1", 1]}
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(nil, value).should equal(value)
    store[nil].should == {"hashval1"=>["array1", 1]}
    store.load(nil).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[nil] = {"hashval1"=>["array1", 1]}
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[nil] = {"hashval1"=>["array1", 1]}
    store[nil].should == {"hashval1"=>["array1", 1]}
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = {"hashval1"=>["array1", 1]}
    store.delete(nil).should == {"hashval1"=>["array1", 1]}
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = {"hashval1"=>["array1", 1]}
    store[nil].should == {"hashval1"=>["array1", 1]}
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[nil].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = {"hashval1"=>["array1", 1]}
    store.fetch(nil, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = {"hashval1"=>["array1", 1]}
    store[0].should == {"hashval1"=>["array1", 1]}
    store.load(0).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[0] = {"hashval1"=>["array1", 1]}
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(0, value).should equal(value)
    store[0].should == {"hashval1"=>["array1", 1]}
    store.load(0).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[0] = {"hashval1"=>["array1", 1]}
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[0] = {"hashval1"=>["array1", 1]}
    store[0].should == {"hashval1"=>["array1", 1]}
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = {"hashval1"=>["array1", 1]}
    store.delete(0).should == {"hashval1"=>["array1", 1]}
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = {"hashval1"=>["array1", 1]}
    store[0].should == {"hashval1"=>["array1", 1]}
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[0] = value).should equal(value)
    store[0].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[0].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = {"hashval1"=>["array1", 1]}
    store.fetch(0, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(nil).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(nil, value).should equal(value)
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(nil).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(nil).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil] = {"hashval1"=>["array1", 1]}
    store[nil].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[nil] = value).should equal(value)
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(nil, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(0).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(0, value).should equal(value)
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(0).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(0).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0] = {"hashval1"=>["array1", 1]}
    store[0].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[0] = value).should equal(value)
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(0, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_nilkey_hashvalue ####################

shared_examples_for 'returndifferent_nilkey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[nil] = value
    store[nil].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[0] = value
    store[0].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil] = value
    store[nil].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0] = value
    store[0].should_not be_equal(value)
  end
end

#################### returnsame_nilkey_hashvalue ####################

shared_examples_for 'returnsame_nilkey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[nil] = value
    store[nil].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[0] = value
    store[0].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[nil] = value
    store[nil].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0] = value
    store[0].should be_equal(value)
  end
end

#################### persist_nilkey_hashvalue ####################

shared_examples_for 'persist_nilkey_hashvalue' do
  it 'persists values' do
    store[nil] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[nil].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[0] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[0].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[nil] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[nil].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store[0] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[0].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_nilkey_objectvalue ####################

shared_examples_for 'null_nilkey_objectvalue' do
  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = Value.new(:objval1)
    store[0] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = Value.new(:objval1)
    store[nil] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[nil].should be_nil
    store.load(nil).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[nil] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(nil).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(nil).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[nil] = Value.new(:objval2)
    store[0] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(nil).should be_false
    store.key?(0).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(nil, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = nil
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(nil, options).should be_false
    store.load(nil, options).should be_nil
    store.fetch(nil, 42, options).should == 42
    store.fetch(nil, options) { 42 }.should == 42
    store.delete(nil, options).should be_nil
    store.clear(options).should equal(store)
    store.store(nil, Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store[0].should be_nil
    store.load(0).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[0] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0] = Value.new(:objval2)
    store[nil] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(0).should be_false
    store.key?(nil).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0, options).should be_false
    store.load(0, options).should be_nil
    store.fetch(0, 42, options).should == 42
    store.fetch(0, options) { 42 }.should == 42
    store.delete(0, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0, Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_nilkey_objectvalue ####################

shared_examples_for 'store_nilkey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store[nil] = Value.new(:objval1)
    store[nil].should == Value.new(:objval1)
    store.load(nil).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = Value.new(:objval1)
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(nil, value).should equal(value)
    store[nil].should == Value.new(:objval1)
    store.load(nil).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[nil] = Value.new(:objval1)
    store[0] = Value.new(:objval2)
    store.clear.should equal(store)
    store[nil] = Value.new(:objval1)
    store[nil].should == Value.new(:objval1)
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = Value.new(:objval1)
    store.delete(nil).should == Value.new(:objval1)
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = Value.new(:objval1)
    store[nil].should == Value.new(:objval1)
    store[nil] = Value.new(:objval2)
    store[nil].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[nil] = value).should equal(value)
    store[nil].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = Value.new(:objval1)
    store[nil].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = Value.new(:objval1)
    store.fetch(nil, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = Value.new(:objval1)
    store[0].should == Value.new(:objval1)
    store.load(0).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[0] = Value.new(:objval1)
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(0, value).should equal(value)
    store[0].should == Value.new(:objval1)
    store.load(0).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[0] = Value.new(:objval1)
    store[nil] = Value.new(:objval2)
    store.clear.should equal(store)
    store[0] = Value.new(:objval1)
    store[0].should == Value.new(:objval1)
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = Value.new(:objval1)
    store.delete(0).should == Value.new(:objval1)
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = Value.new(:objval1)
    store[0].should == Value.new(:objval1)
    store[0] = Value.new(:objval2)
    store[0].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[0] = value).should equal(value)
    store[0].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = Value.new(:objval1)
    store[0].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = Value.new(:objval1)
    store.fetch(0, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[nil] = Value.new(:objval2)
    store[nil].should == Value.new(:objval2)
    store.load(nil).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[nil] = Value.new(:objval2)
    store.key?(nil).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(nil, value).should equal(value)
    store[nil].should == Value.new(:objval2)
    store.load(nil).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[nil] = Value.new(:objval2)
    store[0] = Value.new(:objval1)
    store.clear.should equal(store)
    store[nil] = Value.new(:objval2)
    store[nil].should == Value.new(:objval2)
    store[0].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[nil] = Value.new(:objval2)
    store.delete(nil).should == Value.new(:objval2)
    store.key?(nil).should be_false
  end

  it 'overwrites existing values' do
    store[nil] = Value.new(:objval2)
    store[nil].should == Value.new(:objval2)
    store[nil] = Value.new(:objval1)
    store[nil].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[nil] = value).should equal(value)
    store[nil].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = nil.freeze
    store[key] = Value.new(:objval2)
    store[nil].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[nil] = Value.new(:objval2)
    store.fetch(nil, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[nil] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(nil) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0] = Value.new(:objval2)
    store[0].should == Value.new(:objval2)
    store.load(0).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[0] = Value.new(:objval2)
    store.key?(0).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(0, value).should equal(value)
    store[0].should == Value.new(:objval2)
    store.load(0).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[0] = Value.new(:objval2)
    store[nil] = Value.new(:objval1)
    store.clear.should equal(store)
    store[0] = Value.new(:objval2)
    store[0].should == Value.new(:objval2)
    store[nil].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0] = Value.new(:objval2)
    store.delete(0).should == Value.new(:objval2)
    store.key?(0).should be_false
  end

  it 'overwrites existing values' do
    store[0] = Value.new(:objval2)
    store[0].should == Value.new(:objval2)
    store[0] = Value.new(:objval1)
    store[0].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[0] = value).should equal(value)
    store[0].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = 0.freeze
    store[key] = Value.new(:objval2)
    store[0].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0] = Value.new(:objval2)
    store.fetch(0, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[0] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(0) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_nilkey_objectvalue ####################

shared_examples_for 'returndifferent_nilkey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[nil] = value
    store[nil].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[0] = value
    store[0].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[nil] = value
    store[nil].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[0] = value
    store[0].should_not be_equal(value)
  end
end

#################### returnsame_nilkey_objectvalue ####################

shared_examples_for 'returnsame_nilkey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[nil] = value
    store[nil].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[0] = value
    store[0].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[nil] = value
    store[nil].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[0] = value
    store[0].should be_equal(value)
  end
end

#################### persist_nilkey_objectvalue ####################

shared_examples_for 'persist_nilkey_objectvalue' do
  it 'persists values' do
    store[nil] = Value.new(:objval1)
    store.close
    @store = nil
    store[nil].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[0] = Value.new(:objval1)
    store.close
    @store = nil
    store[0].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[nil] = Value.new(:objval2)
    store.close
    @store = nil
    store[nil].should == Value.new(:objval2)
  end

  it 'persists values' do
    store[0] = Value.new(:objval2)
    store.close
    @store = nil
    store[0].should == Value.new(:objval2)
  end
end

#################### null_integerkey_nilvalue ####################

shared_examples_for 'null_integerkey_nilvalue' do
  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = ''
    store[42] = nil
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = ''
    store[-10] = nil
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = nil
    store[42] = ''
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = nil
    store[-10] = ''
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = 0
    store[42] = false
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = 0
    store[-10] = false
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = false
    store[42] = 0
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = false
    store[-10] = 0
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, false, options).should == false
  end
end

#################### store_integerkey_nilvalue ####################

shared_examples_for 'store_integerkey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store[-10] = ''
    store[-10].should == ''
    store.load(-10).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = ''
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(-10, value).should equal(value)
    store[-10].should == ''
    store.load(-10).should == ''
  end

  it 'stores values after clear' do
    store[-10] = ''
    store[42] = nil
    store.clear.should equal(store)
    store[-10] = ''
    store[-10].should == ''
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = ''
    store.delete(-10).should == ''
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = ''
    store[-10].should == ''
    store[-10] = nil
    store[-10].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == ''
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = ''
    store[-10].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[42] = ''
    store[42].should == ''
    store.load(42).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[42] = ''
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(42, value).should equal(value)
    store[42].should == ''
    store.load(42).should == ''
  end

  it 'stores values after clear' do
    store[42] = ''
    store[-10] = nil
    store.clear.should equal(store)
    store[42] = ''
    store[42].should == ''
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = ''
    store.delete(42).should == ''
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = ''
    store[42].should == ''
    store[42] = nil
    store[42].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[42] = value).should equal(value)
    store[42].should == ''
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = ''
    store[42].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = nil
    store[-10].should == nil
    store.load(-10).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = nil
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(-10, value).should equal(value)
    store[-10].should == nil
    store.load(-10).should == nil
  end

  it 'stores values after clear' do
    store[-10] = nil
    store[42] = ''
    store.clear.should equal(store)
    store[-10] = nil
    store[-10].should == nil
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = nil
    store.delete(-10).should == nil
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = nil
    store[-10].should == nil
    store[-10] = ''
    store[-10].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == nil
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = nil
    store[-10].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[42] = nil
    store[42].should == nil
    store.load(42).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[42] = nil
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(42, value).should equal(value)
    store[42].should == nil
    store.load(42).should == nil
  end

  it 'stores values after clear' do
    store[42] = nil
    store[-10] = ''
    store.clear.should equal(store)
    store[42] = nil
    store[42].should == nil
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = nil
    store.delete(42).should == nil
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = nil
    store[42].should == nil
    store[42] = ''
    store[42].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[42] = value).should equal(value)
    store[42].should == nil
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = nil
    store[42].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = 0
    store[-10].should == 0
    store.load(-10).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = 0
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(-10, value).should equal(value)
    store[-10].should == 0
    store.load(-10).should == 0
  end

  it 'stores values after clear' do
    store[-10] = 0
    store[42] = false
    store.clear.should equal(store)
    store[-10] = 0
    store[-10].should == 0
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = 0
    store.delete(-10).should == 0
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = 0
    store[-10].should == 0
    store[-10] = false
    store[-10].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == 0
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = 0
    store[-10].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[42] = 0
    store[42].should == 0
    store.load(42).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[42] = 0
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(42, value).should equal(value)
    store[42].should == 0
    store.load(42).should == 0
  end

  it 'stores values after clear' do
    store[42] = 0
    store[-10] = false
    store.clear.should equal(store)
    store[42] = 0
    store[42].should == 0
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = 0
    store.delete(42).should == 0
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = 0
    store[42].should == 0
    store[42] = false
    store[42].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[42] = value).should equal(value)
    store[42].should == 0
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = 0
    store[42].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = false
    store[-10].should == false
    store.load(-10).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = false
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(-10, value).should equal(value)
    store[-10].should == false
    store.load(-10).should == false
  end

  it 'stores values after clear' do
    store[-10] = false
    store[42] = 0
    store.clear.should equal(store)
    store[-10] = false
    store[-10].should == false
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = false
    store.delete(-10).should == false
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = false
    store[-10].should == false
    store[-10] = 0
    store[-10].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == false
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = false
    store[-10].should == false
  end

  it 'writes values to keys that like a Hash' do
    store[42] = false
    store[42].should == false
    store.load(42).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[42] = false
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(42, value).should equal(value)
    store[42].should == false
    store.load(42).should == false
  end

  it 'stores values after clear' do
    store[42] = false
    store[-10] = 0
    store.clear.should equal(store)
    store[42] = false
    store[42].should == false
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = false
    store.delete(42).should == false
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = false
    store[42].should == false
    store[42] = 0
    store[42].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[42] = value).should equal(value)
    store[42].should == false
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = false
    store[42].should == false
  end
end

#################### persist_integerkey_nilvalue ####################

shared_examples_for 'persist_integerkey_nilvalue' do
  it 'persists values' do
    store[-10] = ''
    store.close
    @store = nil
    store[-10].should == ''
  end

  it 'persists values' do
    store[42] = ''
    store.close
    @store = nil
    store[42].should == ''
  end

  it 'persists values' do
    store[-10] = nil
    store.close
    @store = nil
    store[-10].should == nil
  end

  it 'persists values' do
    store[42] = nil
    store.close
    @store = nil
    store[42].should == nil
  end

  it 'persists values' do
    store[-10] = 0
    store.close
    @store = nil
    store[-10].should == 0
  end

  it 'persists values' do
    store[42] = 0
    store.close
    @store = nil
    store[42].should == 0
  end

  it 'persists values' do
    store[-10] = false
    store.close
    @store = nil
    store[-10].should == false
  end

  it 'persists values' do
    store[42] = false
    store.close
    @store = nil
    store[42].should == false
  end
end

#################### null_integerkey_integervalue ####################

shared_examples_for 'null_integerkey_integervalue' do
  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = 41
    store[42] = -12
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = 41
    store[-10] = -12
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = -12
    store[42] = 41
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = -12
    store[-10] = 41
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, -12, options).should == -12
  end
end

#################### store_integerkey_integervalue ####################

shared_examples_for 'store_integerkey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store[-10] = 41
    store[-10].should == 41
    store.load(-10).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = 41
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(-10, value).should equal(value)
    store[-10].should == 41
    store.load(-10).should == 41
  end

  it 'stores values after clear' do
    store[-10] = 41
    store[42] = -12
    store.clear.should equal(store)
    store[-10] = 41
    store[-10].should == 41
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = 41
    store.delete(-10).should == 41
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = 41
    store[-10].should == 41
    store[-10] = -12
    store[-10].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == 41
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = 41
    store[-10].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = 41
    store.fetch(-10, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = 41
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = 41
    store[42].should == 41
    store.load(42).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[42] = 41
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(42, value).should equal(value)
    store[42].should == 41
    store.load(42).should == 41
  end

  it 'stores values after clear' do
    store[42] = 41
    store[-10] = -12
    store.clear.should equal(store)
    store[42] = 41
    store[42].should == 41
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = 41
    store.delete(42).should == 41
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = 41
    store[42].should == 41
    store[42] = -12
    store[42].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[42] = value).should equal(value)
    store[42].should == 41
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = 41
    store[42].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = 41
    store.fetch(42, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = 41
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = -12
    store[-10].should == -12
    store.load(-10).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = -12
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(-10, value).should equal(value)
    store[-10].should == -12
    store.load(-10).should == -12
  end

  it 'stores values after clear' do
    store[-10] = -12
    store[42] = 41
    store.clear.should equal(store)
    store[-10] = -12
    store[-10].should == -12
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = -12
    store.delete(-10).should == -12
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = -12
    store[-10].should == -12
    store[-10] = 41
    store[-10].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == -12
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = -12
    store[-10].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = -12
    store.fetch(-10, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = -12
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = -12
    store[42].should == -12
    store.load(42).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[42] = -12
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(42, value).should equal(value)
    store[42].should == -12
    store.load(42).should == -12
  end

  it 'stores values after clear' do
    store[42] = -12
    store[-10] = 41
    store.clear.should equal(store)
    store[42] = -12
    store[42].should == -12
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = -12
    store.delete(42).should == -12
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = -12
    store[42].should == -12
    store[42] = 41
    store[42].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[42] = value).should equal(value)
    store[42].should == -12
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = -12
    store[42].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = -12
    store.fetch(42, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = -12
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_integerkey_integervalue ####################

shared_examples_for 'persist_integerkey_integervalue' do
  it 'persists values' do
    store[-10] = 41
    store.close
    @store = nil
    store[-10].should == 41
  end

  it 'persists values' do
    store[42] = 41
    store.close
    @store = nil
    store[42].should == 41
  end

  it 'persists values' do
    store[-10] = -12
    store.close
    @store = nil
    store[-10].should == -12
  end

  it 'persists values' do
    store[42] = -12
    store.close
    @store = nil
    store[42].should == -12
  end
end

#################### null_integerkey_numbervalue ####################

shared_examples_for 'null_integerkey_numbervalue' do
  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = 123.456
    store[42] = -98.7
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = 123.456
    store[-10] = -98.7
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = -98.7
    store[42] = 123.456
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = -98.7
    store[-10] = 123.456
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = 340282366920938463463374607431768211456
    store[42] = 33
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = 340282366920938463463374607431768211456
    store[-10] = 33
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = 33
    store[42] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = 33
    store[-10] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, 33, options).should == 33
  end
end

#################### store_integerkey_numbervalue ####################

shared_examples_for 'store_integerkey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store[-10] = 123.456
    store[-10].should == 123.456
    store.load(-10).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = 123.456
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(-10, value).should equal(value)
    store[-10].should == 123.456
    store.load(-10).should == 123.456
  end

  it 'stores values after clear' do
    store[-10] = 123.456
    store[42] = -98.7
    store.clear.should equal(store)
    store[-10] = 123.456
    store[-10].should == 123.456
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = 123.456
    store.delete(-10).should == 123.456
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = 123.456
    store[-10].should == 123.456
    store[-10] = -98.7
    store[-10].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == 123.456
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = 123.456
    store[-10].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = 123.456
    store.fetch(-10, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = 123.456
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = 123.456
    store[42].should == 123.456
    store.load(42).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[42] = 123.456
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(42, value).should equal(value)
    store[42].should == 123.456
    store.load(42).should == 123.456
  end

  it 'stores values after clear' do
    store[42] = 123.456
    store[-10] = -98.7
    store.clear.should equal(store)
    store[42] = 123.456
    store[42].should == 123.456
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = 123.456
    store.delete(42).should == 123.456
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = 123.456
    store[42].should == 123.456
    store[42] = -98.7
    store[42].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[42] = value).should equal(value)
    store[42].should == 123.456
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = 123.456
    store[42].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = 123.456
    store.fetch(42, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = 123.456
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = -98.7
    store[-10].should == -98.7
    store.load(-10).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = -98.7
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(-10, value).should equal(value)
    store[-10].should == -98.7
    store.load(-10).should == -98.7
  end

  it 'stores values after clear' do
    store[-10] = -98.7
    store[42] = 123.456
    store.clear.should equal(store)
    store[-10] = -98.7
    store[-10].should == -98.7
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = -98.7
    store.delete(-10).should == -98.7
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = -98.7
    store[-10].should == -98.7
    store[-10] = 123.456
    store[-10].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == -98.7
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = -98.7
    store[-10].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = -98.7
    store.fetch(-10, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = -98.7
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = -98.7
    store[42].should == -98.7
    store.load(42).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[42] = -98.7
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(42, value).should equal(value)
    store[42].should == -98.7
    store.load(42).should == -98.7
  end

  it 'stores values after clear' do
    store[42] = -98.7
    store[-10] = 123.456
    store.clear.should equal(store)
    store[42] = -98.7
    store[42].should == -98.7
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = -98.7
    store.delete(42).should == -98.7
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = -98.7
    store[42].should == -98.7
    store[42] = 123.456
    store[42].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[42] = value).should equal(value)
    store[42].should == -98.7
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = -98.7
    store[42].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = -98.7
    store.fetch(42, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = -98.7
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = 340282366920938463463374607431768211456
    store[-10].should == 340282366920938463463374607431768211456
    store.load(-10).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = 340282366920938463463374607431768211456
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(-10, value).should equal(value)
    store[-10].should == 340282366920938463463374607431768211456
    store.load(-10).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[-10] = 340282366920938463463374607431768211456
    store[42] = 33
    store.clear.should equal(store)
    store[-10] = 340282366920938463463374607431768211456
    store[-10].should == 340282366920938463463374607431768211456
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = 340282366920938463463374607431768211456
    store.delete(-10).should == 340282366920938463463374607431768211456
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = 340282366920938463463374607431768211456
    store[-10].should == 340282366920938463463374607431768211456
    store[-10] = 33
    store[-10].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = 340282366920938463463374607431768211456
    store[-10].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = 340282366920938463463374607431768211456
    store.fetch(-10, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = 340282366920938463463374607431768211456
    store[42].should == 340282366920938463463374607431768211456
    store.load(42).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[42] = 340282366920938463463374607431768211456
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(42, value).should equal(value)
    store[42].should == 340282366920938463463374607431768211456
    store.load(42).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[42] = 340282366920938463463374607431768211456
    store[-10] = 33
    store.clear.should equal(store)
    store[42] = 340282366920938463463374607431768211456
    store[42].should == 340282366920938463463374607431768211456
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = 340282366920938463463374607431768211456
    store.delete(42).should == 340282366920938463463374607431768211456
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = 340282366920938463463374607431768211456
    store[42].should == 340282366920938463463374607431768211456
    store[42] = 33
    store[42].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[42] = value).should equal(value)
    store[42].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = 340282366920938463463374607431768211456
    store[42].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = 340282366920938463463374607431768211456
    store.fetch(42, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = 33
    store[-10].should == 33
    store.load(-10).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = 33
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(-10, value).should equal(value)
    store[-10].should == 33
    store.load(-10).should == 33
  end

  it 'stores values after clear' do
    store[-10] = 33
    store[42] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[-10] = 33
    store[-10].should == 33
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = 33
    store.delete(-10).should == 33
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = 33
    store[-10].should == 33
    store[-10] = 340282366920938463463374607431768211456
    store[-10].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == 33
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = 33
    store[-10].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = 33
    store.fetch(-10, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = 33
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = 33
    store[42].should == 33
    store.load(42).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[42] = 33
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(42, value).should equal(value)
    store[42].should == 33
    store.load(42).should == 33
  end

  it 'stores values after clear' do
    store[42] = 33
    store[-10] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[42] = 33
    store[42].should == 33
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = 33
    store.delete(42).should == 33
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = 33
    store[42].should == 33
    store[42] = 340282366920938463463374607431768211456
    store[42].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[42] = value).should equal(value)
    store[42].should == 33
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = 33
    store[42].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = 33
    store.fetch(42, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = 33
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_integerkey_numbervalue ####################

shared_examples_for 'persist_integerkey_numbervalue' do
  it 'persists values' do
    store[-10] = 123.456
    store.close
    @store = nil
    store[-10].should == 123.456
  end

  it 'persists values' do
    store[42] = 123.456
    store.close
    @store = nil
    store[42].should == 123.456
  end

  it 'persists values' do
    store[-10] = -98.7
    store.close
    @store = nil
    store[-10].should == -98.7
  end

  it 'persists values' do
    store[42] = -98.7
    store.close
    @store = nil
    store[42].should == -98.7
  end

  it 'persists values' do
    store[-10] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[-10].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[42] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[42].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[-10] = 33
    store.close
    @store = nil
    store[-10].should == 33
  end

  it 'persists values' do
    store[42] = 33
    store.close
    @store = nil
    store[42].should == 33
  end
end

#################### null_integerkey_booleanvalue ####################

shared_examples_for 'null_integerkey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = true
    store[42] = false
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = true
    store[-10] = false
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = false
    store[42] = true
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = false
    store[-10] = true
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, false, options).should == false
  end
end

#################### store_integerkey_booleanvalue ####################

shared_examples_for 'store_integerkey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store[-10] = true
    store[-10].should == true
    store.load(-10).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = true
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(-10, value).should equal(value)
    store[-10].should == true
    store.load(-10).should == true
  end

  it 'stores values after clear' do
    store[-10] = true
    store[42] = false
    store.clear.should equal(store)
    store[-10] = true
    store[-10].should == true
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = true
    store.delete(-10).should == true
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = true
    store[-10].should == true
    store[-10] = false
    store[-10].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == true
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = true
    store[-10].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = true
    store.fetch(-10, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = true
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = true
    store[42].should == true
    store.load(42).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[42] = true
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(42, value).should equal(value)
    store[42].should == true
    store.load(42).should == true
  end

  it 'stores values after clear' do
    store[42] = true
    store[-10] = false
    store.clear.should equal(store)
    store[42] = true
    store[42].should == true
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = true
    store.delete(42).should == true
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = true
    store[42].should == true
    store[42] = false
    store[42].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[42] = value).should equal(value)
    store[42].should == true
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = true
    store[42].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = true
    store.fetch(42, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = true
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = false
    store[-10].should == false
    store.load(-10).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = false
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(-10, value).should equal(value)
    store[-10].should == false
    store.load(-10).should == false
  end

  it 'stores values after clear' do
    store[-10] = false
    store[42] = true
    store.clear.should equal(store)
    store[-10] = false
    store[-10].should == false
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = false
    store.delete(-10).should == false
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = false
    store[-10].should == false
    store[-10] = true
    store[-10].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == false
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = false
    store[-10].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = false
    store.fetch(-10, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = false
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = false
    store[42].should == false
    store.load(42).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[42] = false
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(42, value).should equal(value)
    store[42].should == false
    store.load(42).should == false
  end

  it 'stores values after clear' do
    store[42] = false
    store[-10] = true
    store.clear.should equal(store)
    store[42] = false
    store[42].should == false
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = false
    store.delete(42).should == false
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = false
    store[42].should == false
    store[42] = true
    store[42].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[42] = value).should equal(value)
    store[42].should == false
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = false
    store[42].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = false
    store.fetch(42, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = false
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_integerkey_booleanvalue ####################

shared_examples_for 'persist_integerkey_booleanvalue' do
  it 'persists values' do
    store[-10] = true
    store.close
    @store = nil
    store[-10].should == true
  end

  it 'persists values' do
    store[42] = true
    store.close
    @store = nil
    store[42].should == true
  end

  it 'persists values' do
    store[-10] = false
    store.close
    @store = nil
    store[-10].should == false
  end

  it 'persists values' do
    store[42] = false
    store.close
    @store = nil
    store[42].should == false
  end
end

#################### null_integerkey_stringvalue ####################

shared_examples_for 'null_integerkey_stringvalue' do
  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = "strval1"
    store[42] = "strval2"
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = "strval1"
    store[-10] = "strval2"
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = "strval2"
    store[42] = "strval1"
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = "strval2"
    store[-10] = "strval1"
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, "strval2", options).should == "strval2"
  end
end

#################### store_integerkey_stringvalue ####################

shared_examples_for 'store_integerkey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store[-10] = "strval1"
    store[-10].should == "strval1"
    store.load(-10).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = "strval1"
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(-10, value).should equal(value)
    store[-10].should == "strval1"
    store.load(-10).should == "strval1"
  end

  it 'stores values after clear' do
    store[-10] = "strval1"
    store[42] = "strval2"
    store.clear.should equal(store)
    store[-10] = "strval1"
    store[-10].should == "strval1"
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = "strval1"
    store.delete(-10).should == "strval1"
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = "strval1"
    store[-10].should == "strval1"
    store[-10] = "strval2"
    store[-10].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[-10] = value).should equal(value)
    store[-10].should == "strval1"
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = "strval1"
    store[-10].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = "strval1"
    store.fetch(-10, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = "strval1"
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = "strval1"
    store[42].should == "strval1"
    store.load(42).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[42] = "strval1"
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(42, value).should equal(value)
    store[42].should == "strval1"
    store.load(42).should == "strval1"
  end

  it 'stores values after clear' do
    store[42] = "strval1"
    store[-10] = "strval2"
    store.clear.should equal(store)
    store[42] = "strval1"
    store[42].should == "strval1"
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = "strval1"
    store.delete(42).should == "strval1"
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = "strval1"
    store[42].should == "strval1"
    store[42] = "strval2"
    store[42].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[42] = value).should equal(value)
    store[42].should == "strval1"
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = "strval1"
    store[42].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = "strval1"
    store.fetch(42, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = "strval1"
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = "strval2"
    store[-10].should == "strval2"
    store.load(-10).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = "strval2"
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(-10, value).should equal(value)
    store[-10].should == "strval2"
    store.load(-10).should == "strval2"
  end

  it 'stores values after clear' do
    store[-10] = "strval2"
    store[42] = "strval1"
    store.clear.should equal(store)
    store[-10] = "strval2"
    store[-10].should == "strval2"
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = "strval2"
    store.delete(-10).should == "strval2"
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = "strval2"
    store[-10].should == "strval2"
    store[-10] = "strval1"
    store[-10].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[-10] = value).should equal(value)
    store[-10].should == "strval2"
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = "strval2"
    store[-10].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = "strval2"
    store.fetch(-10, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = "strval2"
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = "strval2"
    store[42].should == "strval2"
    store.load(42).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[42] = "strval2"
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(42, value).should equal(value)
    store[42].should == "strval2"
    store.load(42).should == "strval2"
  end

  it 'stores values after clear' do
    store[42] = "strval2"
    store[-10] = "strval1"
    store.clear.should equal(store)
    store[42] = "strval2"
    store[42].should == "strval2"
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = "strval2"
    store.delete(42).should == "strval2"
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = "strval2"
    store[42].should == "strval2"
    store[42] = "strval1"
    store[42].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[42] = value).should equal(value)
    store[42].should == "strval2"
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = "strval2"
    store[42].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = "strval2"
    store.fetch(42, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = "strval2"
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_integerkey_stringvalue ####################

shared_examples_for 'returndifferent_integerkey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[-10] = value
    store[-10].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[42] = value
    store[42].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[-10] = value
    store[-10].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[42] = value
    store[42].should_not be_equal(value)
  end
end

#################### returnsame_integerkey_stringvalue ####################

shared_examples_for 'returnsame_integerkey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[-10] = value
    store[-10].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[42] = value
    store[42].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[-10] = value
    store[-10].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[42] = value
    store[42].should be_equal(value)
  end
end

#################### persist_integerkey_stringvalue ####################

shared_examples_for 'persist_integerkey_stringvalue' do
  it 'persists values' do
    store[-10] = "strval1"
    store.close
    @store = nil
    store[-10].should == "strval1"
  end

  it 'persists values' do
    store[42] = "strval1"
    store.close
    @store = nil
    store[42].should == "strval1"
  end

  it 'persists values' do
    store[-10] = "strval2"
    store.close
    @store = nil
    store[-10].should == "strval2"
  end

  it 'persists values' do
    store[42] = "strval2"
    store.close
    @store = nil
    store[42].should == "strval2"
  end
end

#################### null_integerkey_binaryvalue ####################

shared_examples_for 'null_integerkey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = "ber"
    store[42] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = "ber"
    store[-10] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = "\xAA\xBB\xCC"
    store[42] = "ber"
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = "\xAA\xBB\xCC"
    store[-10] = "ber"
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_integerkey_binaryvalue ####################

shared_examples_for 'store_integerkey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store[-10] = "ber"
    store[-10].should == "ber"
    store.load(-10).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = "ber"
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(-10, value).should equal(value)
    store[-10].should == "ber"
    store.load(-10).should == "ber"
  end

  it 'stores values after clear' do
    store[-10] = "ber"
    store[42] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[-10] = "ber"
    store[-10].should == "ber"
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = "ber"
    store.delete(-10).should == "ber"
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = "ber"
    store[-10].should == "ber"
    store[-10] = "\xAA\xBB\xCC"
    store[-10].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[-10] = value).should equal(value)
    store[-10].should == "ber"
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = "ber"
    store[-10].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = "ber"
    store.fetch(-10, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = "ber"
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = "ber"
    store[42].should == "ber"
    store.load(42).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[42] = "ber"
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(42, value).should equal(value)
    store[42].should == "ber"
    store.load(42).should == "ber"
  end

  it 'stores values after clear' do
    store[42] = "ber"
    store[-10] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[42] = "ber"
    store[42].should == "ber"
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = "ber"
    store.delete(42).should == "ber"
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = "ber"
    store[42].should == "ber"
    store[42] = "\xAA\xBB\xCC"
    store[42].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[42] = value).should equal(value)
    store[42].should == "ber"
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = "ber"
    store[42].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = "ber"
    store.fetch(42, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = "ber"
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = "\xAA\xBB\xCC"
    store[-10].should == "\xAA\xBB\xCC"
    store.load(-10).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = "\xAA\xBB\xCC"
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(-10, value).should equal(value)
    store[-10].should == "\xAA\xBB\xCC"
    store.load(-10).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[-10] = "\xAA\xBB\xCC"
    store[42] = "ber"
    store.clear.should equal(store)
    store[-10] = "\xAA\xBB\xCC"
    store[-10].should == "\xAA\xBB\xCC"
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = "\xAA\xBB\xCC"
    store.delete(-10).should == "\xAA\xBB\xCC"
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = "\xAA\xBB\xCC"
    store[-10].should == "\xAA\xBB\xCC"
    store[-10] = "ber"
    store[-10].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[-10] = value).should equal(value)
    store[-10].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = "\xAA\xBB\xCC"
    store[-10].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = "\xAA\xBB\xCC"
    store.fetch(-10, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = "\xAA\xBB\xCC"
    store[42].should == "\xAA\xBB\xCC"
    store.load(42).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[42] = "\xAA\xBB\xCC"
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(42, value).should equal(value)
    store[42].should == "\xAA\xBB\xCC"
    store.load(42).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[42] = "\xAA\xBB\xCC"
    store[-10] = "ber"
    store.clear.should equal(store)
    store[42] = "\xAA\xBB\xCC"
    store[42].should == "\xAA\xBB\xCC"
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = "\xAA\xBB\xCC"
    store.delete(42).should == "\xAA\xBB\xCC"
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = "\xAA\xBB\xCC"
    store[42].should == "\xAA\xBB\xCC"
    store[42] = "ber"
    store[42].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[42] = value).should equal(value)
    store[42].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = "\xAA\xBB\xCC"
    store[42].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = "\xAA\xBB\xCC"
    store.fetch(42, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_integerkey_binaryvalue ####################

shared_examples_for 'returndifferent_integerkey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[-10] = value
    store[-10].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[42] = value
    store[42].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[-10] = value
    store[-10].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[42] = value
    store[42].should_not be_equal(value)
  end
end

#################### returnsame_integerkey_binaryvalue ####################

shared_examples_for 'returnsame_integerkey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[-10] = value
    store[-10].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[42] = value
    store[42].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[-10] = value
    store[-10].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[42] = value
    store[42].should be_equal(value)
  end
end

#################### persist_integerkey_binaryvalue ####################

shared_examples_for 'persist_integerkey_binaryvalue' do
  it 'persists values' do
    store[-10] = "ber"
    store.close
    @store = nil
    store[-10].should == "ber"
  end

  it 'persists values' do
    store[42] = "ber"
    store.close
    @store = nil
    store[42].should == "ber"
  end

  it 'persists values' do
    store[-10] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[-10].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store[42] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[42].should == "\xAA\xBB\xCC"
  end
end

#################### null_integerkey_hashvalue ####################

shared_examples_for 'null_integerkey_hashvalue' do
  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = {"hashval1"=>["array1", 1]}
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_integerkey_hashvalue ####################

shared_examples_for 'store_integerkey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[-10].should == {"hashval1"=>["array1", 1]}
    store.load(-10).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = {"hashval1"=>["array1", 1]}
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(-10, value).should equal(value)
    store[-10].should == {"hashval1"=>["array1", 1]}
    store.load(-10).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[-10] = {"hashval1"=>["array1", 1]}
    store[-10].should == {"hashval1"=>["array1", 1]}
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = {"hashval1"=>["array1", 1]}
    store.delete(-10).should == {"hashval1"=>["array1", 1]}
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = {"hashval1"=>["array1", 1]}
    store[-10].should == {"hashval1"=>["array1", 1]}
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[-10].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = {"hashval1"=>["array1", 1]}
    store.fetch(-10, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = {"hashval1"=>["array1", 1]}
    store[42].should == {"hashval1"=>["array1", 1]}
    store.load(42).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[42] = {"hashval1"=>["array1", 1]}
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(42, value).should equal(value)
    store[42].should == {"hashval1"=>["array1", 1]}
    store.load(42).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[42] = {"hashval1"=>["array1", 1]}
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[42] = {"hashval1"=>["array1", 1]}
    store[42].should == {"hashval1"=>["array1", 1]}
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = {"hashval1"=>["array1", 1]}
    store.delete(42).should == {"hashval1"=>["array1", 1]}
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = {"hashval1"=>["array1", 1]}
    store[42].should == {"hashval1"=>["array1", 1]}
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[42] = value).should equal(value)
    store[42].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[42].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = {"hashval1"=>["array1", 1]}
    store.fetch(42, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(-10).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(-10, value).should equal(value)
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(-10).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(-10).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10] = {"hashval1"=>["array1", 1]}
    store[-10].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[-10] = value).should equal(value)
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(-10, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(42).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(42, value).should equal(value)
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(42).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(42).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42] = {"hashval1"=>["array1", 1]}
    store[42].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[42] = value).should equal(value)
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(42, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_integerkey_hashvalue ####################

shared_examples_for 'returndifferent_integerkey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[-10] = value
    store[-10].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[42] = value
    store[42].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10] = value
    store[-10].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42] = value
    store[42].should_not be_equal(value)
  end
end

#################### returnsame_integerkey_hashvalue ####################

shared_examples_for 'returnsame_integerkey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[-10] = value
    store[-10].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[42] = value
    store[42].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-10] = value
    store[-10].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[42] = value
    store[42].should be_equal(value)
  end
end

#################### persist_integerkey_hashvalue ####################

shared_examples_for 'persist_integerkey_hashvalue' do
  it 'persists values' do
    store[-10] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[-10].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[42] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[42].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[-10] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[-10].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store[42] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[42].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_integerkey_objectvalue ####################

shared_examples_for 'null_integerkey_objectvalue' do
  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = Value.new(:objval1)
    store[42] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = Value.new(:objval1)
    store[-10] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[-10].should be_nil
    store.load(-10).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[-10] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-10).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-10).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-10] = Value.new(:objval2)
    store[42] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(-10).should be_false
    store.key?(42).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-10, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -10
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-10, options).should be_false
    store.load(-10, options).should be_nil
    store.fetch(-10, 42, options).should == 42
    store.fetch(-10, options) { 42 }.should == 42
    store.delete(-10, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-10, Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store[42].should be_nil
    store.load(42).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[42] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(42).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(42).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[42] = Value.new(:objval2)
    store[-10] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(42).should be_false
    store.key?(-10).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(42, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 42
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(42, options).should be_false
    store.load(42, options).should be_nil
    store.fetch(42, 42, options).should == 42
    store.fetch(42, options) { 42 }.should == 42
    store.delete(42, options).should be_nil
    store.clear(options).should equal(store)
    store.store(42, Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_integerkey_objectvalue ####################

shared_examples_for 'store_integerkey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store[-10] = Value.new(:objval1)
    store[-10].should == Value.new(:objval1)
    store.load(-10).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = Value.new(:objval1)
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(-10, value).should equal(value)
    store[-10].should == Value.new(:objval1)
    store.load(-10).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[-10] = Value.new(:objval1)
    store[42] = Value.new(:objval2)
    store.clear.should equal(store)
    store[-10] = Value.new(:objval1)
    store[-10].should == Value.new(:objval1)
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = Value.new(:objval1)
    store.delete(-10).should == Value.new(:objval1)
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = Value.new(:objval1)
    store[-10].should == Value.new(:objval1)
    store[-10] = Value.new(:objval2)
    store[-10].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[-10] = value).should equal(value)
    store[-10].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = Value.new(:objval1)
    store[-10].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = Value.new(:objval1)
    store.fetch(-10, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = Value.new(:objval1)
    store[42].should == Value.new(:objval1)
    store.load(42).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[42] = Value.new(:objval1)
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(42, value).should equal(value)
    store[42].should == Value.new(:objval1)
    store.load(42).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[42] = Value.new(:objval1)
    store[-10] = Value.new(:objval2)
    store.clear.should equal(store)
    store[42] = Value.new(:objval1)
    store[42].should == Value.new(:objval1)
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = Value.new(:objval1)
    store.delete(42).should == Value.new(:objval1)
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = Value.new(:objval1)
    store[42].should == Value.new(:objval1)
    store[42] = Value.new(:objval2)
    store[42].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[42] = value).should equal(value)
    store[42].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = Value.new(:objval1)
    store[42].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = Value.new(:objval1)
    store.fetch(42, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-10] = Value.new(:objval2)
    store[-10].should == Value.new(:objval2)
    store.load(-10).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[-10] = Value.new(:objval2)
    store.key?(-10).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(-10, value).should equal(value)
    store[-10].should == Value.new(:objval2)
    store.load(-10).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[-10] = Value.new(:objval2)
    store[42] = Value.new(:objval1)
    store.clear.should equal(store)
    store[-10] = Value.new(:objval2)
    store[-10].should == Value.new(:objval2)
    store[42].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-10] = Value.new(:objval2)
    store.delete(-10).should == Value.new(:objval2)
    store.key?(-10).should be_false
  end

  it 'overwrites existing values' do
    store[-10] = Value.new(:objval2)
    store[-10].should == Value.new(:objval2)
    store[-10] = Value.new(:objval1)
    store[-10].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[-10] = value).should equal(value)
    store[-10].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = -10.freeze
    store[key] = Value.new(:objval2)
    store[-10].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-10] = Value.new(:objval2)
    store.fetch(-10, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[-10] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(-10) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[42] = Value.new(:objval2)
    store[42].should == Value.new(:objval2)
    store.load(42).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[42] = Value.new(:objval2)
    store.key?(42).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(42, value).should equal(value)
    store[42].should == Value.new(:objval2)
    store.load(42).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[42] = Value.new(:objval2)
    store[-10] = Value.new(:objval1)
    store.clear.should equal(store)
    store[42] = Value.new(:objval2)
    store[42].should == Value.new(:objval2)
    store[-10].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[42] = Value.new(:objval2)
    store.delete(42).should == Value.new(:objval2)
    store.key?(42).should be_false
  end

  it 'overwrites existing values' do
    store[42] = Value.new(:objval2)
    store[42].should == Value.new(:objval2)
    store[42] = Value.new(:objval1)
    store[42].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[42] = value).should equal(value)
    store[42].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = 42.freeze
    store[key] = Value.new(:objval2)
    store[42].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[42] = Value.new(:objval2)
    store.fetch(42, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[42] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(42) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_integerkey_objectvalue ####################

shared_examples_for 'returndifferent_integerkey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[-10] = value
    store[-10].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[42] = value
    store[42].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[-10] = value
    store[-10].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[42] = value
    store[42].should_not be_equal(value)
  end
end

#################### returnsame_integerkey_objectvalue ####################

shared_examples_for 'returnsame_integerkey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[-10] = value
    store[-10].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[42] = value
    store[42].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[-10] = value
    store[-10].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[42] = value
    store[42].should be_equal(value)
  end
end

#################### persist_integerkey_objectvalue ####################

shared_examples_for 'persist_integerkey_objectvalue' do
  it 'persists values' do
    store[-10] = Value.new(:objval1)
    store.close
    @store = nil
    store[-10].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[42] = Value.new(:objval1)
    store.close
    @store = nil
    store[42].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[-10] = Value.new(:objval2)
    store.close
    @store = nil
    store[-10].should == Value.new(:objval2)
  end

  it 'persists values' do
    store[42] = Value.new(:objval2)
    store.close
    @store = nil
    store[42].should == Value.new(:objval2)
  end
end

#################### null_numberkey_nilvalue ####################

shared_examples_for 'null_numberkey_nilvalue' do
  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = ''
    store[-0.3] = nil
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = ''
    store[0.5] = nil
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = nil
    store[-0.3] = ''
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = nil
    store[0.5] = ''
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = 0
    store[-0.3] = false
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = 0
    store[0.5] = false
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = false
    store[-0.3] = 0
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = false
    store[0.5] = 0
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = ''
    store[99] = nil
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = ''
    store[170141183460469231731687303715884105728] = nil
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = nil
    store[99] = ''
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = nil
    store[170141183460469231731687303715884105728] = ''
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = 0
    store[99] = false
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = 0
    store[170141183460469231731687303715884105728] = false
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = false
    store[99] = 0
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = false
    store[170141183460469231731687303715884105728] = 0
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, false, options).should == false
  end
end

#################### store_numberkey_nilvalue ####################

shared_examples_for 'store_numberkey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store[0.5] = ''
    store[0.5].should == ''
    store.load(0.5).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = ''
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(0.5, value).should equal(value)
    store[0.5].should == ''
    store.load(0.5).should == ''
  end

  it 'stores values after clear' do
    store[0.5] = ''
    store[-0.3] = nil
    store.clear.should equal(store)
    store[0.5] = ''
    store[0.5].should == ''
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = ''
    store.delete(0.5).should == ''
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = ''
    store[0.5].should == ''
    store[0.5] = nil
    store[0.5].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == ''
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = ''
    store[0.5].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = ''
    store[-0.3].should == ''
    store.load(-0.3).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = ''
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == ''
    store.load(-0.3).should == ''
  end

  it 'stores values after clear' do
    store[-0.3] = ''
    store[0.5] = nil
    store.clear.should equal(store)
    store[-0.3] = ''
    store[-0.3].should == ''
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = ''
    store.delete(-0.3).should == ''
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = ''
    store[-0.3].should == ''
    store[-0.3] = nil
    store[-0.3].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == ''
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = ''
    store[-0.3].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = nil
    store[0.5].should == nil
    store.load(0.5).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = nil
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(0.5, value).should equal(value)
    store[0.5].should == nil
    store.load(0.5).should == nil
  end

  it 'stores values after clear' do
    store[0.5] = nil
    store[-0.3] = ''
    store.clear.should equal(store)
    store[0.5] = nil
    store[0.5].should == nil
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = nil
    store.delete(0.5).should == nil
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = nil
    store[0.5].should == nil
    store[0.5] = ''
    store[0.5].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == nil
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = nil
    store[0.5].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = nil
    store[-0.3].should == nil
    store.load(-0.3).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = nil
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == nil
    store.load(-0.3).should == nil
  end

  it 'stores values after clear' do
    store[-0.3] = nil
    store[0.5] = ''
    store.clear.should equal(store)
    store[-0.3] = nil
    store[-0.3].should == nil
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = nil
    store.delete(-0.3).should == nil
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = nil
    store[-0.3].should == nil
    store[-0.3] = ''
    store[-0.3].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == nil
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = nil
    store[-0.3].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = 0
    store[0.5].should == 0
    store.load(0.5).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = 0
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(0.5, value).should equal(value)
    store[0.5].should == 0
    store.load(0.5).should == 0
  end

  it 'stores values after clear' do
    store[0.5] = 0
    store[-0.3] = false
    store.clear.should equal(store)
    store[0.5] = 0
    store[0.5].should == 0
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = 0
    store.delete(0.5).should == 0
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = 0
    store[0.5].should == 0
    store[0.5] = false
    store[0.5].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == 0
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = 0
    store[0.5].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = 0
    store[-0.3].should == 0
    store.load(-0.3).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = 0
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == 0
    store.load(-0.3).should == 0
  end

  it 'stores values after clear' do
    store[-0.3] = 0
    store[0.5] = false
    store.clear.should equal(store)
    store[-0.3] = 0
    store[-0.3].should == 0
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = 0
    store.delete(-0.3).should == 0
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = 0
    store[-0.3].should == 0
    store[-0.3] = false
    store[-0.3].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == 0
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = 0
    store[-0.3].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = false
    store[0.5].should == false
    store.load(0.5).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = false
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(0.5, value).should equal(value)
    store[0.5].should == false
    store.load(0.5).should == false
  end

  it 'stores values after clear' do
    store[0.5] = false
    store[-0.3] = 0
    store.clear.should equal(store)
    store[0.5] = false
    store[0.5].should == false
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = false
    store.delete(0.5).should == false
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = false
    store[0.5].should == false
    store[0.5] = 0
    store[0.5].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == false
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = false
    store[0.5].should == false
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = false
    store[-0.3].should == false
    store.load(-0.3).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = false
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == false
    store.load(-0.3).should == false
  end

  it 'stores values after clear' do
    store[-0.3] = false
    store[0.5] = 0
    store.clear.should equal(store)
    store[-0.3] = false
    store[-0.3].should == false
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = false
    store.delete(-0.3).should == false
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = false
    store[-0.3].should == false
    store[-0.3] = 0
    store[-0.3].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == false
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = false
    store[-0.3].should == false
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = ''
    store[170141183460469231731687303715884105728].should == ''
    store.load(170141183460469231731687303715884105728).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = ''
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == ''
    store.load(170141183460469231731687303715884105728).should == ''
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = ''
    store[99] = nil
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = ''
    store[170141183460469231731687303715884105728].should == ''
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = ''
    store.delete(170141183460469231731687303715884105728).should == ''
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = ''
    store[170141183460469231731687303715884105728].should == ''
    store[170141183460469231731687303715884105728] = nil
    store[170141183460469231731687303715884105728].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == ''
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = ''
    store[170141183460469231731687303715884105728].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[99] = ''
    store[99].should == ''
    store.load(99).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[99] = ''
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(99, value).should equal(value)
    store[99].should == ''
    store.load(99).should == ''
  end

  it 'stores values after clear' do
    store[99] = ''
    store[170141183460469231731687303715884105728] = nil
    store.clear.should equal(store)
    store[99] = ''
    store[99].should == ''
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = ''
    store.delete(99).should == ''
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = ''
    store[99].should == ''
    store[99] = nil
    store[99].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[99] = value).should equal(value)
    store[99].should == ''
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = ''
    store[99].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = nil
    store[170141183460469231731687303715884105728].should == nil
    store.load(170141183460469231731687303715884105728).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = nil
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == nil
    store.load(170141183460469231731687303715884105728).should == nil
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = nil
    store[99] = ''
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = nil
    store[170141183460469231731687303715884105728].should == nil
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = nil
    store.delete(170141183460469231731687303715884105728).should == nil
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = nil
    store[170141183460469231731687303715884105728].should == nil
    store[170141183460469231731687303715884105728] = ''
    store[170141183460469231731687303715884105728].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == nil
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = nil
    store[170141183460469231731687303715884105728].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[99] = nil
    store[99].should == nil
    store.load(99).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[99] = nil
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(99, value).should equal(value)
    store[99].should == nil
    store.load(99).should == nil
  end

  it 'stores values after clear' do
    store[99] = nil
    store[170141183460469231731687303715884105728] = ''
    store.clear.should equal(store)
    store[99] = nil
    store[99].should == nil
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = nil
    store.delete(99).should == nil
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = nil
    store[99].should == nil
    store[99] = ''
    store[99].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[99] = value).should equal(value)
    store[99].should == nil
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = nil
    store[99].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = 0
    store[170141183460469231731687303715884105728].should == 0
    store.load(170141183460469231731687303715884105728).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = 0
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == 0
    store.load(170141183460469231731687303715884105728).should == 0
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = 0
    store[99] = false
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = 0
    store[170141183460469231731687303715884105728].should == 0
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = 0
    store.delete(170141183460469231731687303715884105728).should == 0
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = 0
    store[170141183460469231731687303715884105728].should == 0
    store[170141183460469231731687303715884105728] = false
    store[170141183460469231731687303715884105728].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == 0
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = 0
    store[170141183460469231731687303715884105728].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[99] = 0
    store[99].should == 0
    store.load(99).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[99] = 0
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(99, value).should equal(value)
    store[99].should == 0
    store.load(99).should == 0
  end

  it 'stores values after clear' do
    store[99] = 0
    store[170141183460469231731687303715884105728] = false
    store.clear.should equal(store)
    store[99] = 0
    store[99].should == 0
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = 0
    store.delete(99).should == 0
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = 0
    store[99].should == 0
    store[99] = false
    store[99].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[99] = value).should equal(value)
    store[99].should == 0
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = 0
    store[99].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = false
    store[170141183460469231731687303715884105728].should == false
    store.load(170141183460469231731687303715884105728).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = false
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == false
    store.load(170141183460469231731687303715884105728).should == false
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = false
    store[99] = 0
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = false
    store[170141183460469231731687303715884105728].should == false
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = false
    store.delete(170141183460469231731687303715884105728).should == false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = false
    store[170141183460469231731687303715884105728].should == false
    store[170141183460469231731687303715884105728] = 0
    store[170141183460469231731687303715884105728].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == false
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = false
    store[170141183460469231731687303715884105728].should == false
  end

  it 'writes values to keys that like a Hash' do
    store[99] = false
    store[99].should == false
    store.load(99).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[99] = false
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(99, value).should equal(value)
    store[99].should == false
    store.load(99).should == false
  end

  it 'stores values after clear' do
    store[99] = false
    store[170141183460469231731687303715884105728] = 0
    store.clear.should equal(store)
    store[99] = false
    store[99].should == false
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = false
    store.delete(99).should == false
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = false
    store[99].should == false
    store[99] = 0
    store[99].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[99] = value).should equal(value)
    store[99].should == false
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = false
    store[99].should == false
  end
end

#################### persist_numberkey_nilvalue ####################

shared_examples_for 'persist_numberkey_nilvalue' do
  it 'persists values' do
    store[0.5] = ''
    store.close
    @store = nil
    store[0.5].should == ''
  end

  it 'persists values' do
    store[-0.3] = ''
    store.close
    @store = nil
    store[-0.3].should == ''
  end

  it 'persists values' do
    store[0.5] = nil
    store.close
    @store = nil
    store[0.5].should == nil
  end

  it 'persists values' do
    store[-0.3] = nil
    store.close
    @store = nil
    store[-0.3].should == nil
  end

  it 'persists values' do
    store[0.5] = 0
    store.close
    @store = nil
    store[0.5].should == 0
  end

  it 'persists values' do
    store[-0.3] = 0
    store.close
    @store = nil
    store[-0.3].should == 0
  end

  it 'persists values' do
    store[0.5] = false
    store.close
    @store = nil
    store[0.5].should == false
  end

  it 'persists values' do
    store[-0.3] = false
    store.close
    @store = nil
    store[-0.3].should == false
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = ''
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == ''
  end

  it 'persists values' do
    store[99] = ''
    store.close
    @store = nil
    store[99].should == ''
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = nil
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == nil
  end

  it 'persists values' do
    store[99] = nil
    store.close
    @store = nil
    store[99].should == nil
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = 0
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == 0
  end

  it 'persists values' do
    store[99] = 0
    store.close
    @store = nil
    store[99].should == 0
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = false
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == false
  end

  it 'persists values' do
    store[99] = false
    store.close
    @store = nil
    store[99].should == false
  end
end

#################### null_numberkey_integervalue ####################

shared_examples_for 'null_numberkey_integervalue' do
  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = 41
    store[-0.3] = -12
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = 41
    store[0.5] = -12
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = -12
    store[-0.3] = 41
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = -12
    store[0.5] = 41
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = 41
    store[99] = -12
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = 41
    store[170141183460469231731687303715884105728] = -12
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = -12
    store[99] = 41
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = -12
    store[170141183460469231731687303715884105728] = 41
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, -12, options).should == -12
  end
end

#################### store_numberkey_integervalue ####################

shared_examples_for 'store_numberkey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store[0.5] = 41
    store[0.5].should == 41
    store.load(0.5).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = 41
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(0.5, value).should equal(value)
    store[0.5].should == 41
    store.load(0.5).should == 41
  end

  it 'stores values after clear' do
    store[0.5] = 41
    store[-0.3] = -12
    store.clear.should equal(store)
    store[0.5] = 41
    store[0.5].should == 41
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = 41
    store.delete(0.5).should == 41
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = 41
    store[0.5].should == 41
    store[0.5] = -12
    store[0.5].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == 41
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = 41
    store[0.5].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = 41
    store.fetch(0.5, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = 41
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = 41
    store[-0.3].should == 41
    store.load(-0.3).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = 41
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == 41
    store.load(-0.3).should == 41
  end

  it 'stores values after clear' do
    store[-0.3] = 41
    store[0.5] = -12
    store.clear.should equal(store)
    store[-0.3] = 41
    store[-0.3].should == 41
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = 41
    store.delete(-0.3).should == 41
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = 41
    store[-0.3].should == 41
    store[-0.3] = -12
    store[-0.3].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == 41
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = 41
    store[-0.3].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = 41
    store.fetch(-0.3, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = 41
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = -12
    store[0.5].should == -12
    store.load(0.5).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = -12
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(0.5, value).should equal(value)
    store[0.5].should == -12
    store.load(0.5).should == -12
  end

  it 'stores values after clear' do
    store[0.5] = -12
    store[-0.3] = 41
    store.clear.should equal(store)
    store[0.5] = -12
    store[0.5].should == -12
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = -12
    store.delete(0.5).should == -12
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = -12
    store[0.5].should == -12
    store[0.5] = 41
    store[0.5].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == -12
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = -12
    store[0.5].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = -12
    store.fetch(0.5, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = -12
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = -12
    store[-0.3].should == -12
    store.load(-0.3).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = -12
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == -12
    store.load(-0.3).should == -12
  end

  it 'stores values after clear' do
    store[-0.3] = -12
    store[0.5] = 41
    store.clear.should equal(store)
    store[-0.3] = -12
    store[-0.3].should == -12
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = -12
    store.delete(-0.3).should == -12
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = -12
    store[-0.3].should == -12
    store[-0.3] = 41
    store[-0.3].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == -12
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = -12
    store[-0.3].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = -12
    store.fetch(-0.3, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = -12
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = 41
    store[170141183460469231731687303715884105728].should == 41
    store.load(170141183460469231731687303715884105728).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = 41
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == 41
    store.load(170141183460469231731687303715884105728).should == 41
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = 41
    store[99] = -12
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = 41
    store[170141183460469231731687303715884105728].should == 41
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = 41
    store.delete(170141183460469231731687303715884105728).should == 41
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = 41
    store[170141183460469231731687303715884105728].should == 41
    store[170141183460469231731687303715884105728] = -12
    store[170141183460469231731687303715884105728].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == 41
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = 41
    store[170141183460469231731687303715884105728].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = 41
    store.fetch(170141183460469231731687303715884105728, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = 41
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = 41
    store[99].should == 41
    store.load(99).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[99] = 41
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(99, value).should equal(value)
    store[99].should == 41
    store.load(99).should == 41
  end

  it 'stores values after clear' do
    store[99] = 41
    store[170141183460469231731687303715884105728] = -12
    store.clear.should equal(store)
    store[99] = 41
    store[99].should == 41
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = 41
    store.delete(99).should == 41
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = 41
    store[99].should == 41
    store[99] = -12
    store[99].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[99] = value).should equal(value)
    store[99].should == 41
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = 41
    store[99].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = 41
    store.fetch(99, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = 41
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = -12
    store[170141183460469231731687303715884105728].should == -12
    store.load(170141183460469231731687303715884105728).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = -12
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == -12
    store.load(170141183460469231731687303715884105728).should == -12
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = -12
    store[99] = 41
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = -12
    store[170141183460469231731687303715884105728].should == -12
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = -12
    store.delete(170141183460469231731687303715884105728).should == -12
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = -12
    store[170141183460469231731687303715884105728].should == -12
    store[170141183460469231731687303715884105728] = 41
    store[170141183460469231731687303715884105728].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == -12
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = -12
    store[170141183460469231731687303715884105728].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = -12
    store.fetch(170141183460469231731687303715884105728, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = -12
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = -12
    store[99].should == -12
    store.load(99).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[99] = -12
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(99, value).should equal(value)
    store[99].should == -12
    store.load(99).should == -12
  end

  it 'stores values after clear' do
    store[99] = -12
    store[170141183460469231731687303715884105728] = 41
    store.clear.should equal(store)
    store[99] = -12
    store[99].should == -12
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = -12
    store.delete(99).should == -12
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = -12
    store[99].should == -12
    store[99] = 41
    store[99].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[99] = value).should equal(value)
    store[99].should == -12
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = -12
    store[99].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = -12
    store.fetch(99, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = -12
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_numberkey_integervalue ####################

shared_examples_for 'persist_numberkey_integervalue' do
  it 'persists values' do
    store[0.5] = 41
    store.close
    @store = nil
    store[0.5].should == 41
  end

  it 'persists values' do
    store[-0.3] = 41
    store.close
    @store = nil
    store[-0.3].should == 41
  end

  it 'persists values' do
    store[0.5] = -12
    store.close
    @store = nil
    store[0.5].should == -12
  end

  it 'persists values' do
    store[-0.3] = -12
    store.close
    @store = nil
    store[-0.3].should == -12
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = 41
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == 41
  end

  it 'persists values' do
    store[99] = 41
    store.close
    @store = nil
    store[99].should == 41
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = -12
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == -12
  end

  it 'persists values' do
    store[99] = -12
    store.close
    @store = nil
    store[99].should == -12
  end
end

#################### null_numberkey_numbervalue ####################

shared_examples_for 'null_numberkey_numbervalue' do
  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = 123.456
    store[-0.3] = -98.7
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = 123.456
    store[0.5] = -98.7
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = -98.7
    store[-0.3] = 123.456
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = -98.7
    store[0.5] = 123.456
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = 340282366920938463463374607431768211456
    store[-0.3] = 33
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = 340282366920938463463374607431768211456
    store[0.5] = 33
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = 33
    store[-0.3] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = 33
    store[0.5] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = 123.456
    store[99] = -98.7
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = 123.456
    store[170141183460469231731687303715884105728] = -98.7
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = -98.7
    store[99] = 123.456
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = -98.7
    store[170141183460469231731687303715884105728] = 123.456
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store[99] = 33
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728] = 33
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = 33
    store[99] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = 33
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, 33, options).should == 33
  end
end

#################### store_numberkey_numbervalue ####################

shared_examples_for 'store_numberkey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store[0.5] = 123.456
    store[0.5].should == 123.456
    store.load(0.5).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = 123.456
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(0.5, value).should equal(value)
    store[0.5].should == 123.456
    store.load(0.5).should == 123.456
  end

  it 'stores values after clear' do
    store[0.5] = 123.456
    store[-0.3] = -98.7
    store.clear.should equal(store)
    store[0.5] = 123.456
    store[0.5].should == 123.456
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = 123.456
    store.delete(0.5).should == 123.456
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = 123.456
    store[0.5].should == 123.456
    store[0.5] = -98.7
    store[0.5].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == 123.456
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = 123.456
    store[0.5].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = 123.456
    store.fetch(0.5, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = 123.456
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = 123.456
    store[-0.3].should == 123.456
    store.load(-0.3).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = 123.456
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == 123.456
    store.load(-0.3).should == 123.456
  end

  it 'stores values after clear' do
    store[-0.3] = 123.456
    store[0.5] = -98.7
    store.clear.should equal(store)
    store[-0.3] = 123.456
    store[-0.3].should == 123.456
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = 123.456
    store.delete(-0.3).should == 123.456
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = 123.456
    store[-0.3].should == 123.456
    store[-0.3] = -98.7
    store[-0.3].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == 123.456
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = 123.456
    store[-0.3].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = 123.456
    store.fetch(-0.3, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = 123.456
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = -98.7
    store[0.5].should == -98.7
    store.load(0.5).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = -98.7
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(0.5, value).should equal(value)
    store[0.5].should == -98.7
    store.load(0.5).should == -98.7
  end

  it 'stores values after clear' do
    store[0.5] = -98.7
    store[-0.3] = 123.456
    store.clear.should equal(store)
    store[0.5] = -98.7
    store[0.5].should == -98.7
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = -98.7
    store.delete(0.5).should == -98.7
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = -98.7
    store[0.5].should == -98.7
    store[0.5] = 123.456
    store[0.5].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == -98.7
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = -98.7
    store[0.5].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = -98.7
    store.fetch(0.5, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = -98.7
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = -98.7
    store[-0.3].should == -98.7
    store.load(-0.3).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = -98.7
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == -98.7
    store.load(-0.3).should == -98.7
  end

  it 'stores values after clear' do
    store[-0.3] = -98.7
    store[0.5] = 123.456
    store.clear.should equal(store)
    store[-0.3] = -98.7
    store[-0.3].should == -98.7
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = -98.7
    store.delete(-0.3).should == -98.7
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = -98.7
    store[-0.3].should == -98.7
    store[-0.3] = 123.456
    store[-0.3].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == -98.7
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = -98.7
    store[-0.3].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = -98.7
    store.fetch(-0.3, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = -98.7
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = 340282366920938463463374607431768211456
    store[0.5].should == 340282366920938463463374607431768211456
    store.load(0.5).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = 340282366920938463463374607431768211456
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(0.5, value).should equal(value)
    store[0.5].should == 340282366920938463463374607431768211456
    store.load(0.5).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[0.5] = 340282366920938463463374607431768211456
    store[-0.3] = 33
    store.clear.should equal(store)
    store[0.5] = 340282366920938463463374607431768211456
    store[0.5].should == 340282366920938463463374607431768211456
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = 340282366920938463463374607431768211456
    store.delete(0.5).should == 340282366920938463463374607431768211456
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = 340282366920938463463374607431768211456
    store[0.5].should == 340282366920938463463374607431768211456
    store[0.5] = 33
    store[0.5].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = 340282366920938463463374607431768211456
    store[0.5].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = 340282366920938463463374607431768211456
    store.fetch(0.5, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = 340282366920938463463374607431768211456
    store[-0.3].should == 340282366920938463463374607431768211456
    store.load(-0.3).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = 340282366920938463463374607431768211456
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == 340282366920938463463374607431768211456
    store.load(-0.3).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[-0.3] = 340282366920938463463374607431768211456
    store[0.5] = 33
    store.clear.should equal(store)
    store[-0.3] = 340282366920938463463374607431768211456
    store[-0.3].should == 340282366920938463463374607431768211456
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = 340282366920938463463374607431768211456
    store.delete(-0.3).should == 340282366920938463463374607431768211456
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = 340282366920938463463374607431768211456
    store[-0.3].should == 340282366920938463463374607431768211456
    store[-0.3] = 33
    store[-0.3].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = 340282366920938463463374607431768211456
    store[-0.3].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = 340282366920938463463374607431768211456
    store.fetch(-0.3, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = 33
    store[0.5].should == 33
    store.load(0.5).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = 33
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(0.5, value).should equal(value)
    store[0.5].should == 33
    store.load(0.5).should == 33
  end

  it 'stores values after clear' do
    store[0.5] = 33
    store[-0.3] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[0.5] = 33
    store[0.5].should == 33
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = 33
    store.delete(0.5).should == 33
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = 33
    store[0.5].should == 33
    store[0.5] = 340282366920938463463374607431768211456
    store[0.5].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == 33
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = 33
    store[0.5].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = 33
    store.fetch(0.5, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = 33
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = 33
    store[-0.3].should == 33
    store.load(-0.3).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = 33
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == 33
    store.load(-0.3).should == 33
  end

  it 'stores values after clear' do
    store[-0.3] = 33
    store[0.5] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[-0.3] = 33
    store[-0.3].should == 33
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = 33
    store.delete(-0.3).should == 33
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = 33
    store[-0.3].should == 33
    store[-0.3] = 340282366920938463463374607431768211456
    store[-0.3].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == 33
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = 33
    store[-0.3].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = 33
    store.fetch(-0.3, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = 33
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = 123.456
    store[170141183460469231731687303715884105728].should == 123.456
    store.load(170141183460469231731687303715884105728).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = 123.456
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == 123.456
    store.load(170141183460469231731687303715884105728).should == 123.456
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = 123.456
    store[99] = -98.7
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = 123.456
    store[170141183460469231731687303715884105728].should == 123.456
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = 123.456
    store.delete(170141183460469231731687303715884105728).should == 123.456
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = 123.456
    store[170141183460469231731687303715884105728].should == 123.456
    store[170141183460469231731687303715884105728] = -98.7
    store[170141183460469231731687303715884105728].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == 123.456
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = 123.456
    store[170141183460469231731687303715884105728].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = 123.456
    store.fetch(170141183460469231731687303715884105728, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = 123.456
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = 123.456
    store[99].should == 123.456
    store.load(99).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[99] = 123.456
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(99, value).should equal(value)
    store[99].should == 123.456
    store.load(99).should == 123.456
  end

  it 'stores values after clear' do
    store[99] = 123.456
    store[170141183460469231731687303715884105728] = -98.7
    store.clear.should equal(store)
    store[99] = 123.456
    store[99].should == 123.456
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = 123.456
    store.delete(99).should == 123.456
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = 123.456
    store[99].should == 123.456
    store[99] = -98.7
    store[99].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[99] = value).should equal(value)
    store[99].should == 123.456
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = 123.456
    store[99].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = 123.456
    store.fetch(99, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = 123.456
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = -98.7
    store[170141183460469231731687303715884105728].should == -98.7
    store.load(170141183460469231731687303715884105728).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = -98.7
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == -98.7
    store.load(170141183460469231731687303715884105728).should == -98.7
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = -98.7
    store[99] = 123.456
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = -98.7
    store[170141183460469231731687303715884105728].should == -98.7
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = -98.7
    store.delete(170141183460469231731687303715884105728).should == -98.7
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = -98.7
    store[170141183460469231731687303715884105728].should == -98.7
    store[170141183460469231731687303715884105728] = 123.456
    store[170141183460469231731687303715884105728].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == -98.7
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = -98.7
    store[170141183460469231731687303715884105728].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = -98.7
    store.fetch(170141183460469231731687303715884105728, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = -98.7
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = -98.7
    store[99].should == -98.7
    store.load(99).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[99] = -98.7
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(99, value).should equal(value)
    store[99].should == -98.7
    store.load(99).should == -98.7
  end

  it 'stores values after clear' do
    store[99] = -98.7
    store[170141183460469231731687303715884105728] = 123.456
    store.clear.should equal(store)
    store[99] = -98.7
    store[99].should == -98.7
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = -98.7
    store.delete(99).should == -98.7
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = -98.7
    store[99].should == -98.7
    store[99] = 123.456
    store[99].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[99] = value).should equal(value)
    store[99].should == -98.7
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = -98.7
    store[99].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = -98.7
    store.fetch(99, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = -98.7
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728].should == 340282366920938463463374607431768211456
    store.load(170141183460469231731687303715884105728).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == 340282366920938463463374607431768211456
    store.load(170141183460469231731687303715884105728).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store[99] = 33
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728].should == 340282366920938463463374607431768211456
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store.delete(170141183460469231731687303715884105728).should == 340282366920938463463374607431768211456
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728].should == 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728] = 33
    store[170141183460469231731687303715884105728].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store.fetch(170141183460469231731687303715884105728, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = 340282366920938463463374607431768211456
    store[99].should == 340282366920938463463374607431768211456
    store.load(99).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[99] = 340282366920938463463374607431768211456
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(99, value).should equal(value)
    store[99].should == 340282366920938463463374607431768211456
    store.load(99).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[99] = 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728] = 33
    store.clear.should equal(store)
    store[99] = 340282366920938463463374607431768211456
    store[99].should == 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = 340282366920938463463374607431768211456
    store.delete(99).should == 340282366920938463463374607431768211456
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = 340282366920938463463374607431768211456
    store[99].should == 340282366920938463463374607431768211456
    store[99] = 33
    store[99].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[99] = value).should equal(value)
    store[99].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = 340282366920938463463374607431768211456
    store[99].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = 340282366920938463463374607431768211456
    store.fetch(99, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = 33
    store[170141183460469231731687303715884105728].should == 33
    store.load(170141183460469231731687303715884105728).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = 33
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == 33
    store.load(170141183460469231731687303715884105728).should == 33
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = 33
    store[99] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = 33
    store[170141183460469231731687303715884105728].should == 33
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = 33
    store.delete(170141183460469231731687303715884105728).should == 33
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = 33
    store[170141183460469231731687303715884105728].should == 33
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store[170141183460469231731687303715884105728].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == 33
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = 33
    store[170141183460469231731687303715884105728].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = 33
    store.fetch(170141183460469231731687303715884105728, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = 33
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = 33
    store[99].should == 33
    store.load(99).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[99] = 33
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(99, value).should equal(value)
    store[99].should == 33
    store.load(99).should == 33
  end

  it 'stores values after clear' do
    store[99] = 33
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[99] = 33
    store[99].should == 33
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = 33
    store.delete(99).should == 33
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = 33
    store[99].should == 33
    store[99] = 340282366920938463463374607431768211456
    store[99].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[99] = value).should equal(value)
    store[99].should == 33
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = 33
    store[99].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = 33
    store.fetch(99, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = 33
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_numberkey_numbervalue ####################

shared_examples_for 'persist_numberkey_numbervalue' do
  it 'persists values' do
    store[0.5] = 123.456
    store.close
    @store = nil
    store[0.5].should == 123.456
  end

  it 'persists values' do
    store[-0.3] = 123.456
    store.close
    @store = nil
    store[-0.3].should == 123.456
  end

  it 'persists values' do
    store[0.5] = -98.7
    store.close
    @store = nil
    store[0.5].should == -98.7
  end

  it 'persists values' do
    store[-0.3] = -98.7
    store.close
    @store = nil
    store[-0.3].should == -98.7
  end

  it 'persists values' do
    store[0.5] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[0.5].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[-0.3] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[-0.3].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[0.5] = 33
    store.close
    @store = nil
    store[0.5].should == 33
  end

  it 'persists values' do
    store[-0.3] = 33
    store.close
    @store = nil
    store[-0.3].should == 33
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = 123.456
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == 123.456
  end

  it 'persists values' do
    store[99] = 123.456
    store.close
    @store = nil
    store[99].should == 123.456
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = -98.7
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == -98.7
  end

  it 'persists values' do
    store[99] = -98.7
    store.close
    @store = nil
    store[99].should == -98.7
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[99] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[99].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = 33
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == 33
  end

  it 'persists values' do
    store[99] = 33
    store.close
    @store = nil
    store[99].should == 33
  end
end

#################### null_numberkey_booleanvalue ####################

shared_examples_for 'null_numberkey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = true
    store[-0.3] = false
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = true
    store[0.5] = false
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = false
    store[-0.3] = true
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = false
    store[0.5] = true
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = true
    store[99] = false
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = true
    store[170141183460469231731687303715884105728] = false
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = false
    store[99] = true
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = false
    store[170141183460469231731687303715884105728] = true
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, false, options).should == false
  end
end

#################### store_numberkey_booleanvalue ####################

shared_examples_for 'store_numberkey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store[0.5] = true
    store[0.5].should == true
    store.load(0.5).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = true
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(0.5, value).should equal(value)
    store[0.5].should == true
    store.load(0.5).should == true
  end

  it 'stores values after clear' do
    store[0.5] = true
    store[-0.3] = false
    store.clear.should equal(store)
    store[0.5] = true
    store[0.5].should == true
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = true
    store.delete(0.5).should == true
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = true
    store[0.5].should == true
    store[0.5] = false
    store[0.5].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == true
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = true
    store[0.5].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = true
    store.fetch(0.5, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = true
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = true
    store[-0.3].should == true
    store.load(-0.3).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = true
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == true
    store.load(-0.3).should == true
  end

  it 'stores values after clear' do
    store[-0.3] = true
    store[0.5] = false
    store.clear.should equal(store)
    store[-0.3] = true
    store[-0.3].should == true
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = true
    store.delete(-0.3).should == true
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = true
    store[-0.3].should == true
    store[-0.3] = false
    store[-0.3].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == true
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = true
    store[-0.3].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = true
    store.fetch(-0.3, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = true
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = false
    store[0.5].should == false
    store.load(0.5).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = false
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(0.5, value).should equal(value)
    store[0.5].should == false
    store.load(0.5).should == false
  end

  it 'stores values after clear' do
    store[0.5] = false
    store[-0.3] = true
    store.clear.should equal(store)
    store[0.5] = false
    store[0.5].should == false
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = false
    store.delete(0.5).should == false
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = false
    store[0.5].should == false
    store[0.5] = true
    store[0.5].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == false
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = false
    store[0.5].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = false
    store.fetch(0.5, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = false
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = false
    store[-0.3].should == false
    store.load(-0.3).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = false
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == false
    store.load(-0.3).should == false
  end

  it 'stores values after clear' do
    store[-0.3] = false
    store[0.5] = true
    store.clear.should equal(store)
    store[-0.3] = false
    store[-0.3].should == false
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = false
    store.delete(-0.3).should == false
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = false
    store[-0.3].should == false
    store[-0.3] = true
    store[-0.3].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == false
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = false
    store[-0.3].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = false
    store.fetch(-0.3, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = false
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = true
    store[170141183460469231731687303715884105728].should == true
    store.load(170141183460469231731687303715884105728).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = true
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == true
    store.load(170141183460469231731687303715884105728).should == true
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = true
    store[99] = false
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = true
    store[170141183460469231731687303715884105728].should == true
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = true
    store.delete(170141183460469231731687303715884105728).should == true
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = true
    store[170141183460469231731687303715884105728].should == true
    store[170141183460469231731687303715884105728] = false
    store[170141183460469231731687303715884105728].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == true
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = true
    store[170141183460469231731687303715884105728].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = true
    store.fetch(170141183460469231731687303715884105728, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = true
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = true
    store[99].should == true
    store.load(99).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[99] = true
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(99, value).should equal(value)
    store[99].should == true
    store.load(99).should == true
  end

  it 'stores values after clear' do
    store[99] = true
    store[170141183460469231731687303715884105728] = false
    store.clear.should equal(store)
    store[99] = true
    store[99].should == true
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = true
    store.delete(99).should == true
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = true
    store[99].should == true
    store[99] = false
    store[99].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[99] = value).should equal(value)
    store[99].should == true
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = true
    store[99].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = true
    store.fetch(99, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = true
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = false
    store[170141183460469231731687303715884105728].should == false
    store.load(170141183460469231731687303715884105728).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = false
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == false
    store.load(170141183460469231731687303715884105728).should == false
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = false
    store[99] = true
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = false
    store[170141183460469231731687303715884105728].should == false
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = false
    store.delete(170141183460469231731687303715884105728).should == false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = false
    store[170141183460469231731687303715884105728].should == false
    store[170141183460469231731687303715884105728] = true
    store[170141183460469231731687303715884105728].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == false
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = false
    store[170141183460469231731687303715884105728].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = false
    store.fetch(170141183460469231731687303715884105728, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = false
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = false
    store[99].should == false
    store.load(99).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[99] = false
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(99, value).should equal(value)
    store[99].should == false
    store.load(99).should == false
  end

  it 'stores values after clear' do
    store[99] = false
    store[170141183460469231731687303715884105728] = true
    store.clear.should equal(store)
    store[99] = false
    store[99].should == false
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = false
    store.delete(99).should == false
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = false
    store[99].should == false
    store[99] = true
    store[99].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[99] = value).should equal(value)
    store[99].should == false
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = false
    store[99].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = false
    store.fetch(99, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = false
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_numberkey_booleanvalue ####################

shared_examples_for 'persist_numberkey_booleanvalue' do
  it 'persists values' do
    store[0.5] = true
    store.close
    @store = nil
    store[0.5].should == true
  end

  it 'persists values' do
    store[-0.3] = true
    store.close
    @store = nil
    store[-0.3].should == true
  end

  it 'persists values' do
    store[0.5] = false
    store.close
    @store = nil
    store[0.5].should == false
  end

  it 'persists values' do
    store[-0.3] = false
    store.close
    @store = nil
    store[-0.3].should == false
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = true
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == true
  end

  it 'persists values' do
    store[99] = true
    store.close
    @store = nil
    store[99].should == true
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = false
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == false
  end

  it 'persists values' do
    store[99] = false
    store.close
    @store = nil
    store[99].should == false
  end
end

#################### null_numberkey_stringvalue ####################

shared_examples_for 'null_numberkey_stringvalue' do
  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = "strval1"
    store[-0.3] = "strval2"
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = "strval1"
    store[0.5] = "strval2"
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = "strval2"
    store[-0.3] = "strval1"
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = "strval2"
    store[0.5] = "strval1"
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = "strval1"
    store[99] = "strval2"
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = "strval1"
    store[170141183460469231731687303715884105728] = "strval2"
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = "strval2"
    store[99] = "strval1"
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = "strval2"
    store[170141183460469231731687303715884105728] = "strval1"
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, "strval2", options).should == "strval2"
  end
end

#################### store_numberkey_stringvalue ####################

shared_examples_for 'store_numberkey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store[0.5] = "strval1"
    store[0.5].should == "strval1"
    store.load(0.5).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = "strval1"
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(0.5, value).should equal(value)
    store[0.5].should == "strval1"
    store.load(0.5).should == "strval1"
  end

  it 'stores values after clear' do
    store[0.5] = "strval1"
    store[-0.3] = "strval2"
    store.clear.should equal(store)
    store[0.5] = "strval1"
    store[0.5].should == "strval1"
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = "strval1"
    store.delete(0.5).should == "strval1"
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = "strval1"
    store[0.5].should == "strval1"
    store[0.5] = "strval2"
    store[0.5].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == "strval1"
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = "strval1"
    store[0.5].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = "strval1"
    store.fetch(0.5, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = "strval1"
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = "strval1"
    store[-0.3].should == "strval1"
    store.load(-0.3).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = "strval1"
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == "strval1"
    store.load(-0.3).should == "strval1"
  end

  it 'stores values after clear' do
    store[-0.3] = "strval1"
    store[0.5] = "strval2"
    store.clear.should equal(store)
    store[-0.3] = "strval1"
    store[-0.3].should == "strval1"
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = "strval1"
    store.delete(-0.3).should == "strval1"
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = "strval1"
    store[-0.3].should == "strval1"
    store[-0.3] = "strval2"
    store[-0.3].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == "strval1"
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = "strval1"
    store[-0.3].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = "strval1"
    store.fetch(-0.3, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = "strval1"
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = "strval2"
    store[0.5].should == "strval2"
    store.load(0.5).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = "strval2"
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(0.5, value).should equal(value)
    store[0.5].should == "strval2"
    store.load(0.5).should == "strval2"
  end

  it 'stores values after clear' do
    store[0.5] = "strval2"
    store[-0.3] = "strval1"
    store.clear.should equal(store)
    store[0.5] = "strval2"
    store[0.5].should == "strval2"
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = "strval2"
    store.delete(0.5).should == "strval2"
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = "strval2"
    store[0.5].should == "strval2"
    store[0.5] = "strval1"
    store[0.5].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == "strval2"
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = "strval2"
    store[0.5].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = "strval2"
    store.fetch(0.5, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = "strval2"
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = "strval2"
    store[-0.3].should == "strval2"
    store.load(-0.3).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = "strval2"
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == "strval2"
    store.load(-0.3).should == "strval2"
  end

  it 'stores values after clear' do
    store[-0.3] = "strval2"
    store[0.5] = "strval1"
    store.clear.should equal(store)
    store[-0.3] = "strval2"
    store[-0.3].should == "strval2"
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = "strval2"
    store.delete(-0.3).should == "strval2"
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = "strval2"
    store[-0.3].should == "strval2"
    store[-0.3] = "strval1"
    store[-0.3].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == "strval2"
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = "strval2"
    store[-0.3].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = "strval2"
    store.fetch(-0.3, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = "strval2"
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = "strval1"
    store[170141183460469231731687303715884105728].should == "strval1"
    store.load(170141183460469231731687303715884105728).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = "strval1"
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == "strval1"
    store.load(170141183460469231731687303715884105728).should == "strval1"
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = "strval1"
    store[99] = "strval2"
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = "strval1"
    store[170141183460469231731687303715884105728].should == "strval1"
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = "strval1"
    store.delete(170141183460469231731687303715884105728).should == "strval1"
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = "strval1"
    store[170141183460469231731687303715884105728].should == "strval1"
    store[170141183460469231731687303715884105728] = "strval2"
    store[170141183460469231731687303715884105728].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == "strval1"
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = "strval1"
    store[170141183460469231731687303715884105728].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = "strval1"
    store.fetch(170141183460469231731687303715884105728, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = "strval1"
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = "strval1"
    store[99].should == "strval1"
    store.load(99).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[99] = "strval1"
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(99, value).should equal(value)
    store[99].should == "strval1"
    store.load(99).should == "strval1"
  end

  it 'stores values after clear' do
    store[99] = "strval1"
    store[170141183460469231731687303715884105728] = "strval2"
    store.clear.should equal(store)
    store[99] = "strval1"
    store[99].should == "strval1"
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = "strval1"
    store.delete(99).should == "strval1"
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = "strval1"
    store[99].should == "strval1"
    store[99] = "strval2"
    store[99].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[99] = value).should equal(value)
    store[99].should == "strval1"
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = "strval1"
    store[99].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = "strval1"
    store.fetch(99, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = "strval1"
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = "strval2"
    store[170141183460469231731687303715884105728].should == "strval2"
    store.load(170141183460469231731687303715884105728).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = "strval2"
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == "strval2"
    store.load(170141183460469231731687303715884105728).should == "strval2"
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = "strval2"
    store[99] = "strval1"
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = "strval2"
    store[170141183460469231731687303715884105728].should == "strval2"
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = "strval2"
    store.delete(170141183460469231731687303715884105728).should == "strval2"
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = "strval2"
    store[170141183460469231731687303715884105728].should == "strval2"
    store[170141183460469231731687303715884105728] = "strval1"
    store[170141183460469231731687303715884105728].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == "strval2"
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = "strval2"
    store[170141183460469231731687303715884105728].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = "strval2"
    store.fetch(170141183460469231731687303715884105728, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = "strval2"
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = "strval2"
    store[99].should == "strval2"
    store.load(99).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[99] = "strval2"
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(99, value).should equal(value)
    store[99].should == "strval2"
    store.load(99).should == "strval2"
  end

  it 'stores values after clear' do
    store[99] = "strval2"
    store[170141183460469231731687303715884105728] = "strval1"
    store.clear.should equal(store)
    store[99] = "strval2"
    store[99].should == "strval2"
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = "strval2"
    store.delete(99).should == "strval2"
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = "strval2"
    store[99].should == "strval2"
    store[99] = "strval1"
    store[99].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[99] = value).should equal(value)
    store[99].should == "strval2"
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = "strval2"
    store[99].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = "strval2"
    store.fetch(99, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = "strval2"
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_numberkey_stringvalue ####################

shared_examples_for 'returndifferent_numberkey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[0.5] = value
    store[0.5].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[-0.3] = value
    store[-0.3].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[0.5] = value
    store[0.5].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[-0.3] = value
    store[-0.3].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[99] = value
    store[99].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[99] = value
    store[99].should_not be_equal(value)
  end
end

#################### returnsame_numberkey_stringvalue ####################

shared_examples_for 'returnsame_numberkey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[0.5] = value
    store[0.5].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[-0.3] = value
    store[-0.3].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[0.5] = value
    store[0.5].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[-0.3] = value
    store[-0.3].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[99] = value
    store[99].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[99] = value
    store[99].should be_equal(value)
  end
end

#################### persist_numberkey_stringvalue ####################

shared_examples_for 'persist_numberkey_stringvalue' do
  it 'persists values' do
    store[0.5] = "strval1"
    store.close
    @store = nil
    store[0.5].should == "strval1"
  end

  it 'persists values' do
    store[-0.3] = "strval1"
    store.close
    @store = nil
    store[-0.3].should == "strval1"
  end

  it 'persists values' do
    store[0.5] = "strval2"
    store.close
    @store = nil
    store[0.5].should == "strval2"
  end

  it 'persists values' do
    store[-0.3] = "strval2"
    store.close
    @store = nil
    store[-0.3].should == "strval2"
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = "strval1"
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == "strval1"
  end

  it 'persists values' do
    store[99] = "strval1"
    store.close
    @store = nil
    store[99].should == "strval1"
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = "strval2"
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == "strval2"
  end

  it 'persists values' do
    store[99] = "strval2"
    store.close
    @store = nil
    store[99].should == "strval2"
  end
end

#################### null_numberkey_binaryvalue ####################

shared_examples_for 'null_numberkey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = "ber"
    store[-0.3] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = "ber"
    store[0.5] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = "\xAA\xBB\xCC"
    store[-0.3] = "ber"
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = "\xAA\xBB\xCC"
    store[0.5] = "ber"
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = "ber"
    store[99] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = "ber"
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store[99] = "ber"
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728] = "ber"
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_numberkey_binaryvalue ####################

shared_examples_for 'store_numberkey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store[0.5] = "ber"
    store[0.5].should == "ber"
    store.load(0.5).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = "ber"
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(0.5, value).should equal(value)
    store[0.5].should == "ber"
    store.load(0.5).should == "ber"
  end

  it 'stores values after clear' do
    store[0.5] = "ber"
    store[-0.3] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[0.5] = "ber"
    store[0.5].should == "ber"
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = "ber"
    store.delete(0.5).should == "ber"
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = "ber"
    store[0.5].should == "ber"
    store[0.5] = "\xAA\xBB\xCC"
    store[0.5].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == "ber"
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = "ber"
    store[0.5].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = "ber"
    store.fetch(0.5, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = "ber"
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = "ber"
    store[-0.3].should == "ber"
    store.load(-0.3).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = "ber"
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == "ber"
    store.load(-0.3).should == "ber"
  end

  it 'stores values after clear' do
    store[-0.3] = "ber"
    store[0.5] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[-0.3] = "ber"
    store[-0.3].should == "ber"
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = "ber"
    store.delete(-0.3).should == "ber"
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = "ber"
    store[-0.3].should == "ber"
    store[-0.3] = "\xAA\xBB\xCC"
    store[-0.3].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == "ber"
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = "ber"
    store[-0.3].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = "ber"
    store.fetch(-0.3, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = "ber"
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = "\xAA\xBB\xCC"
    store[0.5].should == "\xAA\xBB\xCC"
    store.load(0.5).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = "\xAA\xBB\xCC"
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(0.5, value).should equal(value)
    store[0.5].should == "\xAA\xBB\xCC"
    store.load(0.5).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[0.5] = "\xAA\xBB\xCC"
    store[-0.3] = "ber"
    store.clear.should equal(store)
    store[0.5] = "\xAA\xBB\xCC"
    store[0.5].should == "\xAA\xBB\xCC"
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = "\xAA\xBB\xCC"
    store.delete(0.5).should == "\xAA\xBB\xCC"
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = "\xAA\xBB\xCC"
    store[0.5].should == "\xAA\xBB\xCC"
    store[0.5] = "ber"
    store[0.5].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = "\xAA\xBB\xCC"
    store[0.5].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = "\xAA\xBB\xCC"
    store.fetch(0.5, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = "\xAA\xBB\xCC"
    store[-0.3].should == "\xAA\xBB\xCC"
    store.load(-0.3).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = "\xAA\xBB\xCC"
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == "\xAA\xBB\xCC"
    store.load(-0.3).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[-0.3] = "\xAA\xBB\xCC"
    store[0.5] = "ber"
    store.clear.should equal(store)
    store[-0.3] = "\xAA\xBB\xCC"
    store[-0.3].should == "\xAA\xBB\xCC"
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = "\xAA\xBB\xCC"
    store.delete(-0.3).should == "\xAA\xBB\xCC"
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = "\xAA\xBB\xCC"
    store[-0.3].should == "\xAA\xBB\xCC"
    store[-0.3] = "ber"
    store[-0.3].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = "\xAA\xBB\xCC"
    store[-0.3].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = "\xAA\xBB\xCC"
    store.fetch(-0.3, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = "ber"
    store[170141183460469231731687303715884105728].should == "ber"
    store.load(170141183460469231731687303715884105728).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = "ber"
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == "ber"
    store.load(170141183460469231731687303715884105728).should == "ber"
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = "ber"
    store[99] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = "ber"
    store[170141183460469231731687303715884105728].should == "ber"
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = "ber"
    store.delete(170141183460469231731687303715884105728).should == "ber"
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = "ber"
    store[170141183460469231731687303715884105728].should == "ber"
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == "ber"
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = "ber"
    store[170141183460469231731687303715884105728].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = "ber"
    store.fetch(170141183460469231731687303715884105728, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = "ber"
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = "ber"
    store[99].should == "ber"
    store.load(99).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[99] = "ber"
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(99, value).should equal(value)
    store[99].should == "ber"
    store.load(99).should == "ber"
  end

  it 'stores values after clear' do
    store[99] = "ber"
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[99] = "ber"
    store[99].should == "ber"
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = "ber"
    store.delete(99).should == "ber"
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = "ber"
    store[99].should == "ber"
    store[99] = "\xAA\xBB\xCC"
    store[99].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[99] = value).should equal(value)
    store[99].should == "ber"
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = "ber"
    store[99].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = "ber"
    store.fetch(99, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = "ber"
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728].should == "\xAA\xBB\xCC"
    store.load(170141183460469231731687303715884105728).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == "\xAA\xBB\xCC"
    store.load(170141183460469231731687303715884105728).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store[99] = "ber"
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728].should == "\xAA\xBB\xCC"
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store.delete(170141183460469231731687303715884105728).should == "\xAA\xBB\xCC"
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728].should == "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728] = "ber"
    store[170141183460469231731687303715884105728].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store.fetch(170141183460469231731687303715884105728, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = "\xAA\xBB\xCC"
    store[99].should == "\xAA\xBB\xCC"
    store.load(99).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[99] = "\xAA\xBB\xCC"
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(99, value).should equal(value)
    store[99].should == "\xAA\xBB\xCC"
    store.load(99).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[99] = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728] = "ber"
    store.clear.should equal(store)
    store[99] = "\xAA\xBB\xCC"
    store[99].should == "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = "\xAA\xBB\xCC"
    store.delete(99).should == "\xAA\xBB\xCC"
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = "\xAA\xBB\xCC"
    store[99].should == "\xAA\xBB\xCC"
    store[99] = "ber"
    store[99].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[99] = value).should equal(value)
    store[99].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = "\xAA\xBB\xCC"
    store[99].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = "\xAA\xBB\xCC"
    store.fetch(99, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_numberkey_binaryvalue ####################

shared_examples_for 'returndifferent_numberkey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[0.5] = value
    store[0.5].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[-0.3] = value
    store[-0.3].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[0.5] = value
    store[0.5].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[-0.3] = value
    store[-0.3].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[99] = value
    store[99].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[99] = value
    store[99].should_not be_equal(value)
  end
end

#################### returnsame_numberkey_binaryvalue ####################

shared_examples_for 'returnsame_numberkey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[0.5] = value
    store[0.5].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[-0.3] = value
    store[-0.3].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[0.5] = value
    store[0.5].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[-0.3] = value
    store[-0.3].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[99] = value
    store[99].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[99] = value
    store[99].should be_equal(value)
  end
end

#################### persist_numberkey_binaryvalue ####################

shared_examples_for 'persist_numberkey_binaryvalue' do
  it 'persists values' do
    store[0.5] = "ber"
    store.close
    @store = nil
    store[0.5].should == "ber"
  end

  it 'persists values' do
    store[-0.3] = "ber"
    store.close
    @store = nil
    store[-0.3].should == "ber"
  end

  it 'persists values' do
    store[0.5] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[0.5].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store[-0.3] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[-0.3].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = "ber"
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == "ber"
  end

  it 'persists values' do
    store[99] = "ber"
    store.close
    @store = nil
    store[99].should == "ber"
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store[99] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[99].should == "\xAA\xBB\xCC"
  end
end

#################### null_numberkey_hashvalue ####################

shared_examples_for 'null_numberkey_hashvalue' do
  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_numberkey_hashvalue ####################

shared_examples_for 'store_numberkey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    store[0.5].should == {"hashval1"=>["array1", 1]}
    store.load(0.5).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(0.5, value).should equal(value)
    store[0.5].should == {"hashval1"=>["array1", 1]}
    store.load(0.5).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[0.5] = {"hashval1"=>["array1", 1]}
    store[0.5].should == {"hashval1"=>["array1", 1]}
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    store.delete(0.5).should == {"hashval1"=>["array1", 1]}
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    store[0.5].should == {"hashval1"=>["array1", 1]}
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[0.5].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    store.fetch(0.5, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store[-0.3].should == {"hashval1"=>["array1", 1]}
    store.load(-0.3).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == {"hashval1"=>["array1", 1]}
    store.load(-0.3).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store[-0.3].should == {"hashval1"=>["array1", 1]}
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store.delete(-0.3).should == {"hashval1"=>["array1", 1]}
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store[-0.3].should == {"hashval1"=>["array1", 1]}
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[-0.3].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store.fetch(-0.3, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(0.5).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(0.5, value).should equal(value)
    store[0.5].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(0.5).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(0.5).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5] = {"hashval1"=>["array1", 1]}
    store[0.5].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(0.5, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(-0.3).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(-0.3).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(-0.3).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store[-0.3].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(-0.3, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728].should == {"hashval1"=>["array1", 1]}
    store.load(170141183460469231731687303715884105728).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == {"hashval1"=>["array1", 1]}
    store.load(170141183460469231731687303715884105728).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728].should == {"hashval1"=>["array1", 1]}
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store.delete(170141183460469231731687303715884105728).should == {"hashval1"=>["array1", 1]}
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728].should == {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store.fetch(170141183460469231731687303715884105728, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = {"hashval1"=>["array1", 1]}
    store[99].should == {"hashval1"=>["array1", 1]}
    store.load(99).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[99] = {"hashval1"=>["array1", 1]}
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(99, value).should equal(value)
    store[99].should == {"hashval1"=>["array1", 1]}
    store.load(99).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[99] = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[99] = {"hashval1"=>["array1", 1]}
    store[99].should == {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = {"hashval1"=>["array1", 1]}
    store.delete(99).should == {"hashval1"=>["array1", 1]}
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = {"hashval1"=>["array1", 1]}
    store[99].should == {"hashval1"=>["array1", 1]}
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[99] = value).should equal(value)
    store[99].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[99].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = {"hashval1"=>["array1", 1]}
    store.fetch(99, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(170141183460469231731687303715884105728).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(170141183460469231731687303715884105728).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(170141183460469231731687303715884105728).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(170141183460469231731687303715884105728, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(99).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(99, value).should equal(value)
    store[99].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(99).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(99).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99] = {"hashval1"=>["array1", 1]}
    store[99].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[99] = value).should equal(value)
    store[99].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(99, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_numberkey_hashvalue ####################

shared_examples_for 'returndifferent_numberkey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[0.5] = value
    store[0.5].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[-0.3] = value
    store[-0.3].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5] = value
    store[0.5].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3] = value
    store[-0.3].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[99] = value
    store[99].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99] = value
    store[99].should_not be_equal(value)
  end
end

#################### returnsame_numberkey_hashvalue ####################

shared_examples_for 'returnsame_numberkey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[0.5] = value
    store[0.5].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[-0.3] = value
    store[-0.3].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[0.5] = value
    store[0.5].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[-0.3] = value
    store[-0.3].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[99] = value
    store[99].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[99] = value
    store[99].should be_equal(value)
  end
end

#################### persist_numberkey_hashvalue ####################

shared_examples_for 'persist_numberkey_hashvalue' do
  it 'persists values' do
    store[0.5] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[0.5].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[-0.3] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[-0.3].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[0.5] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[0.5].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store[-0.3] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[-0.3].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[99] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[99].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store[99] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[99].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_numberkey_objectvalue ####################

shared_examples_for 'null_numberkey_objectvalue' do
  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = Value.new(:objval1)
    store[-0.3] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = Value.new(:objval1)
    store[0.5] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[0.5].should be_nil
    store.load(0.5).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[0.5] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(0.5).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(0.5).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[0.5] = Value.new(:objval2)
    store[-0.3] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(0.5).should be_false
    store.key?(-0.3).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(0.5, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 0.5
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(0.5, options).should be_false
    store.load(0.5, options).should be_nil
    store.fetch(0.5, 42, options).should == 42
    store.fetch(0.5, options) { 42 }.should == 42
    store.delete(0.5, options).should be_nil
    store.clear(options).should equal(store)
    store.store(0.5, Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store[-0.3].should be_nil
    store.load(-0.3).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[-0.3] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(-0.3).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(-0.3).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[-0.3] = Value.new(:objval2)
    store[0.5] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(-0.3).should be_false
    store.key?(0.5).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(-0.3, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = -0.3
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(-0.3, options).should be_false
    store.load(-0.3, options).should be_nil
    store.fetch(-0.3, 42, options).should == 42
    store.fetch(-0.3, options) { 42 }.should == 42
    store.delete(-0.3, options).should be_nil
    store.clear(options).should equal(store)
    store.store(-0.3, Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store[99] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = Value.new(:objval1)
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[170141183460469231731687303715884105728].should be_nil
    store.load(170141183460469231731687303715884105728).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[170141183460469231731687303715884105728] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(170141183460469231731687303715884105728).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store[99] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(170141183460469231731687303715884105728).should be_false
    store.key?(99).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(170141183460469231731687303715884105728, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 170141183460469231731687303715884105728
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(170141183460469231731687303715884105728, options).should be_false
    store.load(170141183460469231731687303715884105728, options).should be_nil
    store.fetch(170141183460469231731687303715884105728, 42, options).should == 42
    store.fetch(170141183460469231731687303715884105728, options) { 42 }.should == 42
    store.delete(170141183460469231731687303715884105728, options).should be_nil
    store.clear(options).should equal(store)
    store.store(170141183460469231731687303715884105728, Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store[99].should be_nil
    store.load(99).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[99] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(99).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(99).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[99] = Value.new(:objval2)
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(99).should be_false
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(99, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = 99
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(99, options).should be_false
    store.load(99, options).should be_nil
    store.fetch(99, 42, options).should == 42
    store.fetch(99, options) { 42 }.should == 42
    store.delete(99, options).should be_nil
    store.clear(options).should equal(store)
    store.store(99, Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_numberkey_objectvalue ####################

shared_examples_for 'store_numberkey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store[0.5] = Value.new(:objval1)
    store[0.5].should == Value.new(:objval1)
    store.load(0.5).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = Value.new(:objval1)
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(0.5, value).should equal(value)
    store[0.5].should == Value.new(:objval1)
    store.load(0.5).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[0.5] = Value.new(:objval1)
    store[-0.3] = Value.new(:objval2)
    store.clear.should equal(store)
    store[0.5] = Value.new(:objval1)
    store[0.5].should == Value.new(:objval1)
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = Value.new(:objval1)
    store.delete(0.5).should == Value.new(:objval1)
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = Value.new(:objval1)
    store[0.5].should == Value.new(:objval1)
    store[0.5] = Value.new(:objval2)
    store[0.5].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = Value.new(:objval1)
    store[0.5].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = Value.new(:objval1)
    store.fetch(0.5, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = Value.new(:objval1)
    store[-0.3].should == Value.new(:objval1)
    store.load(-0.3).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = Value.new(:objval1)
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == Value.new(:objval1)
    store.load(-0.3).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[-0.3] = Value.new(:objval1)
    store[0.5] = Value.new(:objval2)
    store.clear.should equal(store)
    store[-0.3] = Value.new(:objval1)
    store[-0.3].should == Value.new(:objval1)
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = Value.new(:objval1)
    store.delete(-0.3).should == Value.new(:objval1)
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = Value.new(:objval1)
    store[-0.3].should == Value.new(:objval1)
    store[-0.3] = Value.new(:objval2)
    store[-0.3].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = Value.new(:objval1)
    store[-0.3].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = Value.new(:objval1)
    store.fetch(-0.3, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[0.5] = Value.new(:objval2)
    store[0.5].should == Value.new(:objval2)
    store.load(0.5).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[0.5] = Value.new(:objval2)
    store.key?(0.5).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(0.5, value).should equal(value)
    store[0.5].should == Value.new(:objval2)
    store.load(0.5).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[0.5] = Value.new(:objval2)
    store[-0.3] = Value.new(:objval1)
    store.clear.should equal(store)
    store[0.5] = Value.new(:objval2)
    store[0.5].should == Value.new(:objval2)
    store[-0.3].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[0.5] = Value.new(:objval2)
    store.delete(0.5).should == Value.new(:objval2)
    store.key?(0.5).should be_false
  end

  it 'overwrites existing values' do
    store[0.5] = Value.new(:objval2)
    store[0.5].should == Value.new(:objval2)
    store[0.5] = Value.new(:objval1)
    store[0.5].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[0.5] = value).should equal(value)
    store[0.5].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = 0.5.freeze
    store[key] = Value.new(:objval2)
    store[0.5].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[0.5] = Value.new(:objval2)
    store.fetch(0.5, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[0.5] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(0.5) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[-0.3] = Value.new(:objval2)
    store[-0.3].should == Value.new(:objval2)
    store.load(-0.3).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[-0.3] = Value.new(:objval2)
    store.key?(-0.3).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(-0.3, value).should equal(value)
    store[-0.3].should == Value.new(:objval2)
    store.load(-0.3).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[-0.3] = Value.new(:objval2)
    store[0.5] = Value.new(:objval1)
    store.clear.should equal(store)
    store[-0.3] = Value.new(:objval2)
    store[-0.3].should == Value.new(:objval2)
    store[0.5].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[-0.3] = Value.new(:objval2)
    store.delete(-0.3).should == Value.new(:objval2)
    store.key?(-0.3).should be_false
  end

  it 'overwrites existing values' do
    store[-0.3] = Value.new(:objval2)
    store[-0.3].should == Value.new(:objval2)
    store[-0.3] = Value.new(:objval1)
    store[-0.3].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[-0.3] = value).should equal(value)
    store[-0.3].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = -0.3.freeze
    store[key] = Value.new(:objval2)
    store[-0.3].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[-0.3] = Value.new(:objval2)
    store.fetch(-0.3, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[-0.3] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(-0.3) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store[170141183460469231731687303715884105728].should == Value.new(:objval1)
    store.load(170141183460469231731687303715884105728).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == Value.new(:objval1)
    store.load(170141183460469231731687303715884105728).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store[99] = Value.new(:objval2)
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store[170141183460469231731687303715884105728].should == Value.new(:objval1)
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store.delete(170141183460469231731687303715884105728).should == Value.new(:objval1)
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store[170141183460469231731687303715884105728].should == Value.new(:objval1)
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store[170141183460469231731687303715884105728].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = Value.new(:objval1)
    store[170141183460469231731687303715884105728].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store.fetch(170141183460469231731687303715884105728, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = Value.new(:objval1)
    store[99].should == Value.new(:objval1)
    store.load(99).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[99] = Value.new(:objval1)
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(99, value).should equal(value)
    store[99].should == Value.new(:objval1)
    store.load(99).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[99] = Value.new(:objval1)
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store.clear.should equal(store)
    store[99] = Value.new(:objval1)
    store[99].should == Value.new(:objval1)
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = Value.new(:objval1)
    store.delete(99).should == Value.new(:objval1)
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = Value.new(:objval1)
    store[99].should == Value.new(:objval1)
    store[99] = Value.new(:objval2)
    store[99].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[99] = value).should equal(value)
    store[99].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = Value.new(:objval1)
    store[99].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = Value.new(:objval1)
    store.fetch(99, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store[170141183460469231731687303715884105728].should == Value.new(:objval2)
    store.load(170141183460469231731687303715884105728).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store.key?(170141183460469231731687303715884105728).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(170141183460469231731687303715884105728, value).should equal(value)
    store[170141183460469231731687303715884105728].should == Value.new(:objval2)
    store.load(170141183460469231731687303715884105728).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store[99] = Value.new(:objval1)
    store.clear.should equal(store)
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store[170141183460469231731687303715884105728].should == Value.new(:objval2)
    store[99].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store.delete(170141183460469231731687303715884105728).should == Value.new(:objval2)
    store.key?(170141183460469231731687303715884105728).should be_false
  end

  it 'overwrites existing values' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store[170141183460469231731687303715884105728].should == Value.new(:objval2)
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store[170141183460469231731687303715884105728].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[170141183460469231731687303715884105728] = value).should equal(value)
    store[170141183460469231731687303715884105728].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = 170141183460469231731687303715884105728.freeze
    store[key] = Value.new(:objval2)
    store[170141183460469231731687303715884105728].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store.fetch(170141183460469231731687303715884105728, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(170141183460469231731687303715884105728) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[99] = Value.new(:objval2)
    store[99].should == Value.new(:objval2)
    store.load(99).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[99] = Value.new(:objval2)
    store.key?(99).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(99, value).should equal(value)
    store[99].should == Value.new(:objval2)
    store.load(99).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[99] = Value.new(:objval2)
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store.clear.should equal(store)
    store[99] = Value.new(:objval2)
    store[99].should == Value.new(:objval2)
    store[170141183460469231731687303715884105728].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[99] = Value.new(:objval2)
    store.delete(99).should == Value.new(:objval2)
    store.key?(99).should be_false
  end

  it 'overwrites existing values' do
    store[99] = Value.new(:objval2)
    store[99].should == Value.new(:objval2)
    store[99] = Value.new(:objval1)
    store[99].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[99] = value).should equal(value)
    store[99].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = 99.freeze
    store[key] = Value.new(:objval2)
    store[99].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[99] = Value.new(:objval2)
    store.fetch(99, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[99] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(99) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_numberkey_objectvalue ####################

shared_examples_for 'returndifferent_numberkey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[0.5] = value
    store[0.5].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[-0.3] = value
    store[-0.3].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[0.5] = value
    store[0.5].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[-0.3] = value
    store[-0.3].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[99] = value
    store[99].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[99] = value
    store[99].should_not be_equal(value)
  end
end

#################### returnsame_numberkey_objectvalue ####################

shared_examples_for 'returnsame_numberkey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[0.5] = value
    store[0.5].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[-0.3] = value
    store[-0.3].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[0.5] = value
    store[0.5].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[-0.3] = value
    store[-0.3].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[99] = value
    store[99].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[170141183460469231731687303715884105728] = value
    store[170141183460469231731687303715884105728].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[99] = value
    store[99].should be_equal(value)
  end
end

#################### persist_numberkey_objectvalue ####################

shared_examples_for 'persist_numberkey_objectvalue' do
  it 'persists values' do
    store[0.5] = Value.new(:objval1)
    store.close
    @store = nil
    store[0.5].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[-0.3] = Value.new(:objval1)
    store.close
    @store = nil
    store[-0.3].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[0.5] = Value.new(:objval2)
    store.close
    @store = nil
    store[0.5].should == Value.new(:objval2)
  end

  it 'persists values' do
    store[-0.3] = Value.new(:objval2)
    store.close
    @store = nil
    store[-0.3].should == Value.new(:objval2)
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = Value.new(:objval1)
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[99] = Value.new(:objval1)
    store.close
    @store = nil
    store[99].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[170141183460469231731687303715884105728] = Value.new(:objval2)
    store.close
    @store = nil
    store[170141183460469231731687303715884105728].should == Value.new(:objval2)
  end

  it 'persists values' do
    store[99] = Value.new(:objval2)
    store.close
    @store = nil
    store[99].should == Value.new(:objval2)
  end
end

#################### null_booleankey_nilvalue ####################

shared_examples_for 'null_booleankey_nilvalue' do
  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = ''
    store[false] = nil
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = ''
    store[true] = nil
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = nil
    store[false] = ''
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = nil
    store[true] = ''
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = 0
    store[false] = false
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = 0
    store[true] = false
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = false
    store[false] = 0
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = false
    store[true] = 0
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, false, options).should == false
  end
end

#################### store_booleankey_nilvalue ####################

shared_examples_for 'store_booleankey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store[true] = ''
    store[true].should == ''
    store.load(true).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[true] = ''
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(true, value).should equal(value)
    store[true].should == ''
    store.load(true).should == ''
  end

  it 'stores values after clear' do
    store[true] = ''
    store[false] = nil
    store.clear.should equal(store)
    store[true] = ''
    store[true].should == ''
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = ''
    store.delete(true).should == ''
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = ''
    store[true].should == ''
    store[true] = nil
    store[true].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[true] = value).should equal(value)
    store[true].should == ''
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = ''
    store[true].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[false] = ''
    store[false].should == ''
    store.load(false).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[false] = ''
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(false, value).should equal(value)
    store[false].should == ''
    store.load(false).should == ''
  end

  it 'stores values after clear' do
    store[false] = ''
    store[true] = nil
    store.clear.should equal(store)
    store[false] = ''
    store[false].should == ''
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = ''
    store.delete(false).should == ''
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = ''
    store[false].should == ''
    store[false] = nil
    store[false].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[false] = value).should equal(value)
    store[false].should == ''
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = ''
    store[false].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[true] = nil
    store[true].should == nil
    store.load(true).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[true] = nil
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(true, value).should equal(value)
    store[true].should == nil
    store.load(true).should == nil
  end

  it 'stores values after clear' do
    store[true] = nil
    store[false] = ''
    store.clear.should equal(store)
    store[true] = nil
    store[true].should == nil
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = nil
    store.delete(true).should == nil
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = nil
    store[true].should == nil
    store[true] = ''
    store[true].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[true] = value).should equal(value)
    store[true].should == nil
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = nil
    store[true].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[false] = nil
    store[false].should == nil
    store.load(false).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[false] = nil
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(false, value).should equal(value)
    store[false].should == nil
    store.load(false).should == nil
  end

  it 'stores values after clear' do
    store[false] = nil
    store[true] = ''
    store.clear.should equal(store)
    store[false] = nil
    store[false].should == nil
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = nil
    store.delete(false).should == nil
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = nil
    store[false].should == nil
    store[false] = ''
    store[false].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[false] = value).should equal(value)
    store[false].should == nil
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = nil
    store[false].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[true] = 0
    store[true].should == 0
    store.load(true).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[true] = 0
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(true, value).should equal(value)
    store[true].should == 0
    store.load(true).should == 0
  end

  it 'stores values after clear' do
    store[true] = 0
    store[false] = false
    store.clear.should equal(store)
    store[true] = 0
    store[true].should == 0
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = 0
    store.delete(true).should == 0
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = 0
    store[true].should == 0
    store[true] = false
    store[true].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[true] = value).should equal(value)
    store[true].should == 0
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = 0
    store[true].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[false] = 0
    store[false].should == 0
    store.load(false).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[false] = 0
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(false, value).should equal(value)
    store[false].should == 0
    store.load(false).should == 0
  end

  it 'stores values after clear' do
    store[false] = 0
    store[true] = false
    store.clear.should equal(store)
    store[false] = 0
    store[false].should == 0
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = 0
    store.delete(false).should == 0
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = 0
    store[false].should == 0
    store[false] = false
    store[false].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[false] = value).should equal(value)
    store[false].should == 0
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = 0
    store[false].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[true] = false
    store[true].should == false
    store.load(true).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[true] = false
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(true, value).should equal(value)
    store[true].should == false
    store.load(true).should == false
  end

  it 'stores values after clear' do
    store[true] = false
    store[false] = 0
    store.clear.should equal(store)
    store[true] = false
    store[true].should == false
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = false
    store.delete(true).should == false
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = false
    store[true].should == false
    store[true] = 0
    store[true].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[true] = value).should equal(value)
    store[true].should == false
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = false
    store[true].should == false
  end

  it 'writes values to keys that like a Hash' do
    store[false] = false
    store[false].should == false
    store.load(false).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[false] = false
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(false, value).should equal(value)
    store[false].should == false
    store.load(false).should == false
  end

  it 'stores values after clear' do
    store[false] = false
    store[true] = 0
    store.clear.should equal(store)
    store[false] = false
    store[false].should == false
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = false
    store.delete(false).should == false
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = false
    store[false].should == false
    store[false] = 0
    store[false].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[false] = value).should equal(value)
    store[false].should == false
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = false
    store[false].should == false
  end
end

#################### persist_booleankey_nilvalue ####################

shared_examples_for 'persist_booleankey_nilvalue' do
  it 'persists values' do
    store[true] = ''
    store.close
    @store = nil
    store[true].should == ''
  end

  it 'persists values' do
    store[false] = ''
    store.close
    @store = nil
    store[false].should == ''
  end

  it 'persists values' do
    store[true] = nil
    store.close
    @store = nil
    store[true].should == nil
  end

  it 'persists values' do
    store[false] = nil
    store.close
    @store = nil
    store[false].should == nil
  end

  it 'persists values' do
    store[true] = 0
    store.close
    @store = nil
    store[true].should == 0
  end

  it 'persists values' do
    store[false] = 0
    store.close
    @store = nil
    store[false].should == 0
  end

  it 'persists values' do
    store[true] = false
    store.close
    @store = nil
    store[true].should == false
  end

  it 'persists values' do
    store[false] = false
    store.close
    @store = nil
    store[false].should == false
  end
end

#################### null_booleankey_integervalue ####################

shared_examples_for 'null_booleankey_integervalue' do
  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = 41
    store[false] = -12
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = 41
    store[true] = -12
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = -12
    store[false] = 41
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = -12
    store[true] = 41
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, -12, options).should == -12
  end
end

#################### store_booleankey_integervalue ####################

shared_examples_for 'store_booleankey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store[true] = 41
    store[true].should == 41
    store.load(true).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[true] = 41
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(true, value).should equal(value)
    store[true].should == 41
    store.load(true).should == 41
  end

  it 'stores values after clear' do
    store[true] = 41
    store[false] = -12
    store.clear.should equal(store)
    store[true] = 41
    store[true].should == 41
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = 41
    store.delete(true).should == 41
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = 41
    store[true].should == 41
    store[true] = -12
    store[true].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[true] = value).should equal(value)
    store[true].should == 41
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = 41
    store[true].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = 41
    store.fetch(true, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = 41
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = 41
    store[false].should == 41
    store.load(false).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[false] = 41
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(false, value).should equal(value)
    store[false].should == 41
    store.load(false).should == 41
  end

  it 'stores values after clear' do
    store[false] = 41
    store[true] = -12
    store.clear.should equal(store)
    store[false] = 41
    store[false].should == 41
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = 41
    store.delete(false).should == 41
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = 41
    store[false].should == 41
    store[false] = -12
    store[false].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[false] = value).should equal(value)
    store[false].should == 41
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = 41
    store[false].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = 41
    store.fetch(false, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = 41
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = -12
    store[true].should == -12
    store.load(true).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[true] = -12
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(true, value).should equal(value)
    store[true].should == -12
    store.load(true).should == -12
  end

  it 'stores values after clear' do
    store[true] = -12
    store[false] = 41
    store.clear.should equal(store)
    store[true] = -12
    store[true].should == -12
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = -12
    store.delete(true).should == -12
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = -12
    store[true].should == -12
    store[true] = 41
    store[true].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[true] = value).should equal(value)
    store[true].should == -12
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = -12
    store[true].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = -12
    store.fetch(true, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = -12
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = -12
    store[false].should == -12
    store.load(false).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[false] = -12
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(false, value).should equal(value)
    store[false].should == -12
    store.load(false).should == -12
  end

  it 'stores values after clear' do
    store[false] = -12
    store[true] = 41
    store.clear.should equal(store)
    store[false] = -12
    store[false].should == -12
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = -12
    store.delete(false).should == -12
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = -12
    store[false].should == -12
    store[false] = 41
    store[false].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[false] = value).should equal(value)
    store[false].should == -12
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = -12
    store[false].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = -12
    store.fetch(false, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = -12
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_booleankey_integervalue ####################

shared_examples_for 'persist_booleankey_integervalue' do
  it 'persists values' do
    store[true] = 41
    store.close
    @store = nil
    store[true].should == 41
  end

  it 'persists values' do
    store[false] = 41
    store.close
    @store = nil
    store[false].should == 41
  end

  it 'persists values' do
    store[true] = -12
    store.close
    @store = nil
    store[true].should == -12
  end

  it 'persists values' do
    store[false] = -12
    store.close
    @store = nil
    store[false].should == -12
  end
end

#################### null_booleankey_numbervalue ####################

shared_examples_for 'null_booleankey_numbervalue' do
  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = 123.456
    store[false] = -98.7
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = 123.456
    store[true] = -98.7
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = -98.7
    store[false] = 123.456
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = -98.7
    store[true] = 123.456
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = 340282366920938463463374607431768211456
    store[false] = 33
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = 340282366920938463463374607431768211456
    store[true] = 33
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = 33
    store[false] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = 33
    store[true] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, 33, options).should == 33
  end
end

#################### store_booleankey_numbervalue ####################

shared_examples_for 'store_booleankey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store[true] = 123.456
    store[true].should == 123.456
    store.load(true).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[true] = 123.456
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(true, value).should equal(value)
    store[true].should == 123.456
    store.load(true).should == 123.456
  end

  it 'stores values after clear' do
    store[true] = 123.456
    store[false] = -98.7
    store.clear.should equal(store)
    store[true] = 123.456
    store[true].should == 123.456
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = 123.456
    store.delete(true).should == 123.456
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = 123.456
    store[true].should == 123.456
    store[true] = -98.7
    store[true].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[true] = value).should equal(value)
    store[true].should == 123.456
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = 123.456
    store[true].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = 123.456
    store.fetch(true, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = 123.456
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = 123.456
    store[false].should == 123.456
    store.load(false).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[false] = 123.456
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(false, value).should equal(value)
    store[false].should == 123.456
    store.load(false).should == 123.456
  end

  it 'stores values after clear' do
    store[false] = 123.456
    store[true] = -98.7
    store.clear.should equal(store)
    store[false] = 123.456
    store[false].should == 123.456
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = 123.456
    store.delete(false).should == 123.456
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = 123.456
    store[false].should == 123.456
    store[false] = -98.7
    store[false].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[false] = value).should equal(value)
    store[false].should == 123.456
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = 123.456
    store[false].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = 123.456
    store.fetch(false, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = 123.456
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = -98.7
    store[true].should == -98.7
    store.load(true).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[true] = -98.7
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(true, value).should equal(value)
    store[true].should == -98.7
    store.load(true).should == -98.7
  end

  it 'stores values after clear' do
    store[true] = -98.7
    store[false] = 123.456
    store.clear.should equal(store)
    store[true] = -98.7
    store[true].should == -98.7
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = -98.7
    store.delete(true).should == -98.7
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = -98.7
    store[true].should == -98.7
    store[true] = 123.456
    store[true].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[true] = value).should equal(value)
    store[true].should == -98.7
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = -98.7
    store[true].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = -98.7
    store.fetch(true, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = -98.7
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = -98.7
    store[false].should == -98.7
    store.load(false).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[false] = -98.7
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(false, value).should equal(value)
    store[false].should == -98.7
    store.load(false).should == -98.7
  end

  it 'stores values after clear' do
    store[false] = -98.7
    store[true] = 123.456
    store.clear.should equal(store)
    store[false] = -98.7
    store[false].should == -98.7
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = -98.7
    store.delete(false).should == -98.7
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = -98.7
    store[false].should == -98.7
    store[false] = 123.456
    store[false].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[false] = value).should equal(value)
    store[false].should == -98.7
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = -98.7
    store[false].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = -98.7
    store.fetch(false, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = -98.7
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = 340282366920938463463374607431768211456
    store[true].should == 340282366920938463463374607431768211456
    store.load(true).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[true] = 340282366920938463463374607431768211456
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(true, value).should equal(value)
    store[true].should == 340282366920938463463374607431768211456
    store.load(true).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[true] = 340282366920938463463374607431768211456
    store[false] = 33
    store.clear.should equal(store)
    store[true] = 340282366920938463463374607431768211456
    store[true].should == 340282366920938463463374607431768211456
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = 340282366920938463463374607431768211456
    store.delete(true).should == 340282366920938463463374607431768211456
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = 340282366920938463463374607431768211456
    store[true].should == 340282366920938463463374607431768211456
    store[true] = 33
    store[true].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[true] = value).should equal(value)
    store[true].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = 340282366920938463463374607431768211456
    store[true].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = 340282366920938463463374607431768211456
    store.fetch(true, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = 340282366920938463463374607431768211456
    store[false].should == 340282366920938463463374607431768211456
    store.load(false).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[false] = 340282366920938463463374607431768211456
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(false, value).should equal(value)
    store[false].should == 340282366920938463463374607431768211456
    store.load(false).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[false] = 340282366920938463463374607431768211456
    store[true] = 33
    store.clear.should equal(store)
    store[false] = 340282366920938463463374607431768211456
    store[false].should == 340282366920938463463374607431768211456
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = 340282366920938463463374607431768211456
    store.delete(false).should == 340282366920938463463374607431768211456
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = 340282366920938463463374607431768211456
    store[false].should == 340282366920938463463374607431768211456
    store[false] = 33
    store[false].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[false] = value).should equal(value)
    store[false].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = 340282366920938463463374607431768211456
    store[false].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = 340282366920938463463374607431768211456
    store.fetch(false, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = 33
    store[true].should == 33
    store.load(true).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[true] = 33
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(true, value).should equal(value)
    store[true].should == 33
    store.load(true).should == 33
  end

  it 'stores values after clear' do
    store[true] = 33
    store[false] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[true] = 33
    store[true].should == 33
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = 33
    store.delete(true).should == 33
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = 33
    store[true].should == 33
    store[true] = 340282366920938463463374607431768211456
    store[true].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[true] = value).should equal(value)
    store[true].should == 33
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = 33
    store[true].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = 33
    store.fetch(true, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = 33
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = 33
    store[false].should == 33
    store.load(false).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[false] = 33
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(false, value).should equal(value)
    store[false].should == 33
    store.load(false).should == 33
  end

  it 'stores values after clear' do
    store[false] = 33
    store[true] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[false] = 33
    store[false].should == 33
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = 33
    store.delete(false).should == 33
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = 33
    store[false].should == 33
    store[false] = 340282366920938463463374607431768211456
    store[false].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[false] = value).should equal(value)
    store[false].should == 33
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = 33
    store[false].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = 33
    store.fetch(false, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = 33
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_booleankey_numbervalue ####################

shared_examples_for 'persist_booleankey_numbervalue' do
  it 'persists values' do
    store[true] = 123.456
    store.close
    @store = nil
    store[true].should == 123.456
  end

  it 'persists values' do
    store[false] = 123.456
    store.close
    @store = nil
    store[false].should == 123.456
  end

  it 'persists values' do
    store[true] = -98.7
    store.close
    @store = nil
    store[true].should == -98.7
  end

  it 'persists values' do
    store[false] = -98.7
    store.close
    @store = nil
    store[false].should == -98.7
  end

  it 'persists values' do
    store[true] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[true].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[false] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[false].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[true] = 33
    store.close
    @store = nil
    store[true].should == 33
  end

  it 'persists values' do
    store[false] = 33
    store.close
    @store = nil
    store[false].should == 33
  end
end

#################### null_booleankey_booleanvalue ####################

shared_examples_for 'null_booleankey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = true
    store[false] = false
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = true
    store[true] = false
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = false
    store[false] = true
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = false
    store[true] = true
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, false, options).should == false
  end
end

#################### store_booleankey_booleanvalue ####################

shared_examples_for 'store_booleankey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store[true] = true
    store[true].should == true
    store.load(true).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[true] = true
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(true, value).should equal(value)
    store[true].should == true
    store.load(true).should == true
  end

  it 'stores values after clear' do
    store[true] = true
    store[false] = false
    store.clear.should equal(store)
    store[true] = true
    store[true].should == true
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = true
    store.delete(true).should == true
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = true
    store[true].should == true
    store[true] = false
    store[true].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[true] = value).should equal(value)
    store[true].should == true
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = true
    store[true].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = true
    store.fetch(true, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = true
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = true
    store[false].should == true
    store.load(false).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[false] = true
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(false, value).should equal(value)
    store[false].should == true
    store.load(false).should == true
  end

  it 'stores values after clear' do
    store[false] = true
    store[true] = false
    store.clear.should equal(store)
    store[false] = true
    store[false].should == true
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = true
    store.delete(false).should == true
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = true
    store[false].should == true
    store[false] = false
    store[false].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[false] = value).should equal(value)
    store[false].should == true
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = true
    store[false].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = true
    store.fetch(false, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = true
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = false
    store[true].should == false
    store.load(true).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[true] = false
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(true, value).should equal(value)
    store[true].should == false
    store.load(true).should == false
  end

  it 'stores values after clear' do
    store[true] = false
    store[false] = true
    store.clear.should equal(store)
    store[true] = false
    store[true].should == false
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = false
    store.delete(true).should == false
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = false
    store[true].should == false
    store[true] = true
    store[true].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[true] = value).should equal(value)
    store[true].should == false
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = false
    store[true].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = false
    store.fetch(true, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = false
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = false
    store[false].should == false
    store.load(false).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[false] = false
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(false, value).should equal(value)
    store[false].should == false
    store.load(false).should == false
  end

  it 'stores values after clear' do
    store[false] = false
    store[true] = true
    store.clear.should equal(store)
    store[false] = false
    store[false].should == false
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = false
    store.delete(false).should == false
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = false
    store[false].should == false
    store[false] = true
    store[false].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[false] = value).should equal(value)
    store[false].should == false
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = false
    store[false].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = false
    store.fetch(false, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = false
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_booleankey_booleanvalue ####################

shared_examples_for 'persist_booleankey_booleanvalue' do
  it 'persists values' do
    store[true] = true
    store.close
    @store = nil
    store[true].should == true
  end

  it 'persists values' do
    store[false] = true
    store.close
    @store = nil
    store[false].should == true
  end

  it 'persists values' do
    store[true] = false
    store.close
    @store = nil
    store[true].should == false
  end

  it 'persists values' do
    store[false] = false
    store.close
    @store = nil
    store[false].should == false
  end
end

#################### null_booleankey_stringvalue ####################

shared_examples_for 'null_booleankey_stringvalue' do
  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = "strval1"
    store[false] = "strval2"
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = "strval1"
    store[true] = "strval2"
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = "strval2"
    store[false] = "strval1"
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = "strval2"
    store[true] = "strval1"
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, "strval2", options).should == "strval2"
  end
end

#################### store_booleankey_stringvalue ####################

shared_examples_for 'store_booleankey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store[true] = "strval1"
    store[true].should == "strval1"
    store.load(true).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[true] = "strval1"
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(true, value).should equal(value)
    store[true].should == "strval1"
    store.load(true).should == "strval1"
  end

  it 'stores values after clear' do
    store[true] = "strval1"
    store[false] = "strval2"
    store.clear.should equal(store)
    store[true] = "strval1"
    store[true].should == "strval1"
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = "strval1"
    store.delete(true).should == "strval1"
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = "strval1"
    store[true].should == "strval1"
    store[true] = "strval2"
    store[true].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[true] = value).should equal(value)
    store[true].should == "strval1"
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = "strval1"
    store[true].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = "strval1"
    store.fetch(true, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = "strval1"
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = "strval1"
    store[false].should == "strval1"
    store.load(false).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[false] = "strval1"
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(false, value).should equal(value)
    store[false].should == "strval1"
    store.load(false).should == "strval1"
  end

  it 'stores values after clear' do
    store[false] = "strval1"
    store[true] = "strval2"
    store.clear.should equal(store)
    store[false] = "strval1"
    store[false].should == "strval1"
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = "strval1"
    store.delete(false).should == "strval1"
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = "strval1"
    store[false].should == "strval1"
    store[false] = "strval2"
    store[false].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[false] = value).should equal(value)
    store[false].should == "strval1"
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = "strval1"
    store[false].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = "strval1"
    store.fetch(false, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = "strval1"
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = "strval2"
    store[true].should == "strval2"
    store.load(true).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[true] = "strval2"
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(true, value).should equal(value)
    store[true].should == "strval2"
    store.load(true).should == "strval2"
  end

  it 'stores values after clear' do
    store[true] = "strval2"
    store[false] = "strval1"
    store.clear.should equal(store)
    store[true] = "strval2"
    store[true].should == "strval2"
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = "strval2"
    store.delete(true).should == "strval2"
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = "strval2"
    store[true].should == "strval2"
    store[true] = "strval1"
    store[true].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[true] = value).should equal(value)
    store[true].should == "strval2"
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = "strval2"
    store[true].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = "strval2"
    store.fetch(true, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = "strval2"
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = "strval2"
    store[false].should == "strval2"
    store.load(false).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[false] = "strval2"
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(false, value).should equal(value)
    store[false].should == "strval2"
    store.load(false).should == "strval2"
  end

  it 'stores values after clear' do
    store[false] = "strval2"
    store[true] = "strval1"
    store.clear.should equal(store)
    store[false] = "strval2"
    store[false].should == "strval2"
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = "strval2"
    store.delete(false).should == "strval2"
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = "strval2"
    store[false].should == "strval2"
    store[false] = "strval1"
    store[false].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[false] = value).should equal(value)
    store[false].should == "strval2"
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = "strval2"
    store[false].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = "strval2"
    store.fetch(false, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = "strval2"
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_booleankey_stringvalue ####################

shared_examples_for 'returndifferent_booleankey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[true] = value
    store[true].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[false] = value
    store[false].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[true] = value
    store[true].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[false] = value
    store[false].should_not be_equal(value)
  end
end

#################### returnsame_booleankey_stringvalue ####################

shared_examples_for 'returnsame_booleankey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[true] = value
    store[true].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[false] = value
    store[false].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[true] = value
    store[true].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[false] = value
    store[false].should be_equal(value)
  end
end

#################### persist_booleankey_stringvalue ####################

shared_examples_for 'persist_booleankey_stringvalue' do
  it 'persists values' do
    store[true] = "strval1"
    store.close
    @store = nil
    store[true].should == "strval1"
  end

  it 'persists values' do
    store[false] = "strval1"
    store.close
    @store = nil
    store[false].should == "strval1"
  end

  it 'persists values' do
    store[true] = "strval2"
    store.close
    @store = nil
    store[true].should == "strval2"
  end

  it 'persists values' do
    store[false] = "strval2"
    store.close
    @store = nil
    store[false].should == "strval2"
  end
end

#################### null_booleankey_binaryvalue ####################

shared_examples_for 'null_booleankey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = "ber"
    store[false] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = "ber"
    store[true] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = "\xAA\xBB\xCC"
    store[false] = "ber"
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = "\xAA\xBB\xCC"
    store[true] = "ber"
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_booleankey_binaryvalue ####################

shared_examples_for 'store_booleankey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store[true] = "ber"
    store[true].should == "ber"
    store.load(true).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[true] = "ber"
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(true, value).should equal(value)
    store[true].should == "ber"
    store.load(true).should == "ber"
  end

  it 'stores values after clear' do
    store[true] = "ber"
    store[false] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[true] = "ber"
    store[true].should == "ber"
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = "ber"
    store.delete(true).should == "ber"
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = "ber"
    store[true].should == "ber"
    store[true] = "\xAA\xBB\xCC"
    store[true].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[true] = value).should equal(value)
    store[true].should == "ber"
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = "ber"
    store[true].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = "ber"
    store.fetch(true, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = "ber"
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = "ber"
    store[false].should == "ber"
    store.load(false).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[false] = "ber"
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(false, value).should equal(value)
    store[false].should == "ber"
    store.load(false).should == "ber"
  end

  it 'stores values after clear' do
    store[false] = "ber"
    store[true] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[false] = "ber"
    store[false].should == "ber"
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = "ber"
    store.delete(false).should == "ber"
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = "ber"
    store[false].should == "ber"
    store[false] = "\xAA\xBB\xCC"
    store[false].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[false] = value).should equal(value)
    store[false].should == "ber"
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = "ber"
    store[false].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = "ber"
    store.fetch(false, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = "ber"
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = "\xAA\xBB\xCC"
    store[true].should == "\xAA\xBB\xCC"
    store.load(true).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[true] = "\xAA\xBB\xCC"
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(true, value).should equal(value)
    store[true].should == "\xAA\xBB\xCC"
    store.load(true).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[true] = "\xAA\xBB\xCC"
    store[false] = "ber"
    store.clear.should equal(store)
    store[true] = "\xAA\xBB\xCC"
    store[true].should == "\xAA\xBB\xCC"
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = "\xAA\xBB\xCC"
    store.delete(true).should == "\xAA\xBB\xCC"
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = "\xAA\xBB\xCC"
    store[true].should == "\xAA\xBB\xCC"
    store[true] = "ber"
    store[true].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[true] = value).should equal(value)
    store[true].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = "\xAA\xBB\xCC"
    store[true].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = "\xAA\xBB\xCC"
    store.fetch(true, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = "\xAA\xBB\xCC"
    store[false].should == "\xAA\xBB\xCC"
    store.load(false).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[false] = "\xAA\xBB\xCC"
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(false, value).should equal(value)
    store[false].should == "\xAA\xBB\xCC"
    store.load(false).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[false] = "\xAA\xBB\xCC"
    store[true] = "ber"
    store.clear.should equal(store)
    store[false] = "\xAA\xBB\xCC"
    store[false].should == "\xAA\xBB\xCC"
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = "\xAA\xBB\xCC"
    store.delete(false).should == "\xAA\xBB\xCC"
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = "\xAA\xBB\xCC"
    store[false].should == "\xAA\xBB\xCC"
    store[false] = "ber"
    store[false].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[false] = value).should equal(value)
    store[false].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = "\xAA\xBB\xCC"
    store[false].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = "\xAA\xBB\xCC"
    store.fetch(false, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_booleankey_binaryvalue ####################

shared_examples_for 'returndifferent_booleankey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[true] = value
    store[true].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[false] = value
    store[false].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[true] = value
    store[true].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[false] = value
    store[false].should_not be_equal(value)
  end
end

#################### returnsame_booleankey_binaryvalue ####################

shared_examples_for 'returnsame_booleankey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[true] = value
    store[true].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[false] = value
    store[false].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[true] = value
    store[true].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[false] = value
    store[false].should be_equal(value)
  end
end

#################### persist_booleankey_binaryvalue ####################

shared_examples_for 'persist_booleankey_binaryvalue' do
  it 'persists values' do
    store[true] = "ber"
    store.close
    @store = nil
    store[true].should == "ber"
  end

  it 'persists values' do
    store[false] = "ber"
    store.close
    @store = nil
    store[false].should == "ber"
  end

  it 'persists values' do
    store[true] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[true].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store[false] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[false].should == "\xAA\xBB\xCC"
  end
end

#################### null_booleankey_hashvalue ####################

shared_examples_for 'null_booleankey_hashvalue' do
  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = {"hashval1"=>["array1", 1]}
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = {"hashval1"=>["array1", 1]}
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_booleankey_hashvalue ####################

shared_examples_for 'store_booleankey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store[true] = {"hashval1"=>["array1", 1]}
    store[true].should == {"hashval1"=>["array1", 1]}
    store.load(true).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[true] = {"hashval1"=>["array1", 1]}
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(true, value).should equal(value)
    store[true].should == {"hashval1"=>["array1", 1]}
    store.load(true).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[true] = {"hashval1"=>["array1", 1]}
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[true] = {"hashval1"=>["array1", 1]}
    store[true].should == {"hashval1"=>["array1", 1]}
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = {"hashval1"=>["array1", 1]}
    store.delete(true).should == {"hashval1"=>["array1", 1]}
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = {"hashval1"=>["array1", 1]}
    store[true].should == {"hashval1"=>["array1", 1]}
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[true] = value).should equal(value)
    store[true].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[true].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = {"hashval1"=>["array1", 1]}
    store.fetch(true, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = {"hashval1"=>["array1", 1]}
    store[false].should == {"hashval1"=>["array1", 1]}
    store.load(false).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[false] = {"hashval1"=>["array1", 1]}
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(false, value).should equal(value)
    store[false].should == {"hashval1"=>["array1", 1]}
    store.load(false).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[false] = {"hashval1"=>["array1", 1]}
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[false] = {"hashval1"=>["array1", 1]}
    store[false].should == {"hashval1"=>["array1", 1]}
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = {"hashval1"=>["array1", 1]}
    store.delete(false).should == {"hashval1"=>["array1", 1]}
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = {"hashval1"=>["array1", 1]}
    store[false].should == {"hashval1"=>["array1", 1]}
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[false] = value).should equal(value)
    store[false].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[false].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = {"hashval1"=>["array1", 1]}
    store.fetch(false, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(true).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(true, value).should equal(value)
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(true).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(true).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true] = {"hashval1"=>["array1", 1]}
    store[true].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[true] = value).should equal(value)
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(true, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(false).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(false, value).should equal(value)
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(false).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(false).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false] = {"hashval1"=>["array1", 1]}
    store[false].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[false] = value).should equal(value)
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(false, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_booleankey_hashvalue ####################

shared_examples_for 'returndifferent_booleankey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[true] = value
    store[true].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[false] = value
    store[false].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true] = value
    store[true].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false] = value
    store[false].should_not be_equal(value)
  end
end

#################### returnsame_booleankey_hashvalue ####################

shared_examples_for 'returnsame_booleankey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[true] = value
    store[true].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[false] = value
    store[false].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[true] = value
    store[true].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[false] = value
    store[false].should be_equal(value)
  end
end

#################### persist_booleankey_hashvalue ####################

shared_examples_for 'persist_booleankey_hashvalue' do
  it 'persists values' do
    store[true] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[true].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[false] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[false].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[true] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[true].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store[false] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[false].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_booleankey_objectvalue ####################

shared_examples_for 'null_booleankey_objectvalue' do
  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = Value.new(:objval1)
    store[false] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = Value.new(:objval1)
    store[true] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[true].should be_nil
    store.load(true).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[true] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(true).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(true).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[true] = Value.new(:objval2)
    store[false] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(true).should be_false
    store.key?(false).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(true, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = true
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(true, options).should be_false
    store.load(true, options).should be_nil
    store.fetch(true, 42, options).should == 42
    store.fetch(true, options) { 42 }.should == 42
    store.delete(true, options).should be_nil
    store.clear(options).should equal(store)
    store.store(true, Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store[false].should be_nil
    store.load(false).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[false] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(false).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(false).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[false] = Value.new(:objval2)
    store[true] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(false).should be_false
    store.key?(true).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(false, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = false
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(false, options).should be_false
    store.load(false, options).should be_nil
    store.fetch(false, 42, options).should == 42
    store.fetch(false, options) { 42 }.should == 42
    store.delete(false, options).should be_nil
    store.clear(options).should equal(store)
    store.store(false, Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_booleankey_objectvalue ####################

shared_examples_for 'store_booleankey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store[true] = Value.new(:objval1)
    store[true].should == Value.new(:objval1)
    store.load(true).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[true] = Value.new(:objval1)
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(true, value).should equal(value)
    store[true].should == Value.new(:objval1)
    store.load(true).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[true] = Value.new(:objval1)
    store[false] = Value.new(:objval2)
    store.clear.should equal(store)
    store[true] = Value.new(:objval1)
    store[true].should == Value.new(:objval1)
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = Value.new(:objval1)
    store.delete(true).should == Value.new(:objval1)
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = Value.new(:objval1)
    store[true].should == Value.new(:objval1)
    store[true] = Value.new(:objval2)
    store[true].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[true] = value).should equal(value)
    store[true].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = Value.new(:objval1)
    store[true].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = Value.new(:objval1)
    store.fetch(true, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = Value.new(:objval1)
    store[false].should == Value.new(:objval1)
    store.load(false).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[false] = Value.new(:objval1)
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(false, value).should equal(value)
    store[false].should == Value.new(:objval1)
    store.load(false).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[false] = Value.new(:objval1)
    store[true] = Value.new(:objval2)
    store.clear.should equal(store)
    store[false] = Value.new(:objval1)
    store[false].should == Value.new(:objval1)
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = Value.new(:objval1)
    store.delete(false).should == Value.new(:objval1)
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = Value.new(:objval1)
    store[false].should == Value.new(:objval1)
    store[false] = Value.new(:objval2)
    store[false].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[false] = value).should equal(value)
    store[false].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = Value.new(:objval1)
    store[false].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = Value.new(:objval1)
    store.fetch(false, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[true] = Value.new(:objval2)
    store[true].should == Value.new(:objval2)
    store.load(true).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[true] = Value.new(:objval2)
    store.key?(true).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(true, value).should equal(value)
    store[true].should == Value.new(:objval2)
    store.load(true).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[true] = Value.new(:objval2)
    store[false] = Value.new(:objval1)
    store.clear.should equal(store)
    store[true] = Value.new(:objval2)
    store[true].should == Value.new(:objval2)
    store[false].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[true] = Value.new(:objval2)
    store.delete(true).should == Value.new(:objval2)
    store.key?(true).should be_false
  end

  it 'overwrites existing values' do
    store[true] = Value.new(:objval2)
    store[true].should == Value.new(:objval2)
    store[true] = Value.new(:objval1)
    store[true].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[true] = value).should equal(value)
    store[true].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = true.freeze
    store[key] = Value.new(:objval2)
    store[true].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[true] = Value.new(:objval2)
    store.fetch(true, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[true] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(true) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[false] = Value.new(:objval2)
    store[false].should == Value.new(:objval2)
    store.load(false).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[false] = Value.new(:objval2)
    store.key?(false).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(false, value).should equal(value)
    store[false].should == Value.new(:objval2)
    store.load(false).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[false] = Value.new(:objval2)
    store[true] = Value.new(:objval1)
    store.clear.should equal(store)
    store[false] = Value.new(:objval2)
    store[false].should == Value.new(:objval2)
    store[true].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[false] = Value.new(:objval2)
    store.delete(false).should == Value.new(:objval2)
    store.key?(false).should be_false
  end

  it 'overwrites existing values' do
    store[false] = Value.new(:objval2)
    store[false].should == Value.new(:objval2)
    store[false] = Value.new(:objval1)
    store[false].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[false] = value).should equal(value)
    store[false].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = false.freeze
    store[key] = Value.new(:objval2)
    store[false].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[false] = Value.new(:objval2)
    store.fetch(false, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[false] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(false) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_booleankey_objectvalue ####################

shared_examples_for 'returndifferent_booleankey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[true] = value
    store[true].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[false] = value
    store[false].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[true] = value
    store[true].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[false] = value
    store[false].should_not be_equal(value)
  end
end

#################### returnsame_booleankey_objectvalue ####################

shared_examples_for 'returnsame_booleankey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[true] = value
    store[true].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[false] = value
    store[false].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[true] = value
    store[true].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[false] = value
    store[false].should be_equal(value)
  end
end

#################### persist_booleankey_objectvalue ####################

shared_examples_for 'persist_booleankey_objectvalue' do
  it 'persists values' do
    store[true] = Value.new(:objval1)
    store.close
    @store = nil
    store[true].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[false] = Value.new(:objval1)
    store.close
    @store = nil
    store[false].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[true] = Value.new(:objval2)
    store.close
    @store = nil
    store[true].should == Value.new(:objval2)
  end

  it 'persists values' do
    store[false] = Value.new(:objval2)
    store.close
    @store = nil
    store[false].should == Value.new(:objval2)
  end
end

#################### null_stringkey_nilvalue ####################

shared_examples_for 'null_stringkey_nilvalue' do
  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = ''
    store["strkey2"] = nil
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = ''
    store["strkey1"] = nil
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = nil
    store["strkey2"] = ''
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = nil
    store["strkey1"] = ''
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = 0
    store["strkey2"] = false
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = 0
    store["strkey1"] = false
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = false
    store["strkey2"] = 0
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = false
    store["strkey1"] = 0
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", false, options).should == false
  end
end

#################### store_stringkey_nilvalue ####################

shared_examples_for 'store_stringkey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store["strkey1"] = ''
    store["strkey1"].should == ''
    store.load("strkey1").should == ''
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = ''
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == ''
    store.load("strkey1").should == ''
  end

  it 'stores values after clear' do
    store["strkey1"] = ''
    store["strkey2"] = nil
    store.clear.should equal(store)
    store["strkey1"] = ''
    store["strkey1"].should == ''
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = ''
    store.delete("strkey1").should == ''
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = ''
    store["strkey1"].should == ''
    store["strkey1"] = nil
    store["strkey1"].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == ''
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = ''
    store["strkey1"].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = ''
    store["strkey2"].should == ''
    store.load("strkey2").should == ''
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = ''
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == ''
    store.load("strkey2").should == ''
  end

  it 'stores values after clear' do
    store["strkey2"] = ''
    store["strkey1"] = nil
    store.clear.should equal(store)
    store["strkey2"] = ''
    store["strkey2"].should == ''
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = ''
    store.delete("strkey2").should == ''
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = ''
    store["strkey2"].should == ''
    store["strkey2"] = nil
    store["strkey2"].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == ''
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = ''
    store["strkey2"].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = nil
    store["strkey1"].should == nil
    store.load("strkey1").should == nil
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = nil
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == nil
    store.load("strkey1").should == nil
  end

  it 'stores values after clear' do
    store["strkey1"] = nil
    store["strkey2"] = ''
    store.clear.should equal(store)
    store["strkey1"] = nil
    store["strkey1"].should == nil
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = nil
    store.delete("strkey1").should == nil
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = nil
    store["strkey1"].should == nil
    store["strkey1"] = ''
    store["strkey1"].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == nil
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = nil
    store["strkey1"].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = nil
    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = nil
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == nil
    store.load("strkey2").should == nil
  end

  it 'stores values after clear' do
    store["strkey2"] = nil
    store["strkey1"] = ''
    store.clear.should equal(store)
    store["strkey2"] = nil
    store["strkey2"].should == nil
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = nil
    store.delete("strkey2").should == nil
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = nil
    store["strkey2"].should == nil
    store["strkey2"] = ''
    store["strkey2"].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == nil
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = nil
    store["strkey2"].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = 0
    store["strkey1"].should == 0
    store.load("strkey1").should == 0
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = 0
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == 0
    store.load("strkey1").should == 0
  end

  it 'stores values after clear' do
    store["strkey1"] = 0
    store["strkey2"] = false
    store.clear.should equal(store)
    store["strkey1"] = 0
    store["strkey1"].should == 0
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = 0
    store.delete("strkey1").should == 0
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = 0
    store["strkey1"].should == 0
    store["strkey1"] = false
    store["strkey1"].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == 0
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = 0
    store["strkey1"].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = 0
    store["strkey2"].should == 0
    store.load("strkey2").should == 0
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = 0
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == 0
    store.load("strkey2").should == 0
  end

  it 'stores values after clear' do
    store["strkey2"] = 0
    store["strkey1"] = false
    store.clear.should equal(store)
    store["strkey2"] = 0
    store["strkey2"].should == 0
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = 0
    store.delete("strkey2").should == 0
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = 0
    store["strkey2"].should == 0
    store["strkey2"] = false
    store["strkey2"].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == 0
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = 0
    store["strkey2"].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = false
    store["strkey1"].should == false
    store.load("strkey1").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = false
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == false
    store.load("strkey1").should == false
  end

  it 'stores values after clear' do
    store["strkey1"] = false
    store["strkey2"] = 0
    store.clear.should equal(store)
    store["strkey1"] = false
    store["strkey1"].should == false
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = false
    store.delete("strkey1").should == false
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = false
    store["strkey1"].should == false
    store["strkey1"] = 0
    store["strkey1"].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == false
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = false
    store["strkey1"].should == false
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = false
    store["strkey2"].should == false
    store.load("strkey2").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = false
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == false
    store.load("strkey2").should == false
  end

  it 'stores values after clear' do
    store["strkey2"] = false
    store["strkey1"] = 0
    store.clear.should equal(store)
    store["strkey2"] = false
    store["strkey2"].should == false
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = false
    store.delete("strkey2").should == false
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = false
    store["strkey2"].should == false
    store["strkey2"] = 0
    store["strkey2"].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == false
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = false
    store["strkey2"].should == false
  end
end

#################### persist_stringkey_nilvalue ####################

shared_examples_for 'persist_stringkey_nilvalue' do
  it 'persists values' do
    store["strkey1"] = ''
    store.close
    @store = nil
    store["strkey1"].should == ''
  end

  it 'persists values' do
    store["strkey2"] = ''
    store.close
    @store = nil
    store["strkey2"].should == ''
  end

  it 'persists values' do
    store["strkey1"] = nil
    store.close
    @store = nil
    store["strkey1"].should == nil
  end

  it 'persists values' do
    store["strkey2"] = nil
    store.close
    @store = nil
    store["strkey2"].should == nil
  end

  it 'persists values' do
    store["strkey1"] = 0
    store.close
    @store = nil
    store["strkey1"].should == 0
  end

  it 'persists values' do
    store["strkey2"] = 0
    store.close
    @store = nil
    store["strkey2"].should == 0
  end

  it 'persists values' do
    store["strkey1"] = false
    store.close
    @store = nil
    store["strkey1"].should == false
  end

  it 'persists values' do
    store["strkey2"] = false
    store.close
    @store = nil
    store["strkey2"].should == false
  end
end

#################### null_stringkey_integervalue ####################

shared_examples_for 'null_stringkey_integervalue' do
  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = 41
    store["strkey2"] = -12
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = 41
    store["strkey1"] = -12
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = -12
    store["strkey2"] = 41
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = -12
    store["strkey1"] = 41
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", -12, options).should == -12
  end
end

#################### store_stringkey_integervalue ####################

shared_examples_for 'store_stringkey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store["strkey1"] = 41
    store["strkey1"].should == 41
    store.load("strkey1").should == 41
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = 41
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == 41
    store.load("strkey1").should == 41
  end

  it 'stores values after clear' do
    store["strkey1"] = 41
    store["strkey2"] = -12
    store.clear.should equal(store)
    store["strkey1"] = 41
    store["strkey1"].should == 41
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = 41
    store.delete("strkey1").should == 41
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = 41
    store["strkey1"].should == 41
    store["strkey1"] = -12
    store["strkey1"].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == 41
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = 41
    store["strkey1"].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = 41
    store.fetch("strkey1", -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = 41
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = 41
    store["strkey2"].should == 41
    store.load("strkey2").should == 41
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = 41
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == 41
    store.load("strkey2").should == 41
  end

  it 'stores values after clear' do
    store["strkey2"] = 41
    store["strkey1"] = -12
    store.clear.should equal(store)
    store["strkey2"] = 41
    store["strkey2"].should == 41
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = 41
    store.delete("strkey2").should == 41
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = 41
    store["strkey2"].should == 41
    store["strkey2"] = -12
    store["strkey2"].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == 41
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = 41
    store["strkey2"].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = 41
    store.fetch("strkey2", -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = 41
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = -12
    store["strkey1"].should == -12
    store.load("strkey1").should == -12
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = -12
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == -12
    store.load("strkey1").should == -12
  end

  it 'stores values after clear' do
    store["strkey1"] = -12
    store["strkey2"] = 41
    store.clear.should equal(store)
    store["strkey1"] = -12
    store["strkey1"].should == -12
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = -12
    store.delete("strkey1").should == -12
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = -12
    store["strkey1"].should == -12
    store["strkey1"] = 41
    store["strkey1"].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == -12
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = -12
    store["strkey1"].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = -12
    store.fetch("strkey1", 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = -12
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = -12
    store["strkey2"].should == -12
    store.load("strkey2").should == -12
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = -12
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == -12
    store.load("strkey2").should == -12
  end

  it 'stores values after clear' do
    store["strkey2"] = -12
    store["strkey1"] = 41
    store.clear.should equal(store)
    store["strkey2"] = -12
    store["strkey2"].should == -12
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = -12
    store.delete("strkey2").should == -12
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = -12
    store["strkey2"].should == -12
    store["strkey2"] = 41
    store["strkey2"].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == -12
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = -12
    store["strkey2"].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = -12
    store.fetch("strkey2", 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = -12
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_stringkey_integervalue ####################

shared_examples_for 'persist_stringkey_integervalue' do
  it 'persists values' do
    store["strkey1"] = 41
    store.close
    @store = nil
    store["strkey1"].should == 41
  end

  it 'persists values' do
    store["strkey2"] = 41
    store.close
    @store = nil
    store["strkey2"].should == 41
  end

  it 'persists values' do
    store["strkey1"] = -12
    store.close
    @store = nil
    store["strkey1"].should == -12
  end

  it 'persists values' do
    store["strkey2"] = -12
    store.close
    @store = nil
    store["strkey2"].should == -12
  end
end

#################### null_stringkey_numbervalue ####################

shared_examples_for 'null_stringkey_numbervalue' do
  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = 123.456
    store["strkey2"] = -98.7
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = 123.456
    store["strkey1"] = -98.7
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = -98.7
    store["strkey2"] = 123.456
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = -98.7
    store["strkey1"] = 123.456
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = 340282366920938463463374607431768211456
    store["strkey2"] = 33
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = 340282366920938463463374607431768211456
    store["strkey1"] = 33
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = 33
    store["strkey2"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = 33
    store["strkey1"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", 33, options).should == 33
  end
end

#################### store_stringkey_numbervalue ####################

shared_examples_for 'store_stringkey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store["strkey1"] = 123.456
    store["strkey1"].should == 123.456
    store.load("strkey1").should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = 123.456
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == 123.456
    store.load("strkey1").should == 123.456
  end

  it 'stores values after clear' do
    store["strkey1"] = 123.456
    store["strkey2"] = -98.7
    store.clear.should equal(store)
    store["strkey1"] = 123.456
    store["strkey1"].should == 123.456
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = 123.456
    store.delete("strkey1").should == 123.456
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = 123.456
    store["strkey1"].should == 123.456
    store["strkey1"] = -98.7
    store["strkey1"].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == 123.456
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = 123.456
    store["strkey1"].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = 123.456
    store.fetch("strkey1", -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = 123.456
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = 123.456
    store["strkey2"].should == 123.456
    store.load("strkey2").should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = 123.456
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == 123.456
    store.load("strkey2").should == 123.456
  end

  it 'stores values after clear' do
    store["strkey2"] = 123.456
    store["strkey1"] = -98.7
    store.clear.should equal(store)
    store["strkey2"] = 123.456
    store["strkey2"].should == 123.456
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = 123.456
    store.delete("strkey2").should == 123.456
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = 123.456
    store["strkey2"].should == 123.456
    store["strkey2"] = -98.7
    store["strkey2"].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == 123.456
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = 123.456
    store["strkey2"].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = 123.456
    store.fetch("strkey2", -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = 123.456
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = -98.7
    store["strkey1"].should == -98.7
    store.load("strkey1").should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = -98.7
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == -98.7
    store.load("strkey1").should == -98.7
  end

  it 'stores values after clear' do
    store["strkey1"] = -98.7
    store["strkey2"] = 123.456
    store.clear.should equal(store)
    store["strkey1"] = -98.7
    store["strkey1"].should == -98.7
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = -98.7
    store.delete("strkey1").should == -98.7
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = -98.7
    store["strkey1"].should == -98.7
    store["strkey1"] = 123.456
    store["strkey1"].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == -98.7
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = -98.7
    store["strkey1"].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = -98.7
    store.fetch("strkey1", 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = -98.7
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = -98.7
    store["strkey2"].should == -98.7
    store.load("strkey2").should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = -98.7
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == -98.7
    store.load("strkey2").should == -98.7
  end

  it 'stores values after clear' do
    store["strkey2"] = -98.7
    store["strkey1"] = 123.456
    store.clear.should equal(store)
    store["strkey2"] = -98.7
    store["strkey2"].should == -98.7
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = -98.7
    store.delete("strkey2").should == -98.7
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = -98.7
    store["strkey2"].should == -98.7
    store["strkey2"] = 123.456
    store["strkey2"].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == -98.7
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = -98.7
    store["strkey2"].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = -98.7
    store.fetch("strkey2", 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = -98.7
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = 340282366920938463463374607431768211456
    store["strkey1"].should == 340282366920938463463374607431768211456
    store.load("strkey1").should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = 340282366920938463463374607431768211456
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == 340282366920938463463374607431768211456
    store.load("strkey1").should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store["strkey1"] = 340282366920938463463374607431768211456
    store["strkey2"] = 33
    store.clear.should equal(store)
    store["strkey1"] = 340282366920938463463374607431768211456
    store["strkey1"].should == 340282366920938463463374607431768211456
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = 340282366920938463463374607431768211456
    store.delete("strkey1").should == 340282366920938463463374607431768211456
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = 340282366920938463463374607431768211456
    store["strkey1"].should == 340282366920938463463374607431768211456
    store["strkey1"] = 33
    store["strkey1"].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = 340282366920938463463374607431768211456
    store["strkey1"].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = 340282366920938463463374607431768211456
    store.fetch("strkey1", 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = 340282366920938463463374607431768211456
    store["strkey2"].should == 340282366920938463463374607431768211456
    store.load("strkey2").should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = 340282366920938463463374607431768211456
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == 340282366920938463463374607431768211456
    store.load("strkey2").should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store["strkey2"] = 340282366920938463463374607431768211456
    store["strkey1"] = 33
    store.clear.should equal(store)
    store["strkey2"] = 340282366920938463463374607431768211456
    store["strkey2"].should == 340282366920938463463374607431768211456
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = 340282366920938463463374607431768211456
    store.delete("strkey2").should == 340282366920938463463374607431768211456
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = 340282366920938463463374607431768211456
    store["strkey2"].should == 340282366920938463463374607431768211456
    store["strkey2"] = 33
    store["strkey2"].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = 340282366920938463463374607431768211456
    store["strkey2"].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = 340282366920938463463374607431768211456
    store.fetch("strkey2", 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = 33
    store["strkey1"].should == 33
    store.load("strkey1").should == 33
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = 33
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == 33
    store.load("strkey1").should == 33
  end

  it 'stores values after clear' do
    store["strkey1"] = 33
    store["strkey2"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store["strkey1"] = 33
    store["strkey1"].should == 33
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = 33
    store.delete("strkey1").should == 33
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = 33
    store["strkey1"].should == 33
    store["strkey1"] = 340282366920938463463374607431768211456
    store["strkey1"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == 33
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = 33
    store["strkey1"].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = 33
    store.fetch("strkey1", 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = 33
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = 33
    store["strkey2"].should == 33
    store.load("strkey2").should == 33
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = 33
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == 33
    store.load("strkey2").should == 33
  end

  it 'stores values after clear' do
    store["strkey2"] = 33
    store["strkey1"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store["strkey2"] = 33
    store["strkey2"].should == 33
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = 33
    store.delete("strkey2").should == 33
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = 33
    store["strkey2"].should == 33
    store["strkey2"] = 340282366920938463463374607431768211456
    store["strkey2"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == 33
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = 33
    store["strkey2"].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = 33
    store.fetch("strkey2", 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = 33
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_stringkey_numbervalue ####################

shared_examples_for 'persist_stringkey_numbervalue' do
  it 'persists values' do
    store["strkey1"] = 123.456
    store.close
    @store = nil
    store["strkey1"].should == 123.456
  end

  it 'persists values' do
    store["strkey2"] = 123.456
    store.close
    @store = nil
    store["strkey2"].should == 123.456
  end

  it 'persists values' do
    store["strkey1"] = -98.7
    store.close
    @store = nil
    store["strkey1"].should == -98.7
  end

  it 'persists values' do
    store["strkey2"] = -98.7
    store.close
    @store = nil
    store["strkey2"].should == -98.7
  end

  it 'persists values' do
    store["strkey1"] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store["strkey1"].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store["strkey2"] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store["strkey2"].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store["strkey1"] = 33
    store.close
    @store = nil
    store["strkey1"].should == 33
  end

  it 'persists values' do
    store["strkey2"] = 33
    store.close
    @store = nil
    store["strkey2"].should == 33
  end
end

#################### null_stringkey_booleanvalue ####################

shared_examples_for 'null_stringkey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = true
    store["strkey2"] = false
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = true
    store["strkey1"] = false
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = false
    store["strkey2"] = true
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = false
    store["strkey1"] = true
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", false, options).should == false
  end
end

#################### store_stringkey_booleanvalue ####################

shared_examples_for 'store_stringkey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store["strkey1"] = true
    store["strkey1"].should == true
    store.load("strkey1").should == true
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = true
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == true
    store.load("strkey1").should == true
  end

  it 'stores values after clear' do
    store["strkey1"] = true
    store["strkey2"] = false
    store.clear.should equal(store)
    store["strkey1"] = true
    store["strkey1"].should == true
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = true
    store.delete("strkey1").should == true
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = true
    store["strkey1"].should == true
    store["strkey1"] = false
    store["strkey1"].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == true
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = true
    store["strkey1"].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = true
    store.fetch("strkey1", false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = true
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = true
    store["strkey2"].should == true
    store.load("strkey2").should == true
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = true
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == true
    store.load("strkey2").should == true
  end

  it 'stores values after clear' do
    store["strkey2"] = true
    store["strkey1"] = false
    store.clear.should equal(store)
    store["strkey2"] = true
    store["strkey2"].should == true
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = true
    store.delete("strkey2").should == true
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = true
    store["strkey2"].should == true
    store["strkey2"] = false
    store["strkey2"].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == true
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = true
    store["strkey2"].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = true
    store.fetch("strkey2", false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = true
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = false
    store["strkey1"].should == false
    store.load("strkey1").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = false
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == false
    store.load("strkey1").should == false
  end

  it 'stores values after clear' do
    store["strkey1"] = false
    store["strkey2"] = true
    store.clear.should equal(store)
    store["strkey1"] = false
    store["strkey1"].should == false
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = false
    store.delete("strkey1").should == false
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = false
    store["strkey1"].should == false
    store["strkey1"] = true
    store["strkey1"].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == false
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = false
    store["strkey1"].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = false
    store.fetch("strkey1", true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = false
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = false
    store["strkey2"].should == false
    store.load("strkey2").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = false
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == false
    store.load("strkey2").should == false
  end

  it 'stores values after clear' do
    store["strkey2"] = false
    store["strkey1"] = true
    store.clear.should equal(store)
    store["strkey2"] = false
    store["strkey2"].should == false
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = false
    store.delete("strkey2").should == false
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = false
    store["strkey2"].should == false
    store["strkey2"] = true
    store["strkey2"].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == false
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = false
    store["strkey2"].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = false
    store.fetch("strkey2", true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = false
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_stringkey_booleanvalue ####################

shared_examples_for 'persist_stringkey_booleanvalue' do
  it 'persists values' do
    store["strkey1"] = true
    store.close
    @store = nil
    store["strkey1"].should == true
  end

  it 'persists values' do
    store["strkey2"] = true
    store.close
    @store = nil
    store["strkey2"].should == true
  end

  it 'persists values' do
    store["strkey1"] = false
    store.close
    @store = nil
    store["strkey1"].should == false
  end

  it 'persists values' do
    store["strkey2"] = false
    store.close
    @store = nil
    store["strkey2"].should == false
  end
end

#################### null_stringkey_stringvalue ####################

shared_examples_for 'null_stringkey_stringvalue' do
  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = "strval1"
    store["strkey2"] = "strval2"
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = "strval1"
    store["strkey1"] = "strval2"
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = "strval2"
    store["strkey2"] = "strval1"
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = "strval2"
    store["strkey1"] = "strval1"
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", "strval2", options).should == "strval2"
  end
end

#################### store_stringkey_stringvalue ####################

shared_examples_for 'store_stringkey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store["strkey1"] = "strval1"
    store["strkey1"].should == "strval1"
    store.load("strkey1").should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = "strval1"
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == "strval1"
    store.load("strkey1").should == "strval1"
  end

  it 'stores values after clear' do
    store["strkey1"] = "strval1"
    store["strkey2"] = "strval2"
    store.clear.should equal(store)
    store["strkey1"] = "strval1"
    store["strkey1"].should == "strval1"
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = "strval1"
    store.delete("strkey1").should == "strval1"
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = "strval1"
    store["strkey1"].should == "strval1"
    store["strkey1"] = "strval2"
    store["strkey1"].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == "strval1"
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = "strval1"
    store["strkey1"].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = "strval1"
    store.fetch("strkey1", "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = "strval1"
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = "strval1"
    store["strkey2"].should == "strval1"
    store.load("strkey2").should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = "strval1"
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == "strval1"
    store.load("strkey2").should == "strval1"
  end

  it 'stores values after clear' do
    store["strkey2"] = "strval1"
    store["strkey1"] = "strval2"
    store.clear.should equal(store)
    store["strkey2"] = "strval1"
    store["strkey2"].should == "strval1"
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = "strval1"
    store.delete("strkey2").should == "strval1"
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = "strval1"
    store["strkey2"].should == "strval1"
    store["strkey2"] = "strval2"
    store["strkey2"].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == "strval1"
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = "strval1"
    store["strkey2"].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = "strval1"
    store.fetch("strkey2", "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = "strval1"
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = "strval2"
    store["strkey1"].should == "strval2"
    store.load("strkey1").should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = "strval2"
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == "strval2"
    store.load("strkey1").should == "strval2"
  end

  it 'stores values after clear' do
    store["strkey1"] = "strval2"
    store["strkey2"] = "strval1"
    store.clear.should equal(store)
    store["strkey1"] = "strval2"
    store["strkey1"].should == "strval2"
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = "strval2"
    store.delete("strkey1").should == "strval2"
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = "strval2"
    store["strkey1"].should == "strval2"
    store["strkey1"] = "strval1"
    store["strkey1"].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == "strval2"
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = "strval2"
    store["strkey1"].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = "strval2"
    store.fetch("strkey1", "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = "strval2"
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = "strval2"
    store["strkey2"].should == "strval2"
    store.load("strkey2").should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = "strval2"
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == "strval2"
    store.load("strkey2").should == "strval2"
  end

  it 'stores values after clear' do
    store["strkey2"] = "strval2"
    store["strkey1"] = "strval1"
    store.clear.should equal(store)
    store["strkey2"] = "strval2"
    store["strkey2"].should == "strval2"
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = "strval2"
    store.delete("strkey2").should == "strval2"
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = "strval2"
    store["strkey2"].should == "strval2"
    store["strkey2"] = "strval1"
    store["strkey2"].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == "strval2"
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = "strval2"
    store["strkey2"].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = "strval2"
    store.fetch("strkey2", "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = "strval2"
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_stringkey_stringvalue ####################

shared_examples_for 'returndifferent_stringkey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store["strkey1"] = value
    store["strkey1"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store["strkey2"] = value
    store["strkey2"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store["strkey1"] = value
    store["strkey1"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store["strkey2"] = value
    store["strkey2"].should_not be_equal(value)
  end
end

#################### returnsame_stringkey_stringvalue ####################

shared_examples_for 'returnsame_stringkey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store["strkey1"] = value
    store["strkey1"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store["strkey2"] = value
    store["strkey2"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store["strkey1"] = value
    store["strkey1"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store["strkey2"] = value
    store["strkey2"].should be_equal(value)
  end
end

#################### persist_stringkey_stringvalue ####################

shared_examples_for 'persist_stringkey_stringvalue' do
  it 'persists values' do
    store["strkey1"] = "strval1"
    store.close
    @store = nil
    store["strkey1"].should == "strval1"
  end

  it 'persists values' do
    store["strkey2"] = "strval1"
    store.close
    @store = nil
    store["strkey2"].should == "strval1"
  end

  it 'persists values' do
    store["strkey1"] = "strval2"
    store.close
    @store = nil
    store["strkey1"].should == "strval2"
  end

  it 'persists values' do
    store["strkey2"] = "strval2"
    store.close
    @store = nil
    store["strkey2"].should == "strval2"
  end
end

#################### null_stringkey_binaryvalue ####################

shared_examples_for 'null_stringkey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = "ber"
    store["strkey2"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = "ber"
    store["strkey1"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = "\xAA\xBB\xCC"
    store["strkey2"] = "ber"
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = "\xAA\xBB\xCC"
    store["strkey1"] = "ber"
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_stringkey_binaryvalue ####################

shared_examples_for 'store_stringkey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store["strkey1"] = "ber"
    store["strkey1"].should == "ber"
    store.load("strkey1").should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = "ber"
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == "ber"
    store.load("strkey1").should == "ber"
  end

  it 'stores values after clear' do
    store["strkey1"] = "ber"
    store["strkey2"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store["strkey1"] = "ber"
    store["strkey1"].should == "ber"
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = "ber"
    store.delete("strkey1").should == "ber"
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = "ber"
    store["strkey1"].should == "ber"
    store["strkey1"] = "\xAA\xBB\xCC"
    store["strkey1"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == "ber"
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = "ber"
    store["strkey1"].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = "ber"
    store.fetch("strkey1", "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = "ber"
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = "ber"
    store["strkey2"].should == "ber"
    store.load("strkey2").should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = "ber"
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == "ber"
    store.load("strkey2").should == "ber"
  end

  it 'stores values after clear' do
    store["strkey2"] = "ber"
    store["strkey1"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store["strkey2"] = "ber"
    store["strkey2"].should == "ber"
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = "ber"
    store.delete("strkey2").should == "ber"
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = "ber"
    store["strkey2"].should == "ber"
    store["strkey2"] = "\xAA\xBB\xCC"
    store["strkey2"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == "ber"
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = "ber"
    store["strkey2"].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = "ber"
    store.fetch("strkey2", "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = "ber"
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = "\xAA\xBB\xCC"
    store["strkey1"].should == "\xAA\xBB\xCC"
    store.load("strkey1").should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = "\xAA\xBB\xCC"
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == "\xAA\xBB\xCC"
    store.load("strkey1").should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store["strkey1"] = "\xAA\xBB\xCC"
    store["strkey2"] = "ber"
    store.clear.should equal(store)
    store["strkey1"] = "\xAA\xBB\xCC"
    store["strkey1"].should == "\xAA\xBB\xCC"
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = "\xAA\xBB\xCC"
    store.delete("strkey1").should == "\xAA\xBB\xCC"
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = "\xAA\xBB\xCC"
    store["strkey1"].should == "\xAA\xBB\xCC"
    store["strkey1"] = "ber"
    store["strkey1"].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = "\xAA\xBB\xCC"
    store["strkey1"].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = "\xAA\xBB\xCC"
    store.fetch("strkey1", "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = "\xAA\xBB\xCC"
    store["strkey2"].should == "\xAA\xBB\xCC"
    store.load("strkey2").should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = "\xAA\xBB\xCC"
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == "\xAA\xBB\xCC"
    store.load("strkey2").should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store["strkey2"] = "\xAA\xBB\xCC"
    store["strkey1"] = "ber"
    store.clear.should equal(store)
    store["strkey2"] = "\xAA\xBB\xCC"
    store["strkey2"].should == "\xAA\xBB\xCC"
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = "\xAA\xBB\xCC"
    store.delete("strkey2").should == "\xAA\xBB\xCC"
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = "\xAA\xBB\xCC"
    store["strkey2"].should == "\xAA\xBB\xCC"
    store["strkey2"] = "ber"
    store["strkey2"].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = "\xAA\xBB\xCC"
    store["strkey2"].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = "\xAA\xBB\xCC"
    store.fetch("strkey2", "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_stringkey_binaryvalue ####################

shared_examples_for 'returndifferent_stringkey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store["strkey1"] = value
    store["strkey1"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store["strkey2"] = value
    store["strkey2"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["strkey1"] = value
    store["strkey1"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["strkey2"] = value
    store["strkey2"].should_not be_equal(value)
  end
end

#################### returnsame_stringkey_binaryvalue ####################

shared_examples_for 'returnsame_stringkey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store["strkey1"] = value
    store["strkey1"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store["strkey2"] = value
    store["strkey2"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["strkey1"] = value
    store["strkey1"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["strkey2"] = value
    store["strkey2"].should be_equal(value)
  end
end

#################### persist_stringkey_binaryvalue ####################

shared_examples_for 'persist_stringkey_binaryvalue' do
  it 'persists values' do
    store["strkey1"] = "ber"
    store.close
    @store = nil
    store["strkey1"].should == "ber"
  end

  it 'persists values' do
    store["strkey2"] = "ber"
    store.close
    @store = nil
    store["strkey2"].should == "ber"
  end

  it 'persists values' do
    store["strkey1"] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store["strkey1"].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store["strkey2"] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store["strkey2"].should == "\xAA\xBB\xCC"
  end
end

#################### null_stringkey_hashvalue ####################

shared_examples_for 'null_stringkey_hashvalue' do
  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_stringkey_hashvalue ####################

shared_examples_for 'store_stringkey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store.load("strkey1").should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store.load("strkey1").should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.delete("strkey1").should == {"hashval1"=>["array1", 1]}
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.fetch("strkey1", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store["strkey2"].should == {"hashval1"=>["array1", 1]}
    store.load("strkey2").should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == {"hashval1"=>["array1", 1]}
    store.load("strkey2").should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store["strkey2"].should == {"hashval1"=>["array1", 1]}
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store.delete("strkey2").should == {"hashval1"=>["array1", 1]}
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store["strkey2"].should == {"hashval1"=>["array1", 1]}
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store["strkey2"].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store.fetch("strkey2", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("strkey1").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("strkey1").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete("strkey1").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch("strkey1", {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("strkey2").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("strkey2").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete("strkey2").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store["strkey2"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch("strkey2", {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_stringkey_hashvalue ####################

shared_examples_for 'returndifferent_stringkey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["strkey1"] = value
    store["strkey1"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["strkey2"] = value
    store["strkey2"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"] = value
    store["strkey1"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"] = value
    store["strkey2"].should_not be_equal(value)
  end
end

#################### returnsame_stringkey_hashvalue ####################

shared_examples_for 'returnsame_stringkey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["strkey1"] = value
    store["strkey1"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["strkey2"] = value
    store["strkey2"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey1"] = value
    store["strkey1"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["strkey2"] = value
    store["strkey2"].should be_equal(value)
  end
end

#################### persist_stringkey_hashvalue ####################

shared_examples_for 'persist_stringkey_hashvalue' do
  it 'persists values' do
    store["strkey1"] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store["strkey1"].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store["strkey2"] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store["strkey2"].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store["strkey1"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store["strkey1"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store["strkey2"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store["strkey2"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_stringkey_objectvalue ####################

shared_examples_for 'null_stringkey_objectvalue' do
  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = Value.new(:objval1)
    store["strkey2"] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = Value.new(:objval1)
    store["strkey1"] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store["strkey1"].should be_nil
    store.load("strkey1").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store["strkey1"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey1").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey1").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey1"] = Value.new(:objval2)
    store["strkey2"] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?("strkey1").should be_false
    store.key?("strkey2").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey1", Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey1"
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey1", options).should be_false
    store.load("strkey1", options).should be_nil
    store.fetch("strkey1", 42, options).should == 42
    store.fetch("strkey1", options) { 42 }.should == 42
    store.delete("strkey1", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey1", Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store["strkey2"].should be_nil
    store.load("strkey2").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store["strkey2"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("strkey2").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("strkey2").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["strkey2"] = Value.new(:objval2)
    store["strkey1"] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?("strkey2").should be_false
    store.key?("strkey1").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("strkey2", Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "strkey2"
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("strkey2", options).should be_false
    store.load("strkey2", options).should be_nil
    store.fetch("strkey2", 42, options).should == 42
    store.fetch("strkey2", options) { 42 }.should == 42
    store.delete("strkey2", options).should be_nil
    store.clear(options).should equal(store)
    store.store("strkey2", Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_stringkey_objectvalue ####################

shared_examples_for 'store_stringkey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store["strkey1"] = Value.new(:objval1)
    store["strkey1"].should == Value.new(:objval1)
    store.load("strkey1").should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = Value.new(:objval1)
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == Value.new(:objval1)
    store.load("strkey1").should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store["strkey1"] = Value.new(:objval1)
    store["strkey2"] = Value.new(:objval2)
    store.clear.should equal(store)
    store["strkey1"] = Value.new(:objval1)
    store["strkey1"].should == Value.new(:objval1)
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = Value.new(:objval1)
    store.delete("strkey1").should == Value.new(:objval1)
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = Value.new(:objval1)
    store["strkey1"].should == Value.new(:objval1)
    store["strkey1"] = Value.new(:objval2)
    store["strkey1"].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = Value.new(:objval1)
    store["strkey1"].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = Value.new(:objval1)
    store.fetch("strkey1", Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = Value.new(:objval1)
    store["strkey2"].should == Value.new(:objval1)
    store.load("strkey2").should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = Value.new(:objval1)
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == Value.new(:objval1)
    store.load("strkey2").should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store["strkey2"] = Value.new(:objval1)
    store["strkey1"] = Value.new(:objval2)
    store.clear.should equal(store)
    store["strkey2"] = Value.new(:objval1)
    store["strkey2"].should == Value.new(:objval1)
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = Value.new(:objval1)
    store.delete("strkey2").should == Value.new(:objval1)
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = Value.new(:objval1)
    store["strkey2"].should == Value.new(:objval1)
    store["strkey2"] = Value.new(:objval2)
    store["strkey2"].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = Value.new(:objval1)
    store["strkey2"].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = Value.new(:objval1)
    store.fetch("strkey2", Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey1"] = Value.new(:objval2)
    store["strkey1"].should == Value.new(:objval2)
    store.load("strkey1").should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store["strkey1"] = Value.new(:objval2)
    store.key?("strkey1").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store("strkey1", value).should equal(value)
    store["strkey1"].should == Value.new(:objval2)
    store.load("strkey1").should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store["strkey1"] = Value.new(:objval2)
    store["strkey2"] = Value.new(:objval1)
    store.clear.should equal(store)
    store["strkey1"] = Value.new(:objval2)
    store["strkey1"].should == Value.new(:objval2)
    store["strkey2"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey1"] = Value.new(:objval2)
    store.delete("strkey1").should == Value.new(:objval2)
    store.key?("strkey1").should be_false
  end

  it 'overwrites existing values' do
    store["strkey1"] = Value.new(:objval2)
    store["strkey1"].should == Value.new(:objval2)
    store["strkey1"] = Value.new(:objval1)
    store["strkey1"].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store["strkey1"] = value).should equal(value)
    store["strkey1"].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = "strkey1".freeze
    store[key] = Value.new(:objval2)
    store["strkey1"].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey1"] = Value.new(:objval2)
    store.fetch("strkey1", Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey1"] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch("strkey1") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["strkey2"] = Value.new(:objval2)
    store["strkey2"].should == Value.new(:objval2)
    store.load("strkey2").should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store["strkey2"] = Value.new(:objval2)
    store.key?("strkey2").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store("strkey2", value).should equal(value)
    store["strkey2"].should == Value.new(:objval2)
    store.load("strkey2").should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store["strkey2"] = Value.new(:objval2)
    store["strkey1"] = Value.new(:objval1)
    store.clear.should equal(store)
    store["strkey2"] = Value.new(:objval2)
    store["strkey2"].should == Value.new(:objval2)
    store["strkey1"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["strkey2"] = Value.new(:objval2)
    store.delete("strkey2").should == Value.new(:objval2)
    store.key?("strkey2").should be_false
  end

  it 'overwrites existing values' do
    store["strkey2"] = Value.new(:objval2)
    store["strkey2"].should == Value.new(:objval2)
    store["strkey2"] = Value.new(:objval1)
    store["strkey2"].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store["strkey2"] = value).should equal(value)
    store["strkey2"].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = "strkey2".freeze
    store[key] = Value.new(:objval2)
    store["strkey2"].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["strkey2"] = Value.new(:objval2)
    store.fetch("strkey2", Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store["strkey2"] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch("strkey2") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_stringkey_objectvalue ####################

shared_examples_for 'returndifferent_stringkey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store["strkey1"] = value
    store["strkey1"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store["strkey2"] = value
    store["strkey2"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store["strkey1"] = value
    store["strkey1"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store["strkey2"] = value
    store["strkey2"].should_not be_equal(value)
  end
end

#################### returnsame_stringkey_objectvalue ####################

shared_examples_for 'returnsame_stringkey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store["strkey1"] = value
    store["strkey1"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store["strkey2"] = value
    store["strkey2"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store["strkey1"] = value
    store["strkey1"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store["strkey2"] = value
    store["strkey2"].should be_equal(value)
  end
end

#################### persist_stringkey_objectvalue ####################

shared_examples_for 'persist_stringkey_objectvalue' do
  it 'persists values' do
    store["strkey1"] = Value.new(:objval1)
    store.close
    @store = nil
    store["strkey1"].should == Value.new(:objval1)
  end

  it 'persists values' do
    store["strkey2"] = Value.new(:objval1)
    store.close
    @store = nil
    store["strkey2"].should == Value.new(:objval1)
  end

  it 'persists values' do
    store["strkey1"] = Value.new(:objval2)
    store.close
    @store = nil
    store["strkey1"].should == Value.new(:objval2)
  end

  it 'persists values' do
    store["strkey2"] = Value.new(:objval2)
    store.close
    @store = nil
    store["strkey2"].should == Value.new(:objval2)
  end
end

#################### null_pathkey_nilvalue ####################

shared_examples_for 'null_pathkey_nilvalue' do
  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = ''
    store["foo/bar"] = nil
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = ''
    store["bar/foo/baz"] = nil
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = nil
    store["foo/bar"] = ''
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = nil
    store["bar/foo/baz"] = ''
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = 0
    store["foo/bar"] = false
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = 0
    store["bar/foo/baz"] = false
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = false
    store["foo/bar"] = 0
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = false
    store["bar/foo/baz"] = 0
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", false, options).should == false
  end
end

#################### store_pathkey_nilvalue ####################

shared_examples_for 'store_pathkey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = ''
    store["bar/foo/baz"].should == ''
    store.load("bar/foo/baz").should == ''
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = ''
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == ''
    store.load("bar/foo/baz").should == ''
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = ''
    store["foo/bar"] = nil
    store.clear.should equal(store)
    store["bar/foo/baz"] = ''
    store["bar/foo/baz"].should == ''
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = ''
    store.delete("bar/foo/baz").should == ''
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = ''
    store["bar/foo/baz"].should == ''
    store["bar/foo/baz"] = nil
    store["bar/foo/baz"].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == ''
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = ''
    store["bar/foo/baz"].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = ''
    store["foo/bar"].should == ''
    store.load("foo/bar").should == ''
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = ''
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == ''
    store.load("foo/bar").should == ''
  end

  it 'stores values after clear' do
    store["foo/bar"] = ''
    store["bar/foo/baz"] = nil
    store.clear.should equal(store)
    store["foo/bar"] = ''
    store["foo/bar"].should == ''
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = ''
    store.delete("foo/bar").should == ''
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = ''
    store["foo/bar"].should == ''
    store["foo/bar"] = nil
    store["foo/bar"].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == ''
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = ''
    store["foo/bar"].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = nil
    store["bar/foo/baz"].should == nil
    store.load("bar/foo/baz").should == nil
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = nil
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == nil
    store.load("bar/foo/baz").should == nil
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = nil
    store["foo/bar"] = ''
    store.clear.should equal(store)
    store["bar/foo/baz"] = nil
    store["bar/foo/baz"].should == nil
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = nil
    store.delete("bar/foo/baz").should == nil
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = nil
    store["bar/foo/baz"].should == nil
    store["bar/foo/baz"] = ''
    store["bar/foo/baz"].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == nil
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = nil
    store["bar/foo/baz"].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = nil
    store["foo/bar"].should == nil
    store.load("foo/bar").should == nil
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = nil
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == nil
    store.load("foo/bar").should == nil
  end

  it 'stores values after clear' do
    store["foo/bar"] = nil
    store["bar/foo/baz"] = ''
    store.clear.should equal(store)
    store["foo/bar"] = nil
    store["foo/bar"].should == nil
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = nil
    store.delete("foo/bar").should == nil
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = nil
    store["foo/bar"].should == nil
    store["foo/bar"] = ''
    store["foo/bar"].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == nil
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = nil
    store["foo/bar"].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = 0
    store["bar/foo/baz"].should == 0
    store.load("bar/foo/baz").should == 0
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = 0
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == 0
    store.load("bar/foo/baz").should == 0
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = 0
    store["foo/bar"] = false
    store.clear.should equal(store)
    store["bar/foo/baz"] = 0
    store["bar/foo/baz"].should == 0
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = 0
    store.delete("bar/foo/baz").should == 0
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = 0
    store["bar/foo/baz"].should == 0
    store["bar/foo/baz"] = false
    store["bar/foo/baz"].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == 0
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = 0
    store["bar/foo/baz"].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = 0
    store["foo/bar"].should == 0
    store.load("foo/bar").should == 0
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = 0
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == 0
    store.load("foo/bar").should == 0
  end

  it 'stores values after clear' do
    store["foo/bar"] = 0
    store["bar/foo/baz"] = false
    store.clear.should equal(store)
    store["foo/bar"] = 0
    store["foo/bar"].should == 0
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = 0
    store.delete("foo/bar").should == 0
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = 0
    store["foo/bar"].should == 0
    store["foo/bar"] = false
    store["foo/bar"].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == 0
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = 0
    store["foo/bar"].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = false
    store["bar/foo/baz"].should == false
    store.load("bar/foo/baz").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = false
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == false
    store.load("bar/foo/baz").should == false
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = false
    store["foo/bar"] = 0
    store.clear.should equal(store)
    store["bar/foo/baz"] = false
    store["bar/foo/baz"].should == false
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = false
    store.delete("bar/foo/baz").should == false
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = false
    store["bar/foo/baz"].should == false
    store["bar/foo/baz"] = 0
    store["bar/foo/baz"].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == false
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = false
    store["bar/foo/baz"].should == false
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = false
    store["foo/bar"].should == false
    store.load("foo/bar").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = false
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == false
    store.load("foo/bar").should == false
  end

  it 'stores values after clear' do
    store["foo/bar"] = false
    store["bar/foo/baz"] = 0
    store.clear.should equal(store)
    store["foo/bar"] = false
    store["foo/bar"].should == false
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = false
    store.delete("foo/bar").should == false
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = false
    store["foo/bar"].should == false
    store["foo/bar"] = 0
    store["foo/bar"].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == false
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = false
    store["foo/bar"].should == false
  end
end

#################### persist_pathkey_nilvalue ####################

shared_examples_for 'persist_pathkey_nilvalue' do
  it 'persists values' do
    store["bar/foo/baz"] = ''
    store.close
    @store = nil
    store["bar/foo/baz"].should == ''
  end

  it 'persists values' do
    store["foo/bar"] = ''
    store.close
    @store = nil
    store["foo/bar"].should == ''
  end

  it 'persists values' do
    store["bar/foo/baz"] = nil
    store.close
    @store = nil
    store["bar/foo/baz"].should == nil
  end

  it 'persists values' do
    store["foo/bar"] = nil
    store.close
    @store = nil
    store["foo/bar"].should == nil
  end

  it 'persists values' do
    store["bar/foo/baz"] = 0
    store.close
    @store = nil
    store["bar/foo/baz"].should == 0
  end

  it 'persists values' do
    store["foo/bar"] = 0
    store.close
    @store = nil
    store["foo/bar"].should == 0
  end

  it 'persists values' do
    store["bar/foo/baz"] = false
    store.close
    @store = nil
    store["bar/foo/baz"].should == false
  end

  it 'persists values' do
    store["foo/bar"] = false
    store.close
    @store = nil
    store["foo/bar"].should == false
  end
end

#################### null_pathkey_integervalue ####################

shared_examples_for 'null_pathkey_integervalue' do
  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = 41
    store["foo/bar"] = -12
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = 41
    store["bar/foo/baz"] = -12
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = -12
    store["foo/bar"] = 41
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = -12
    store["bar/foo/baz"] = 41
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", -12, options).should == -12
  end
end

#################### store_pathkey_integervalue ####################

shared_examples_for 'store_pathkey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = 41
    store["bar/foo/baz"].should == 41
    store.load("bar/foo/baz").should == 41
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = 41
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == 41
    store.load("bar/foo/baz").should == 41
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = 41
    store["foo/bar"] = -12
    store.clear.should equal(store)
    store["bar/foo/baz"] = 41
    store["bar/foo/baz"].should == 41
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = 41
    store.delete("bar/foo/baz").should == 41
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = 41
    store["bar/foo/baz"].should == 41
    store["bar/foo/baz"] = -12
    store["bar/foo/baz"].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == 41
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = 41
    store["bar/foo/baz"].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = 41
    store.fetch("bar/foo/baz", -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = 41
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = 41
    store["foo/bar"].should == 41
    store.load("foo/bar").should == 41
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = 41
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == 41
    store.load("foo/bar").should == 41
  end

  it 'stores values after clear' do
    store["foo/bar"] = 41
    store["bar/foo/baz"] = -12
    store.clear.should equal(store)
    store["foo/bar"] = 41
    store["foo/bar"].should == 41
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = 41
    store.delete("foo/bar").should == 41
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = 41
    store["foo/bar"].should == 41
    store["foo/bar"] = -12
    store["foo/bar"].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == 41
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = 41
    store["foo/bar"].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = 41
    store.fetch("foo/bar", -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = 41
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = -12
    store["bar/foo/baz"].should == -12
    store.load("bar/foo/baz").should == -12
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = -12
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == -12
    store.load("bar/foo/baz").should == -12
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = -12
    store["foo/bar"] = 41
    store.clear.should equal(store)
    store["bar/foo/baz"] = -12
    store["bar/foo/baz"].should == -12
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = -12
    store.delete("bar/foo/baz").should == -12
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = -12
    store["bar/foo/baz"].should == -12
    store["bar/foo/baz"] = 41
    store["bar/foo/baz"].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == -12
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = -12
    store["bar/foo/baz"].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = -12
    store.fetch("bar/foo/baz", 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = -12
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = -12
    store["foo/bar"].should == -12
    store.load("foo/bar").should == -12
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = -12
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == -12
    store.load("foo/bar").should == -12
  end

  it 'stores values after clear' do
    store["foo/bar"] = -12
    store["bar/foo/baz"] = 41
    store.clear.should equal(store)
    store["foo/bar"] = -12
    store["foo/bar"].should == -12
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = -12
    store.delete("foo/bar").should == -12
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = -12
    store["foo/bar"].should == -12
    store["foo/bar"] = 41
    store["foo/bar"].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == -12
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = -12
    store["foo/bar"].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = -12
    store.fetch("foo/bar", 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = -12
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_pathkey_integervalue ####################

shared_examples_for 'persist_pathkey_integervalue' do
  it 'persists values' do
    store["bar/foo/baz"] = 41
    store.close
    @store = nil
    store["bar/foo/baz"].should == 41
  end

  it 'persists values' do
    store["foo/bar"] = 41
    store.close
    @store = nil
    store["foo/bar"].should == 41
  end

  it 'persists values' do
    store["bar/foo/baz"] = -12
    store.close
    @store = nil
    store["bar/foo/baz"].should == -12
  end

  it 'persists values' do
    store["foo/bar"] = -12
    store.close
    @store = nil
    store["foo/bar"].should == -12
  end
end

#################### null_pathkey_numbervalue ####################

shared_examples_for 'null_pathkey_numbervalue' do
  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = 123.456
    store["foo/bar"] = -98.7
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = 123.456
    store["bar/foo/baz"] = -98.7
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = -98.7
    store["foo/bar"] = 123.456
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = -98.7
    store["bar/foo/baz"] = 123.456
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store["foo/bar"] = 33
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    store["bar/foo/baz"] = 33
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = 33
    store["foo/bar"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = 33
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", 33, options).should == 33
  end
end

#################### store_pathkey_numbervalue ####################

shared_examples_for 'store_pathkey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = 123.456
    store["bar/foo/baz"].should == 123.456
    store.load("bar/foo/baz").should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = 123.456
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == 123.456
    store.load("bar/foo/baz").should == 123.456
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = 123.456
    store["foo/bar"] = -98.7
    store.clear.should equal(store)
    store["bar/foo/baz"] = 123.456
    store["bar/foo/baz"].should == 123.456
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = 123.456
    store.delete("bar/foo/baz").should == 123.456
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = 123.456
    store["bar/foo/baz"].should == 123.456
    store["bar/foo/baz"] = -98.7
    store["bar/foo/baz"].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == 123.456
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = 123.456
    store["bar/foo/baz"].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = 123.456
    store.fetch("bar/foo/baz", -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = 123.456
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = 123.456
    store["foo/bar"].should == 123.456
    store.load("foo/bar").should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = 123.456
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == 123.456
    store.load("foo/bar").should == 123.456
  end

  it 'stores values after clear' do
    store["foo/bar"] = 123.456
    store["bar/foo/baz"] = -98.7
    store.clear.should equal(store)
    store["foo/bar"] = 123.456
    store["foo/bar"].should == 123.456
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = 123.456
    store.delete("foo/bar").should == 123.456
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = 123.456
    store["foo/bar"].should == 123.456
    store["foo/bar"] = -98.7
    store["foo/bar"].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == 123.456
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = 123.456
    store["foo/bar"].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = 123.456
    store.fetch("foo/bar", -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = 123.456
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = -98.7
    store["bar/foo/baz"].should == -98.7
    store.load("bar/foo/baz").should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = -98.7
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == -98.7
    store.load("bar/foo/baz").should == -98.7
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = -98.7
    store["foo/bar"] = 123.456
    store.clear.should equal(store)
    store["bar/foo/baz"] = -98.7
    store["bar/foo/baz"].should == -98.7
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = -98.7
    store.delete("bar/foo/baz").should == -98.7
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = -98.7
    store["bar/foo/baz"].should == -98.7
    store["bar/foo/baz"] = 123.456
    store["bar/foo/baz"].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == -98.7
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = -98.7
    store["bar/foo/baz"].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = -98.7
    store.fetch("bar/foo/baz", 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = -98.7
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = -98.7
    store["foo/bar"].should == -98.7
    store.load("foo/bar").should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = -98.7
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == -98.7
    store.load("foo/bar").should == -98.7
  end

  it 'stores values after clear' do
    store["foo/bar"] = -98.7
    store["bar/foo/baz"] = 123.456
    store.clear.should equal(store)
    store["foo/bar"] = -98.7
    store["foo/bar"].should == -98.7
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = -98.7
    store.delete("foo/bar").should == -98.7
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = -98.7
    store["foo/bar"].should == -98.7
    store["foo/bar"] = 123.456
    store["foo/bar"].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == -98.7
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = -98.7
    store["foo/bar"].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = -98.7
    store.fetch("foo/bar", 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = -98.7
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store["bar/foo/baz"].should == 340282366920938463463374607431768211456
    store.load("bar/foo/baz").should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == 340282366920938463463374607431768211456
    store.load("bar/foo/baz").should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store["foo/bar"] = 33
    store.clear.should equal(store)
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store["bar/foo/baz"].should == 340282366920938463463374607431768211456
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store.delete("bar/foo/baz").should == 340282366920938463463374607431768211456
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store["bar/foo/baz"].should == 340282366920938463463374607431768211456
    store["bar/foo/baz"] = 33
    store["bar/foo/baz"].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = 340282366920938463463374607431768211456
    store["bar/foo/baz"].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store.fetch("bar/foo/baz", 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    store["foo/bar"].should == 340282366920938463463374607431768211456
    store.load("foo/bar").should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == 340282366920938463463374607431768211456
    store.load("foo/bar").should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    store["bar/foo/baz"] = 33
    store.clear.should equal(store)
    store["foo/bar"] = 340282366920938463463374607431768211456
    store["foo/bar"].should == 340282366920938463463374607431768211456
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    store.delete("foo/bar").should == 340282366920938463463374607431768211456
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    store["foo/bar"].should == 340282366920938463463374607431768211456
    store["foo/bar"] = 33
    store["foo/bar"].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = 340282366920938463463374607431768211456
    store["foo/bar"].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    store.fetch("foo/bar", 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = 33
    store["bar/foo/baz"].should == 33
    store.load("bar/foo/baz").should == 33
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = 33
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == 33
    store.load("bar/foo/baz").should == 33
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = 33
    store["foo/bar"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store["bar/foo/baz"] = 33
    store["bar/foo/baz"].should == 33
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = 33
    store.delete("bar/foo/baz").should == 33
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = 33
    store["bar/foo/baz"].should == 33
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store["bar/foo/baz"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == 33
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = 33
    store["bar/foo/baz"].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = 33
    store.fetch("bar/foo/baz", 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = 33
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = 33
    store["foo/bar"].should == 33
    store.load("foo/bar").should == 33
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = 33
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == 33
    store.load("foo/bar").should == 33
  end

  it 'stores values after clear' do
    store["foo/bar"] = 33
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store["foo/bar"] = 33
    store["foo/bar"].should == 33
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = 33
    store.delete("foo/bar").should == 33
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = 33
    store["foo/bar"].should == 33
    store["foo/bar"] = 340282366920938463463374607431768211456
    store["foo/bar"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == 33
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = 33
    store["foo/bar"].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = 33
    store.fetch("foo/bar", 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = 33
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_pathkey_numbervalue ####################

shared_examples_for 'persist_pathkey_numbervalue' do
  it 'persists values' do
    store["bar/foo/baz"] = 123.456
    store.close
    @store = nil
    store["bar/foo/baz"].should == 123.456
  end

  it 'persists values' do
    store["foo/bar"] = 123.456
    store.close
    @store = nil
    store["foo/bar"].should == 123.456
  end

  it 'persists values' do
    store["bar/foo/baz"] = -98.7
    store.close
    @store = nil
    store["bar/foo/baz"].should == -98.7
  end

  it 'persists values' do
    store["foo/bar"] = -98.7
    store.close
    @store = nil
    store["foo/bar"].should == -98.7
  end

  it 'persists values' do
    store["bar/foo/baz"] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store["bar/foo/baz"].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store["foo/bar"] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store["foo/bar"].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store["bar/foo/baz"] = 33
    store.close
    @store = nil
    store["bar/foo/baz"].should == 33
  end

  it 'persists values' do
    store["foo/bar"] = 33
    store.close
    @store = nil
    store["foo/bar"].should == 33
  end
end

#################### null_pathkey_booleanvalue ####################

shared_examples_for 'null_pathkey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = true
    store["foo/bar"] = false
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = true
    store["bar/foo/baz"] = false
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = false
    store["foo/bar"] = true
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = false
    store["bar/foo/baz"] = true
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", false, options).should == false
  end
end

#################### store_pathkey_booleanvalue ####################

shared_examples_for 'store_pathkey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = true
    store["bar/foo/baz"].should == true
    store.load("bar/foo/baz").should == true
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = true
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == true
    store.load("bar/foo/baz").should == true
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = true
    store["foo/bar"] = false
    store.clear.should equal(store)
    store["bar/foo/baz"] = true
    store["bar/foo/baz"].should == true
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = true
    store.delete("bar/foo/baz").should == true
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = true
    store["bar/foo/baz"].should == true
    store["bar/foo/baz"] = false
    store["bar/foo/baz"].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == true
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = true
    store["bar/foo/baz"].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = true
    store.fetch("bar/foo/baz", false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = true
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = true
    store["foo/bar"].should == true
    store.load("foo/bar").should == true
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = true
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == true
    store.load("foo/bar").should == true
  end

  it 'stores values after clear' do
    store["foo/bar"] = true
    store["bar/foo/baz"] = false
    store.clear.should equal(store)
    store["foo/bar"] = true
    store["foo/bar"].should == true
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = true
    store.delete("foo/bar").should == true
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = true
    store["foo/bar"].should == true
    store["foo/bar"] = false
    store["foo/bar"].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == true
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = true
    store["foo/bar"].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = true
    store.fetch("foo/bar", false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = true
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = false
    store["bar/foo/baz"].should == false
    store.load("bar/foo/baz").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = false
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == false
    store.load("bar/foo/baz").should == false
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = false
    store["foo/bar"] = true
    store.clear.should equal(store)
    store["bar/foo/baz"] = false
    store["bar/foo/baz"].should == false
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = false
    store.delete("bar/foo/baz").should == false
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = false
    store["bar/foo/baz"].should == false
    store["bar/foo/baz"] = true
    store["bar/foo/baz"].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == false
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = false
    store["bar/foo/baz"].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = false
    store.fetch("bar/foo/baz", true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = false
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = false
    store["foo/bar"].should == false
    store.load("foo/bar").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = false
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == false
    store.load("foo/bar").should == false
  end

  it 'stores values after clear' do
    store["foo/bar"] = false
    store["bar/foo/baz"] = true
    store.clear.should equal(store)
    store["foo/bar"] = false
    store["foo/bar"].should == false
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = false
    store.delete("foo/bar").should == false
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = false
    store["foo/bar"].should == false
    store["foo/bar"] = true
    store["foo/bar"].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == false
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = false
    store["foo/bar"].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = false
    store.fetch("foo/bar", true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = false
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_pathkey_booleanvalue ####################

shared_examples_for 'persist_pathkey_booleanvalue' do
  it 'persists values' do
    store["bar/foo/baz"] = true
    store.close
    @store = nil
    store["bar/foo/baz"].should == true
  end

  it 'persists values' do
    store["foo/bar"] = true
    store.close
    @store = nil
    store["foo/bar"].should == true
  end

  it 'persists values' do
    store["bar/foo/baz"] = false
    store.close
    @store = nil
    store["bar/foo/baz"].should == false
  end

  it 'persists values' do
    store["foo/bar"] = false
    store.close
    @store = nil
    store["foo/bar"].should == false
  end
end

#################### null_pathkey_stringvalue ####################

shared_examples_for 'null_pathkey_stringvalue' do
  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = "strval1"
    store["foo/bar"] = "strval2"
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = "strval1"
    store["bar/foo/baz"] = "strval2"
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = "strval2"
    store["foo/bar"] = "strval1"
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = "strval2"
    store["bar/foo/baz"] = "strval1"
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", "strval2", options).should == "strval2"
  end
end

#################### store_pathkey_stringvalue ####################

shared_examples_for 'store_pathkey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = "strval1"
    store["bar/foo/baz"].should == "strval1"
    store.load("bar/foo/baz").should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = "strval1"
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == "strval1"
    store.load("bar/foo/baz").should == "strval1"
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = "strval1"
    store["foo/bar"] = "strval2"
    store.clear.should equal(store)
    store["bar/foo/baz"] = "strval1"
    store["bar/foo/baz"].should == "strval1"
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = "strval1"
    store.delete("bar/foo/baz").should == "strval1"
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = "strval1"
    store["bar/foo/baz"].should == "strval1"
    store["bar/foo/baz"] = "strval2"
    store["bar/foo/baz"].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == "strval1"
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = "strval1"
    store["bar/foo/baz"].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = "strval1"
    store.fetch("bar/foo/baz", "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = "strval1"
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = "strval1"
    store["foo/bar"].should == "strval1"
    store.load("foo/bar").should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = "strval1"
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == "strval1"
    store.load("foo/bar").should == "strval1"
  end

  it 'stores values after clear' do
    store["foo/bar"] = "strval1"
    store["bar/foo/baz"] = "strval2"
    store.clear.should equal(store)
    store["foo/bar"] = "strval1"
    store["foo/bar"].should == "strval1"
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = "strval1"
    store.delete("foo/bar").should == "strval1"
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = "strval1"
    store["foo/bar"].should == "strval1"
    store["foo/bar"] = "strval2"
    store["foo/bar"].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == "strval1"
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = "strval1"
    store["foo/bar"].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = "strval1"
    store.fetch("foo/bar", "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = "strval1"
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = "strval2"
    store["bar/foo/baz"].should == "strval2"
    store.load("bar/foo/baz").should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = "strval2"
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == "strval2"
    store.load("bar/foo/baz").should == "strval2"
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = "strval2"
    store["foo/bar"] = "strval1"
    store.clear.should equal(store)
    store["bar/foo/baz"] = "strval2"
    store["bar/foo/baz"].should == "strval2"
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = "strval2"
    store.delete("bar/foo/baz").should == "strval2"
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = "strval2"
    store["bar/foo/baz"].should == "strval2"
    store["bar/foo/baz"] = "strval1"
    store["bar/foo/baz"].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == "strval2"
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = "strval2"
    store["bar/foo/baz"].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = "strval2"
    store.fetch("bar/foo/baz", "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = "strval2"
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = "strval2"
    store["foo/bar"].should == "strval2"
    store.load("foo/bar").should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = "strval2"
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == "strval2"
    store.load("foo/bar").should == "strval2"
  end

  it 'stores values after clear' do
    store["foo/bar"] = "strval2"
    store["bar/foo/baz"] = "strval1"
    store.clear.should equal(store)
    store["foo/bar"] = "strval2"
    store["foo/bar"].should == "strval2"
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = "strval2"
    store.delete("foo/bar").should == "strval2"
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = "strval2"
    store["foo/bar"].should == "strval2"
    store["foo/bar"] = "strval1"
    store["foo/bar"].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == "strval2"
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = "strval2"
    store["foo/bar"].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = "strval2"
    store.fetch("foo/bar", "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = "strval2"
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_pathkey_stringvalue ####################

shared_examples_for 'returndifferent_pathkey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store["foo/bar"] = value
    store["foo/bar"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store["foo/bar"] = value
    store["foo/bar"].should_not be_equal(value)
  end
end

#################### returnsame_pathkey_stringvalue ####################

shared_examples_for 'returnsame_pathkey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store["foo/bar"] = value
    store["foo/bar"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store["foo/bar"] = value
    store["foo/bar"].should be_equal(value)
  end
end

#################### persist_pathkey_stringvalue ####################

shared_examples_for 'persist_pathkey_stringvalue' do
  it 'persists values' do
    store["bar/foo/baz"] = "strval1"
    store.close
    @store = nil
    store["bar/foo/baz"].should == "strval1"
  end

  it 'persists values' do
    store["foo/bar"] = "strval1"
    store.close
    @store = nil
    store["foo/bar"].should == "strval1"
  end

  it 'persists values' do
    store["bar/foo/baz"] = "strval2"
    store.close
    @store = nil
    store["bar/foo/baz"].should == "strval2"
  end

  it 'persists values' do
    store["foo/bar"] = "strval2"
    store.close
    @store = nil
    store["foo/bar"].should == "strval2"
  end
end

#################### null_pathkey_binaryvalue ####################

shared_examples_for 'null_pathkey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = "ber"
    store["foo/bar"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = "ber"
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store["foo/bar"] = "ber"
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    store["bar/foo/baz"] = "ber"
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_pathkey_binaryvalue ####################

shared_examples_for 'store_pathkey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = "ber"
    store["bar/foo/baz"].should == "ber"
    store.load("bar/foo/baz").should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = "ber"
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == "ber"
    store.load("bar/foo/baz").should == "ber"
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = "ber"
    store["foo/bar"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store["bar/foo/baz"] = "ber"
    store["bar/foo/baz"].should == "ber"
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = "ber"
    store.delete("bar/foo/baz").should == "ber"
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = "ber"
    store["bar/foo/baz"].should == "ber"
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store["bar/foo/baz"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == "ber"
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = "ber"
    store["bar/foo/baz"].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = "ber"
    store.fetch("bar/foo/baz", "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = "ber"
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = "ber"
    store["foo/bar"].should == "ber"
    store.load("foo/bar").should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = "ber"
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == "ber"
    store.load("foo/bar").should == "ber"
  end

  it 'stores values after clear' do
    store["foo/bar"] = "ber"
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store["foo/bar"] = "ber"
    store["foo/bar"].should == "ber"
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = "ber"
    store.delete("foo/bar").should == "ber"
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = "ber"
    store["foo/bar"].should == "ber"
    store["foo/bar"] = "\xAA\xBB\xCC"
    store["foo/bar"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == "ber"
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = "ber"
    store["foo/bar"].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = "ber"
    store.fetch("foo/bar", "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = "ber"
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store["bar/foo/baz"].should == "\xAA\xBB\xCC"
    store.load("bar/foo/baz").should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == "\xAA\xBB\xCC"
    store.load("bar/foo/baz").should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store["foo/bar"] = "ber"
    store.clear.should equal(store)
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store["bar/foo/baz"].should == "\xAA\xBB\xCC"
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store.delete("bar/foo/baz").should == "\xAA\xBB\xCC"
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store["bar/foo/baz"].should == "\xAA\xBB\xCC"
    store["bar/foo/baz"] = "ber"
    store["bar/foo/baz"].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = "\xAA\xBB\xCC"
    store["bar/foo/baz"].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store.fetch("bar/foo/baz", "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    store["foo/bar"].should == "\xAA\xBB\xCC"
    store.load("foo/bar").should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == "\xAA\xBB\xCC"
    store.load("foo/bar").should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    store["bar/foo/baz"] = "ber"
    store.clear.should equal(store)
    store["foo/bar"] = "\xAA\xBB\xCC"
    store["foo/bar"].should == "\xAA\xBB\xCC"
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    store.delete("foo/bar").should == "\xAA\xBB\xCC"
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    store["foo/bar"].should == "\xAA\xBB\xCC"
    store["foo/bar"] = "ber"
    store["foo/bar"].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = "\xAA\xBB\xCC"
    store["foo/bar"].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    store.fetch("foo/bar", "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_pathkey_binaryvalue ####################

shared_examples_for 'returndifferent_pathkey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store["foo/bar"] = value
    store["foo/bar"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["foo/bar"] = value
    store["foo/bar"].should_not be_equal(value)
  end
end

#################### returnsame_pathkey_binaryvalue ####################

shared_examples_for 'returnsame_pathkey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store["foo/bar"] = value
    store["foo/bar"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["foo/bar"] = value
    store["foo/bar"].should be_equal(value)
  end
end

#################### persist_pathkey_binaryvalue ####################

shared_examples_for 'persist_pathkey_binaryvalue' do
  it 'persists values' do
    store["bar/foo/baz"] = "ber"
    store.close
    @store = nil
    store["bar/foo/baz"].should == "ber"
  end

  it 'persists values' do
    store["foo/bar"] = "ber"
    store.close
    @store = nil
    store["foo/bar"].should == "ber"
  end

  it 'persists values' do
    store["bar/foo/baz"] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store["bar/foo/baz"].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store["foo/bar"] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store["foo/bar"].should == "\xAA\xBB\xCC"
  end
end

#################### null_pathkey_hashvalue ####################

shared_examples_for 'null_pathkey_hashvalue' do
  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_pathkey_hashvalue ####################

shared_examples_for 'store_pathkey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"].should == {"hashval1"=>["array1", 1]}
    store.load("bar/foo/baz").should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == {"hashval1"=>["array1", 1]}
    store.load("bar/foo/baz").should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"].should == {"hashval1"=>["array1", 1]}
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store.delete("bar/foo/baz").should == {"hashval1"=>["array1", 1]}
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"].should == {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store.fetch("bar/foo/baz", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store["foo/bar"].should == {"hashval1"=>["array1", 1]}
    store.load("foo/bar").should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == {"hashval1"=>["array1", 1]}
    store.load("foo/bar").should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store["foo/bar"].should == {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store.delete("foo/bar").should == {"hashval1"=>["array1", 1]}
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store["foo/bar"].should == {"hashval1"=>["array1", 1]}
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store["foo/bar"].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store.fetch("foo/bar", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("bar/foo/baz").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("bar/foo/baz").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete("bar/foo/baz").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch("bar/foo/baz", {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("foo/bar").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("foo/bar").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete("foo/bar").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store["foo/bar"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch("foo/bar", {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_pathkey_hashvalue ####################

shared_examples_for 'returndifferent_pathkey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["foo/bar"] = value
    store["foo/bar"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"] = value
    store["foo/bar"].should_not be_equal(value)
  end
end

#################### returnsame_pathkey_hashvalue ####################

shared_examples_for 'returnsame_pathkey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["foo/bar"] = value
    store["foo/bar"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["foo/bar"] = value
    store["foo/bar"].should be_equal(value)
  end
end

#################### persist_pathkey_hashvalue ####################

shared_examples_for 'persist_pathkey_hashvalue' do
  it 'persists values' do
    store["bar/foo/baz"] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store["bar/foo/baz"].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store["foo/bar"] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store["foo/bar"].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store["bar/foo/baz"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store["bar/foo/baz"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store["foo/bar"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store["foo/bar"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_pathkey_objectvalue ####################

shared_examples_for 'null_pathkey_objectvalue' do
  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = Value.new(:objval1)
    store["foo/bar"] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = Value.new(:objval1)
    store["bar/foo/baz"] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store["bar/foo/baz"].should be_nil
    store.load("bar/foo/baz").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store["bar/foo/baz"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("bar/foo/baz").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("bar/foo/baz").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["bar/foo/baz"] = Value.new(:objval2)
    store["foo/bar"] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?("bar/foo/baz").should be_false
    store.key?("foo/bar").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("bar/foo/baz", Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "bar/foo/baz"
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("bar/foo/baz", options).should be_false
    store.load("bar/foo/baz", options).should be_nil
    store.fetch("bar/foo/baz", 42, options).should == 42
    store.fetch("bar/foo/baz", options) { 42 }.should == 42
    store.delete("bar/foo/baz", options).should be_nil
    store.clear(options).should equal(store)
    store.store("bar/foo/baz", Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store["foo/bar"].should be_nil
    store.load("foo/bar").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store["foo/bar"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("foo/bar").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("foo/bar").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["foo/bar"] = Value.new(:objval2)
    store["bar/foo/baz"] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?("foo/bar").should be_false
    store.key?("bar/foo/baz").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("foo/bar", Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "foo/bar"
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("foo/bar", options).should be_false
    store.load("foo/bar", options).should be_nil
    store.fetch("foo/bar", 42, options).should == 42
    store.fetch("foo/bar", options) { 42 }.should == 42
    store.delete("foo/bar", options).should be_nil
    store.clear(options).should equal(store)
    store.store("foo/bar", Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_pathkey_objectvalue ####################

shared_examples_for 'store_pathkey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = Value.new(:objval1)
    store["bar/foo/baz"].should == Value.new(:objval1)
    store.load("bar/foo/baz").should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = Value.new(:objval1)
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == Value.new(:objval1)
    store.load("bar/foo/baz").should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = Value.new(:objval1)
    store["foo/bar"] = Value.new(:objval2)
    store.clear.should equal(store)
    store["bar/foo/baz"] = Value.new(:objval1)
    store["bar/foo/baz"].should == Value.new(:objval1)
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = Value.new(:objval1)
    store.delete("bar/foo/baz").should == Value.new(:objval1)
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = Value.new(:objval1)
    store["bar/foo/baz"].should == Value.new(:objval1)
    store["bar/foo/baz"] = Value.new(:objval2)
    store["bar/foo/baz"].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = Value.new(:objval1)
    store["bar/foo/baz"].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = Value.new(:objval1)
    store.fetch("bar/foo/baz", Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = Value.new(:objval1)
    store["foo/bar"].should == Value.new(:objval1)
    store.load("foo/bar").should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = Value.new(:objval1)
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == Value.new(:objval1)
    store.load("foo/bar").should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store["foo/bar"] = Value.new(:objval1)
    store["bar/foo/baz"] = Value.new(:objval2)
    store.clear.should equal(store)
    store["foo/bar"] = Value.new(:objval1)
    store["foo/bar"].should == Value.new(:objval1)
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = Value.new(:objval1)
    store.delete("foo/bar").should == Value.new(:objval1)
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = Value.new(:objval1)
    store["foo/bar"].should == Value.new(:objval1)
    store["foo/bar"] = Value.new(:objval2)
    store["foo/bar"].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = Value.new(:objval1)
    store["foo/bar"].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = Value.new(:objval1)
    store.fetch("foo/bar", Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["bar/foo/baz"] = Value.new(:objval2)
    store["bar/foo/baz"].should == Value.new(:objval2)
    store.load("bar/foo/baz").should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store["bar/foo/baz"] = Value.new(:objval2)
    store.key?("bar/foo/baz").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store("bar/foo/baz", value).should equal(value)
    store["bar/foo/baz"].should == Value.new(:objval2)
    store.load("bar/foo/baz").should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store["bar/foo/baz"] = Value.new(:objval2)
    store["foo/bar"] = Value.new(:objval1)
    store.clear.should equal(store)
    store["bar/foo/baz"] = Value.new(:objval2)
    store["bar/foo/baz"].should == Value.new(:objval2)
    store["foo/bar"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["bar/foo/baz"] = Value.new(:objval2)
    store.delete("bar/foo/baz").should == Value.new(:objval2)
    store.key?("bar/foo/baz").should be_false
  end

  it 'overwrites existing values' do
    store["bar/foo/baz"] = Value.new(:objval2)
    store["bar/foo/baz"].should == Value.new(:objval2)
    store["bar/foo/baz"] = Value.new(:objval1)
    store["bar/foo/baz"].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store["bar/foo/baz"] = value).should equal(value)
    store["bar/foo/baz"].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = "bar/foo/baz".freeze
    store[key] = Value.new(:objval2)
    store["bar/foo/baz"].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["bar/foo/baz"] = Value.new(:objval2)
    store.fetch("bar/foo/baz", Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store["bar/foo/baz"] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch("bar/foo/baz") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["foo/bar"] = Value.new(:objval2)
    store["foo/bar"].should == Value.new(:objval2)
    store.load("foo/bar").should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store["foo/bar"] = Value.new(:objval2)
    store.key?("foo/bar").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store("foo/bar", value).should equal(value)
    store["foo/bar"].should == Value.new(:objval2)
    store.load("foo/bar").should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store["foo/bar"] = Value.new(:objval2)
    store["bar/foo/baz"] = Value.new(:objval1)
    store.clear.should equal(store)
    store["foo/bar"] = Value.new(:objval2)
    store["foo/bar"].should == Value.new(:objval2)
    store["bar/foo/baz"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["foo/bar"] = Value.new(:objval2)
    store.delete("foo/bar").should == Value.new(:objval2)
    store.key?("foo/bar").should be_false
  end

  it 'overwrites existing values' do
    store["foo/bar"] = Value.new(:objval2)
    store["foo/bar"].should == Value.new(:objval2)
    store["foo/bar"] = Value.new(:objval1)
    store["foo/bar"].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store["foo/bar"] = value).should equal(value)
    store["foo/bar"].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = "foo/bar".freeze
    store[key] = Value.new(:objval2)
    store["foo/bar"].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["foo/bar"] = Value.new(:objval2)
    store.fetch("foo/bar", Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store["foo/bar"] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch("foo/bar") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_pathkey_objectvalue ####################

shared_examples_for 'returndifferent_pathkey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store["foo/bar"] = value
    store["foo/bar"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store["foo/bar"] = value
    store["foo/bar"].should_not be_equal(value)
  end
end

#################### returnsame_pathkey_objectvalue ####################

shared_examples_for 'returnsame_pathkey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store["foo/bar"] = value
    store["foo/bar"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store["bar/foo/baz"] = value
    store["bar/foo/baz"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store["foo/bar"] = value
    store["foo/bar"].should be_equal(value)
  end
end

#################### persist_pathkey_objectvalue ####################

shared_examples_for 'persist_pathkey_objectvalue' do
  it 'persists values' do
    store["bar/foo/baz"] = Value.new(:objval1)
    store.close
    @store = nil
    store["bar/foo/baz"].should == Value.new(:objval1)
  end

  it 'persists values' do
    store["foo/bar"] = Value.new(:objval1)
    store.close
    @store = nil
    store["foo/bar"].should == Value.new(:objval1)
  end

  it 'persists values' do
    store["bar/foo/baz"] = Value.new(:objval2)
    store.close
    @store = nil
    store["bar/foo/baz"].should == Value.new(:objval2)
  end

  it 'persists values' do
    store["foo/bar"] = Value.new(:objval2)
    store.close
    @store = nil
    store["foo/bar"].should == Value.new(:objval2)
  end
end

#################### null_binarykey_nilvalue ####################

shared_examples_for 'null_binarykey_nilvalue' do
  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = ''
    store["\xAA\xBB\xCC"] = nil
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = ''
    store["ber"] = nil
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = nil
    store["\xAA\xBB\xCC"] = ''
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = nil
    store["ber"] = ''
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = 0
    store["\xAA\xBB\xCC"] = false
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = 0
    store["ber"] = false
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = false
    store["\xAA\xBB\xCC"] = 0
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = false
    store["ber"] = 0
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", false, options).should == false
  end
end

#################### store_binarykey_nilvalue ####################

shared_examples_for 'store_binarykey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store["ber"] = ''
    store["ber"].should == ''
    store.load("ber").should == ''
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = ''
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store("ber", value).should equal(value)
    store["ber"].should == ''
    store.load("ber").should == ''
  end

  it 'stores values after clear' do
    store["ber"] = ''
    store["\xAA\xBB\xCC"] = nil
    store.clear.should equal(store)
    store["ber"] = ''
    store["ber"].should == ''
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = ''
    store.delete("ber").should == ''
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = ''
    store["ber"].should == ''
    store["ber"] = nil
    store["ber"].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == ''
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = ''
    store["ber"].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = ''
    store["\xAA\xBB\xCC"].should == ''
    store.load("\xAA\xBB\xCC").should == ''
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = ''
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == ''
    store.load("\xAA\xBB\xCC").should == ''
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = ''
    store["ber"] = nil
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = ''
    store["\xAA\xBB\xCC"].should == ''
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = ''
    store.delete("\xAA\xBB\xCC").should == ''
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = ''
    store["\xAA\xBB\xCC"].should == ''
    store["\xAA\xBB\xCC"] = nil
    store["\xAA\xBB\xCC"].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == ''
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = ''
    store["\xAA\xBB\xCC"].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = nil
    store["ber"].should == nil
    store.load("ber").should == nil
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = nil
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store("ber", value).should equal(value)
    store["ber"].should == nil
    store.load("ber").should == nil
  end

  it 'stores values after clear' do
    store["ber"] = nil
    store["\xAA\xBB\xCC"] = ''
    store.clear.should equal(store)
    store["ber"] = nil
    store["ber"].should == nil
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = nil
    store.delete("ber").should == nil
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = nil
    store["ber"].should == nil
    store["ber"] = ''
    store["ber"].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == nil
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = nil
    store["ber"].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = nil
    store["\xAA\xBB\xCC"].should == nil
    store.load("\xAA\xBB\xCC").should == nil
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = nil
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == nil
    store.load("\xAA\xBB\xCC").should == nil
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = nil
    store["ber"] = ''
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = nil
    store["\xAA\xBB\xCC"].should == nil
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = nil
    store.delete("\xAA\xBB\xCC").should == nil
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = nil
    store["\xAA\xBB\xCC"].should == nil
    store["\xAA\xBB\xCC"] = ''
    store["\xAA\xBB\xCC"].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == nil
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = nil
    store["\xAA\xBB\xCC"].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = 0
    store["ber"].should == 0
    store.load("ber").should == 0
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = 0
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store("ber", value).should equal(value)
    store["ber"].should == 0
    store.load("ber").should == 0
  end

  it 'stores values after clear' do
    store["ber"] = 0
    store["\xAA\xBB\xCC"] = false
    store.clear.should equal(store)
    store["ber"] = 0
    store["ber"].should == 0
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = 0
    store.delete("ber").should == 0
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = 0
    store["ber"].should == 0
    store["ber"] = false
    store["ber"].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == 0
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = 0
    store["ber"].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = 0
    store["\xAA\xBB\xCC"].should == 0
    store.load("\xAA\xBB\xCC").should == 0
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = 0
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == 0
    store.load("\xAA\xBB\xCC").should == 0
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = 0
    store["ber"] = false
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = 0
    store["\xAA\xBB\xCC"].should == 0
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = 0
    store.delete("\xAA\xBB\xCC").should == 0
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = 0
    store["\xAA\xBB\xCC"].should == 0
    store["\xAA\xBB\xCC"] = false
    store["\xAA\xBB\xCC"].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == 0
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = 0
    store["\xAA\xBB\xCC"].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = false
    store["ber"].should == false
    store.load("ber").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = false
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("ber", value).should equal(value)
    store["ber"].should == false
    store.load("ber").should == false
  end

  it 'stores values after clear' do
    store["ber"] = false
    store["\xAA\xBB\xCC"] = 0
    store.clear.should equal(store)
    store["ber"] = false
    store["ber"].should == false
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = false
    store.delete("ber").should == false
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = false
    store["ber"].should == false
    store["ber"] = 0
    store["ber"].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == false
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = false
    store["ber"].should == false
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = false
    store["\xAA\xBB\xCC"].should == false
    store.load("\xAA\xBB\xCC").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = false
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == false
    store.load("\xAA\xBB\xCC").should == false
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = false
    store["ber"] = 0
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = false
    store["\xAA\xBB\xCC"].should == false
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = false
    store.delete("\xAA\xBB\xCC").should == false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = false
    store["\xAA\xBB\xCC"].should == false
    store["\xAA\xBB\xCC"] = 0
    store["\xAA\xBB\xCC"].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == false
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = false
    store["\xAA\xBB\xCC"].should == false
  end
end

#################### persist_binarykey_nilvalue ####################

shared_examples_for 'persist_binarykey_nilvalue' do
  it 'persists values' do
    store["ber"] = ''
    store.close
    @store = nil
    store["ber"].should == ''
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = ''
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == ''
  end

  it 'persists values' do
    store["ber"] = nil
    store.close
    @store = nil
    store["ber"].should == nil
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = nil
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == nil
  end

  it 'persists values' do
    store["ber"] = 0
    store.close
    @store = nil
    store["ber"].should == 0
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = 0
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == 0
  end

  it 'persists values' do
    store["ber"] = false
    store.close
    @store = nil
    store["ber"].should == false
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = false
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == false
  end
end

#################### null_binarykey_integervalue ####################

shared_examples_for 'null_binarykey_integervalue' do
  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = 41
    store["\xAA\xBB\xCC"] = -12
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = 41
    store["ber"] = -12
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = -12
    store["\xAA\xBB\xCC"] = 41
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = -12
    store["ber"] = 41
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", -12, options).should == -12
  end
end

#################### store_binarykey_integervalue ####################

shared_examples_for 'store_binarykey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store["ber"] = 41
    store["ber"].should == 41
    store.load("ber").should == 41
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = 41
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store("ber", value).should equal(value)
    store["ber"].should == 41
    store.load("ber").should == 41
  end

  it 'stores values after clear' do
    store["ber"] = 41
    store["\xAA\xBB\xCC"] = -12
    store.clear.should equal(store)
    store["ber"] = 41
    store["ber"].should == 41
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = 41
    store.delete("ber").should == 41
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = 41
    store["ber"].should == 41
    store["ber"] = -12
    store["ber"].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == 41
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = 41
    store["ber"].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = 41
    store.fetch("ber", -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = 41
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = 41
    store["\xAA\xBB\xCC"].should == 41
    store.load("\xAA\xBB\xCC").should == 41
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = 41
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == 41
    store.load("\xAA\xBB\xCC").should == 41
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = 41
    store["ber"] = -12
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = 41
    store["\xAA\xBB\xCC"].should == 41
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = 41
    store.delete("\xAA\xBB\xCC").should == 41
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = 41
    store["\xAA\xBB\xCC"].should == 41
    store["\xAA\xBB\xCC"] = -12
    store["\xAA\xBB\xCC"].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == 41
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = 41
    store["\xAA\xBB\xCC"].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = 41
    store.fetch("\xAA\xBB\xCC", -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = 41
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = -12
    store["ber"].should == -12
    store.load("ber").should == -12
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = -12
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store("ber", value).should equal(value)
    store["ber"].should == -12
    store.load("ber").should == -12
  end

  it 'stores values after clear' do
    store["ber"] = -12
    store["\xAA\xBB\xCC"] = 41
    store.clear.should equal(store)
    store["ber"] = -12
    store["ber"].should == -12
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = -12
    store.delete("ber").should == -12
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = -12
    store["ber"].should == -12
    store["ber"] = 41
    store["ber"].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == -12
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = -12
    store["ber"].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = -12
    store.fetch("ber", 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = -12
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = -12
    store["\xAA\xBB\xCC"].should == -12
    store.load("\xAA\xBB\xCC").should == -12
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = -12
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == -12
    store.load("\xAA\xBB\xCC").should == -12
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = -12
    store["ber"] = 41
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = -12
    store["\xAA\xBB\xCC"].should == -12
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = -12
    store.delete("\xAA\xBB\xCC").should == -12
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = -12
    store["\xAA\xBB\xCC"].should == -12
    store["\xAA\xBB\xCC"] = 41
    store["\xAA\xBB\xCC"].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == -12
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = -12
    store["\xAA\xBB\xCC"].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = -12
    store.fetch("\xAA\xBB\xCC", 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = -12
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_binarykey_integervalue ####################

shared_examples_for 'persist_binarykey_integervalue' do
  it 'persists values' do
    store["ber"] = 41
    store.close
    @store = nil
    store["ber"].should == 41
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = 41
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == 41
  end

  it 'persists values' do
    store["ber"] = -12
    store.close
    @store = nil
    store["ber"].should == -12
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = -12
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == -12
  end
end

#################### null_binarykey_numbervalue ####################

shared_examples_for 'null_binarykey_numbervalue' do
  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = 123.456
    store["\xAA\xBB\xCC"] = -98.7
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = 123.456
    store["ber"] = -98.7
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = -98.7
    store["\xAA\xBB\xCC"] = 123.456
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = -98.7
    store["ber"] = 123.456
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"] = 33
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store["ber"] = 33
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = 33
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = 33
    store["ber"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", 33, options).should == 33
  end
end

#################### store_binarykey_numbervalue ####################

shared_examples_for 'store_binarykey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store["ber"] = 123.456
    store["ber"].should == 123.456
    store.load("ber").should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = 123.456
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store("ber", value).should equal(value)
    store["ber"].should == 123.456
    store.load("ber").should == 123.456
  end

  it 'stores values after clear' do
    store["ber"] = 123.456
    store["\xAA\xBB\xCC"] = -98.7
    store.clear.should equal(store)
    store["ber"] = 123.456
    store["ber"].should == 123.456
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = 123.456
    store.delete("ber").should == 123.456
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = 123.456
    store["ber"].should == 123.456
    store["ber"] = -98.7
    store["ber"].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == 123.456
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = 123.456
    store["ber"].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = 123.456
    store.fetch("ber", -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = 123.456
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = 123.456
    store["\xAA\xBB\xCC"].should == 123.456
    store.load("\xAA\xBB\xCC").should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = 123.456
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == 123.456
    store.load("\xAA\xBB\xCC").should == 123.456
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = 123.456
    store["ber"] = -98.7
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = 123.456
    store["\xAA\xBB\xCC"].should == 123.456
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = 123.456
    store.delete("\xAA\xBB\xCC").should == 123.456
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = 123.456
    store["\xAA\xBB\xCC"].should == 123.456
    store["\xAA\xBB\xCC"] = -98.7
    store["\xAA\xBB\xCC"].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == 123.456
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = 123.456
    store["\xAA\xBB\xCC"].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = 123.456
    store.fetch("\xAA\xBB\xCC", -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = 123.456
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = -98.7
    store["ber"].should == -98.7
    store.load("ber").should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = -98.7
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store("ber", value).should equal(value)
    store["ber"].should == -98.7
    store.load("ber").should == -98.7
  end

  it 'stores values after clear' do
    store["ber"] = -98.7
    store["\xAA\xBB\xCC"] = 123.456
    store.clear.should equal(store)
    store["ber"] = -98.7
    store["ber"].should == -98.7
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = -98.7
    store.delete("ber").should == -98.7
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = -98.7
    store["ber"].should == -98.7
    store["ber"] = 123.456
    store["ber"].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == -98.7
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = -98.7
    store["ber"].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = -98.7
    store.fetch("ber", 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = -98.7
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = -98.7
    store["\xAA\xBB\xCC"].should == -98.7
    store.load("\xAA\xBB\xCC").should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = -98.7
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == -98.7
    store.load("\xAA\xBB\xCC").should == -98.7
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = -98.7
    store["ber"] = 123.456
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = -98.7
    store["\xAA\xBB\xCC"].should == -98.7
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = -98.7
    store.delete("\xAA\xBB\xCC").should == -98.7
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = -98.7
    store["\xAA\xBB\xCC"].should == -98.7
    store["\xAA\xBB\xCC"] = 123.456
    store["\xAA\xBB\xCC"].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == -98.7
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = -98.7
    store["\xAA\xBB\xCC"].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = -98.7
    store.fetch("\xAA\xBB\xCC", 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = -98.7
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = 340282366920938463463374607431768211456
    store["ber"].should == 340282366920938463463374607431768211456
    store.load("ber").should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = 340282366920938463463374607431768211456
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store("ber", value).should equal(value)
    store["ber"].should == 340282366920938463463374607431768211456
    store.load("ber").should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store["ber"] = 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"] = 33
    store.clear.should equal(store)
    store["ber"] = 340282366920938463463374607431768211456
    store["ber"].should == 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = 340282366920938463463374607431768211456
    store.delete("ber").should == 340282366920938463463374607431768211456
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = 340282366920938463463374607431768211456
    store["ber"].should == 340282366920938463463374607431768211456
    store["ber"] = 33
    store["ber"].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = 340282366920938463463374607431768211456
    store["ber"].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = 340282366920938463463374607431768211456
    store.fetch("ber", 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"].should == 340282366920938463463374607431768211456
    store.load("\xAA\xBB\xCC").should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == 340282366920938463463374607431768211456
    store.load("\xAA\xBB\xCC").should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store["ber"] = 33
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"].should == 340282366920938463463374607431768211456
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store.delete("\xAA\xBB\xCC").should == 340282366920938463463374607431768211456
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"].should == 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"] = 33
    store["\xAA\xBB\xCC"].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store.fetch("\xAA\xBB\xCC", 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = 33
    store["ber"].should == 33
    store.load("ber").should == 33
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = 33
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store("ber", value).should equal(value)
    store["ber"].should == 33
    store.load("ber").should == 33
  end

  it 'stores values after clear' do
    store["ber"] = 33
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store["ber"] = 33
    store["ber"].should == 33
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = 33
    store.delete("ber").should == 33
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = 33
    store["ber"].should == 33
    store["ber"] = 340282366920938463463374607431768211456
    store["ber"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == 33
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = 33
    store["ber"].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = 33
    store.fetch("ber", 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = 33
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = 33
    store["\xAA\xBB\xCC"].should == 33
    store.load("\xAA\xBB\xCC").should == 33
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = 33
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == 33
    store.load("\xAA\xBB\xCC").should == 33
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = 33
    store["ber"] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = 33
    store["\xAA\xBB\xCC"].should == 33
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = 33
    store.delete("\xAA\xBB\xCC").should == 33
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = 33
    store["\xAA\xBB\xCC"].should == 33
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store["\xAA\xBB\xCC"].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == 33
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = 33
    store["\xAA\xBB\xCC"].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = 33
    store.fetch("\xAA\xBB\xCC", 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = 33
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_binarykey_numbervalue ####################

shared_examples_for 'persist_binarykey_numbervalue' do
  it 'persists values' do
    store["ber"] = 123.456
    store.close
    @store = nil
    store["ber"].should == 123.456
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = 123.456
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == 123.456
  end

  it 'persists values' do
    store["ber"] = -98.7
    store.close
    @store = nil
    store["ber"].should == -98.7
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = -98.7
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == -98.7
  end

  it 'persists values' do
    store["ber"] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store["ber"].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store["ber"] = 33
    store.close
    @store = nil
    store["ber"].should == 33
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = 33
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == 33
  end
end

#################### null_binarykey_booleanvalue ####################

shared_examples_for 'null_binarykey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = true
    store["\xAA\xBB\xCC"] = false
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = true
    store["ber"] = false
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = false
    store["\xAA\xBB\xCC"] = true
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = false
    store["ber"] = true
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", false, options).should == false
  end
end

#################### store_binarykey_booleanvalue ####################

shared_examples_for 'store_binarykey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store["ber"] = true
    store["ber"].should == true
    store.load("ber").should == true
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = true
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store("ber", value).should equal(value)
    store["ber"].should == true
    store.load("ber").should == true
  end

  it 'stores values after clear' do
    store["ber"] = true
    store["\xAA\xBB\xCC"] = false
    store.clear.should equal(store)
    store["ber"] = true
    store["ber"].should == true
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = true
    store.delete("ber").should == true
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = true
    store["ber"].should == true
    store["ber"] = false
    store["ber"].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == true
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = true
    store["ber"].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = true
    store.fetch("ber", false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = true
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = true
    store["\xAA\xBB\xCC"].should == true
    store.load("\xAA\xBB\xCC").should == true
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = true
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == true
    store.load("\xAA\xBB\xCC").should == true
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = true
    store["ber"] = false
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = true
    store["\xAA\xBB\xCC"].should == true
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = true
    store.delete("\xAA\xBB\xCC").should == true
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = true
    store["\xAA\xBB\xCC"].should == true
    store["\xAA\xBB\xCC"] = false
    store["\xAA\xBB\xCC"].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == true
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = true
    store["\xAA\xBB\xCC"].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = true
    store.fetch("\xAA\xBB\xCC", false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = true
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = false
    store["ber"].should == false
    store.load("ber").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = false
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("ber", value).should equal(value)
    store["ber"].should == false
    store.load("ber").should == false
  end

  it 'stores values after clear' do
    store["ber"] = false
    store["\xAA\xBB\xCC"] = true
    store.clear.should equal(store)
    store["ber"] = false
    store["ber"].should == false
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = false
    store.delete("ber").should == false
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = false
    store["ber"].should == false
    store["ber"] = true
    store["ber"].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == false
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = false
    store["ber"].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = false
    store.fetch("ber", true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = false
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = false
    store["\xAA\xBB\xCC"].should == false
    store.load("\xAA\xBB\xCC").should == false
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = false
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == false
    store.load("\xAA\xBB\xCC").should == false
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = false
    store["ber"] = true
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = false
    store["\xAA\xBB\xCC"].should == false
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = false
    store.delete("\xAA\xBB\xCC").should == false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = false
    store["\xAA\xBB\xCC"].should == false
    store["\xAA\xBB\xCC"] = true
    store["\xAA\xBB\xCC"].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == false
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = false
    store["\xAA\xBB\xCC"].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = false
    store.fetch("\xAA\xBB\xCC", true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = false
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_binarykey_booleanvalue ####################

shared_examples_for 'persist_binarykey_booleanvalue' do
  it 'persists values' do
    store["ber"] = true
    store.close
    @store = nil
    store["ber"].should == true
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = true
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == true
  end

  it 'persists values' do
    store["ber"] = false
    store.close
    @store = nil
    store["ber"].should == false
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = false
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == false
  end
end

#################### null_binarykey_stringvalue ####################

shared_examples_for 'null_binarykey_stringvalue' do
  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = "strval1"
    store["\xAA\xBB\xCC"] = "strval2"
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = "strval1"
    store["ber"] = "strval2"
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = "strval2"
    store["\xAA\xBB\xCC"] = "strval1"
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = "strval2"
    store["ber"] = "strval1"
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", "strval2", options).should == "strval2"
  end
end

#################### store_binarykey_stringvalue ####################

shared_examples_for 'store_binarykey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store["ber"] = "strval1"
    store["ber"].should == "strval1"
    store.load("ber").should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = "strval1"
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store("ber", value).should equal(value)
    store["ber"].should == "strval1"
    store.load("ber").should == "strval1"
  end

  it 'stores values after clear' do
    store["ber"] = "strval1"
    store["\xAA\xBB\xCC"] = "strval2"
    store.clear.should equal(store)
    store["ber"] = "strval1"
    store["ber"].should == "strval1"
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = "strval1"
    store.delete("ber").should == "strval1"
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = "strval1"
    store["ber"].should == "strval1"
    store["ber"] = "strval2"
    store["ber"].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == "strval1"
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = "strval1"
    store["ber"].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = "strval1"
    store.fetch("ber", "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = "strval1"
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = "strval1"
    store["\xAA\xBB\xCC"].should == "strval1"
    store.load("\xAA\xBB\xCC").should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = "strval1"
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == "strval1"
    store.load("\xAA\xBB\xCC").should == "strval1"
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = "strval1"
    store["ber"] = "strval2"
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = "strval1"
    store["\xAA\xBB\xCC"].should == "strval1"
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = "strval1"
    store.delete("\xAA\xBB\xCC").should == "strval1"
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = "strval1"
    store["\xAA\xBB\xCC"].should == "strval1"
    store["\xAA\xBB\xCC"] = "strval2"
    store["\xAA\xBB\xCC"].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == "strval1"
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = "strval1"
    store["\xAA\xBB\xCC"].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = "strval1"
    store.fetch("\xAA\xBB\xCC", "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = "strval1"
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = "strval2"
    store["ber"].should == "strval2"
    store.load("ber").should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = "strval2"
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store("ber", value).should equal(value)
    store["ber"].should == "strval2"
    store.load("ber").should == "strval2"
  end

  it 'stores values after clear' do
    store["ber"] = "strval2"
    store["\xAA\xBB\xCC"] = "strval1"
    store.clear.should equal(store)
    store["ber"] = "strval2"
    store["ber"].should == "strval2"
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = "strval2"
    store.delete("ber").should == "strval2"
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = "strval2"
    store["ber"].should == "strval2"
    store["ber"] = "strval1"
    store["ber"].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == "strval2"
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = "strval2"
    store["ber"].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = "strval2"
    store.fetch("ber", "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = "strval2"
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = "strval2"
    store["\xAA\xBB\xCC"].should == "strval2"
    store.load("\xAA\xBB\xCC").should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = "strval2"
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == "strval2"
    store.load("\xAA\xBB\xCC").should == "strval2"
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = "strval2"
    store["ber"] = "strval1"
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = "strval2"
    store["\xAA\xBB\xCC"].should == "strval2"
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = "strval2"
    store.delete("\xAA\xBB\xCC").should == "strval2"
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = "strval2"
    store["\xAA\xBB\xCC"].should == "strval2"
    store["\xAA\xBB\xCC"] = "strval1"
    store["\xAA\xBB\xCC"].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == "strval2"
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = "strval2"
    store["\xAA\xBB\xCC"].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = "strval2"
    store.fetch("\xAA\xBB\xCC", "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = "strval2"
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_binarykey_stringvalue ####################

shared_examples_for 'returndifferent_binarykey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store["ber"] = value
    store["ber"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store["ber"] = value
    store["ber"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should_not be_equal(value)
  end
end

#################### returnsame_binarykey_stringvalue ####################

shared_examples_for 'returnsame_binarykey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store["ber"] = value
    store["ber"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store["ber"] = value
    store["ber"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should be_equal(value)
  end
end

#################### persist_binarykey_stringvalue ####################

shared_examples_for 'persist_binarykey_stringvalue' do
  it 'persists values' do
    store["ber"] = "strval1"
    store.close
    @store = nil
    store["ber"].should == "strval1"
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = "strval1"
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == "strval1"
  end

  it 'persists values' do
    store["ber"] = "strval2"
    store.close
    @store = nil
    store["ber"].should == "strval2"
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = "strval2"
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == "strval2"
  end
end

#################### null_binarykey_binaryvalue ####################

shared_examples_for 'null_binarykey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = "ber"
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = "ber"
    store["ber"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"] = "ber"
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store["ber"] = "ber"
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_binarykey_binaryvalue ####################

shared_examples_for 'store_binarykey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store["ber"] = "ber"
    store["ber"].should == "ber"
    store.load("ber").should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = "ber"
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store("ber", value).should equal(value)
    store["ber"].should == "ber"
    store.load("ber").should == "ber"
  end

  it 'stores values after clear' do
    store["ber"] = "ber"
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store["ber"] = "ber"
    store["ber"].should == "ber"
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = "ber"
    store.delete("ber").should == "ber"
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = "ber"
    store["ber"].should == "ber"
    store["ber"] = "\xAA\xBB\xCC"
    store["ber"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == "ber"
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = "ber"
    store["ber"].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = "ber"
    store.fetch("ber", "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = "ber"
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = "ber"
    store["\xAA\xBB\xCC"].should == "ber"
    store.load("\xAA\xBB\xCC").should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = "ber"
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == "ber"
    store.load("\xAA\xBB\xCC").should == "ber"
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = "ber"
    store["ber"] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = "ber"
    store["\xAA\xBB\xCC"].should == "ber"
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = "ber"
    store.delete("\xAA\xBB\xCC").should == "ber"
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = "ber"
    store["\xAA\xBB\xCC"].should == "ber"
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == "ber"
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = "ber"
    store["\xAA\xBB\xCC"].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = "ber"
    store.fetch("\xAA\xBB\xCC", "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = "ber"
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = "\xAA\xBB\xCC"
    store["ber"].should == "\xAA\xBB\xCC"
    store.load("ber").should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = "\xAA\xBB\xCC"
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store("ber", value).should equal(value)
    store["ber"].should == "\xAA\xBB\xCC"
    store.load("ber").should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store["ber"] = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"] = "ber"
    store.clear.should equal(store)
    store["ber"] = "\xAA\xBB\xCC"
    store["ber"].should == "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = "\xAA\xBB\xCC"
    store.delete("ber").should == "\xAA\xBB\xCC"
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = "\xAA\xBB\xCC"
    store["ber"].should == "\xAA\xBB\xCC"
    store["ber"] = "ber"
    store["ber"].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = "\xAA\xBB\xCC"
    store["ber"].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = "\xAA\xBB\xCC"
    store.fetch("ber", "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"].should == "\xAA\xBB\xCC"
    store.load("\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == "\xAA\xBB\xCC"
    store.load("\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store["ber"] = "ber"
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"].should == "\xAA\xBB\xCC"
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store.delete("\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"].should == "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"] = "ber"
    store["\xAA\xBB\xCC"].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store.fetch("\xAA\xBB\xCC", "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_binarykey_binaryvalue ####################

shared_examples_for 'returndifferent_binarykey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store["ber"] = value
    store["ber"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["ber"] = value
    store["ber"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should_not be_equal(value)
  end
end

#################### returnsame_binarykey_binaryvalue ####################

shared_examples_for 'returnsame_binarykey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store["ber"] = value
    store["ber"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["ber"] = value
    store["ber"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should be_equal(value)
  end
end

#################### persist_binarykey_binaryvalue ####################

shared_examples_for 'persist_binarykey_binaryvalue' do
  it 'persists values' do
    store["ber"] = "ber"
    store.close
    @store = nil
    store["ber"].should == "ber"
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = "ber"
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == "ber"
  end

  it 'persists values' do
    store["ber"] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store["ber"].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == "\xAA\xBB\xCC"
  end
end

#################### null_binarykey_hashvalue ####################

shared_examples_for 'null_binarykey_hashvalue' do
  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_binarykey_hashvalue ####################

shared_examples_for 'store_binarykey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    store["ber"].should == {"hashval1"=>["array1", 1]}
    store.load("ber").should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store("ber", value).should equal(value)
    store["ber"].should == {"hashval1"=>["array1", 1]}
    store.load("ber").should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store["ber"] = {"hashval1"=>["array1", 1]}
    store["ber"].should == {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    store.delete("ber").should == {"hashval1"=>["array1", 1]}
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    store["ber"].should == {"hashval1"=>["array1", 1]}
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store["ber"].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    store.fetch("ber", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"].should == {"hashval1"=>["array1", 1]}
    store.load("\xAA\xBB\xCC").should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == {"hashval1"=>["array1", 1]}
    store.load("\xAA\xBB\xCC").should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"].should == {"hashval1"=>["array1", 1]}
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store.delete("\xAA\xBB\xCC").should == {"hashval1"=>["array1", 1]}
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"].should == {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store.fetch("\xAA\xBB\xCC", {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("ber").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store("ber", value).should equal(value)
    store["ber"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("ber").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete("ber").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"] = {"hashval1"=>["array1", 1]}
    store["ber"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch("ber", {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("\xAA\xBB\xCC").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load("\xAA\xBB\xCC").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete("\xAA\xBB\xCC").should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch("\xAA\xBB\xCC", {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_binarykey_hashvalue ####################

shared_examples_for 'returndifferent_binarykey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["ber"] = value
    store["ber"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"] = value
    store["ber"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should_not be_equal(value)
  end
end

#################### returnsame_binarykey_hashvalue ####################

shared_examples_for 'returnsame_binarykey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["ber"] = value
    store["ber"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["ber"] = value
    store["ber"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should be_equal(value)
  end
end

#################### persist_binarykey_hashvalue ####################

shared_examples_for 'persist_binarykey_hashvalue' do
  it 'persists values' do
    store["ber"] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store["ber"].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store["ber"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store["ber"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_binarykey_objectvalue ####################

shared_examples_for 'null_binarykey_objectvalue' do
  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = Value.new(:objval1)
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store["ber"] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store["ber"].should be_nil
    store.load("ber").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store["ber"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("ber").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("ber").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["ber"] = Value.new(:objval2)
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?("ber").should be_false
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("ber", Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "ber"
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("ber", options).should be_false
    store.load("ber", options).should be_nil
    store.fetch("ber", 42, options).should == 42
    store.fetch("ber", options) { 42 }.should == 42
    store.delete("ber", options).should be_nil
    store.clear(options).should equal(store)
    store.store("ber", Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store["\xAA\xBB\xCC"].should be_nil
    store.load("\xAA\xBB\xCC").should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store["\xAA\xBB\xCC"] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete("\xAA\xBB\xCC").should be_nil
  end

  it 'removes all keys from the store with clear' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store["ber"] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?("\xAA\xBB\xCC").should be_false
    store.key?("ber").should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch("\xAA\xBB\xCC", Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = "\xAA\xBB\xCC"
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?("\xAA\xBB\xCC", options).should be_false
    store.load("\xAA\xBB\xCC", options).should be_nil
    store.fetch("\xAA\xBB\xCC", 42, options).should == 42
    store.fetch("\xAA\xBB\xCC", options) { 42 }.should == 42
    store.delete("\xAA\xBB\xCC", options).should be_nil
    store.clear(options).should equal(store)
    store.store("\xAA\xBB\xCC", Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_binarykey_objectvalue ####################

shared_examples_for 'store_binarykey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store["ber"] = Value.new(:objval1)
    store["ber"].should == Value.new(:objval1)
    store.load("ber").should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = Value.new(:objval1)
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store("ber", value).should equal(value)
    store["ber"].should == Value.new(:objval1)
    store.load("ber").should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store["ber"] = Value.new(:objval1)
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store.clear.should equal(store)
    store["ber"] = Value.new(:objval1)
    store["ber"].should == Value.new(:objval1)
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = Value.new(:objval1)
    store.delete("ber").should == Value.new(:objval1)
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = Value.new(:objval1)
    store["ber"].should == Value.new(:objval1)
    store["ber"] = Value.new(:objval2)
    store["ber"].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = Value.new(:objval1)
    store["ber"].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = Value.new(:objval1)
    store.fetch("ber", Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store["\xAA\xBB\xCC"].should == Value.new(:objval1)
    store.load("\xAA\xBB\xCC").should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == Value.new(:objval1)
    store.load("\xAA\xBB\xCC").should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store["ber"] = Value.new(:objval2)
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store["\xAA\xBB\xCC"].should == Value.new(:objval1)
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store.delete("\xAA\xBB\xCC").should == Value.new(:objval1)
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store["\xAA\xBB\xCC"].should == Value.new(:objval1)
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store["\xAA\xBB\xCC"].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = Value.new(:objval1)
    store["\xAA\xBB\xCC"].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store.fetch("\xAA\xBB\xCC", Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["ber"] = Value.new(:objval2)
    store["ber"].should == Value.new(:objval2)
    store.load("ber").should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store["ber"] = Value.new(:objval2)
    store.key?("ber").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store("ber", value).should equal(value)
    store["ber"].should == Value.new(:objval2)
    store.load("ber").should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store["ber"] = Value.new(:objval2)
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store.clear.should equal(store)
    store["ber"] = Value.new(:objval2)
    store["ber"].should == Value.new(:objval2)
    store["\xAA\xBB\xCC"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["ber"] = Value.new(:objval2)
    store.delete("ber").should == Value.new(:objval2)
    store.key?("ber").should be_false
  end

  it 'overwrites existing values' do
    store["ber"] = Value.new(:objval2)
    store["ber"].should == Value.new(:objval2)
    store["ber"] = Value.new(:objval1)
    store["ber"].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store["ber"] = value).should equal(value)
    store["ber"].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = "ber".freeze
    store[key] = Value.new(:objval2)
    store["ber"].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["ber"] = Value.new(:objval2)
    store.fetch("ber", Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store["ber"] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch("ber") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store["\xAA\xBB\xCC"].should == Value.new(:objval2)
    store.load("\xAA\xBB\xCC").should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store.key?("\xAA\xBB\xCC").should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store("\xAA\xBB\xCC", value).should equal(value)
    store["\xAA\xBB\xCC"].should == Value.new(:objval2)
    store.load("\xAA\xBB\xCC").should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store["ber"] = Value.new(:objval1)
    store.clear.should equal(store)
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store["\xAA\xBB\xCC"].should == Value.new(:objval2)
    store["ber"].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store.delete("\xAA\xBB\xCC").should == Value.new(:objval2)
    store.key?("\xAA\xBB\xCC").should be_false
  end

  it 'overwrites existing values' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store["\xAA\xBB\xCC"].should == Value.new(:objval2)
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store["\xAA\xBB\xCC"].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store["\xAA\xBB\xCC"] = value).should equal(value)
    store["\xAA\xBB\xCC"].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = "\xAA\xBB\xCC".freeze
    store[key] = Value.new(:objval2)
    store["\xAA\xBB\xCC"].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store.fetch("\xAA\xBB\xCC", Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch("\xAA\xBB\xCC") { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_binarykey_objectvalue ####################

shared_examples_for 'returndifferent_binarykey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store["ber"] = value
    store["ber"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store["ber"] = value
    store["ber"].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should_not be_equal(value)
  end
end

#################### returnsame_binarykey_objectvalue ####################

shared_examples_for 'returnsame_binarykey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store["ber"] = value
    store["ber"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store["ber"] = value
    store["ber"].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store["\xAA\xBB\xCC"] = value
    store["\xAA\xBB\xCC"].should be_equal(value)
  end
end

#################### persist_binarykey_objectvalue ####################

shared_examples_for 'persist_binarykey_objectvalue' do
  it 'persists values' do
    store["ber"] = Value.new(:objval1)
    store.close
    @store = nil
    store["ber"].should == Value.new(:objval1)
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = Value.new(:objval1)
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == Value.new(:objval1)
  end

  it 'persists values' do
    store["ber"] = Value.new(:objval2)
    store.close
    @store = nil
    store["ber"].should == Value.new(:objval2)
  end

  it 'persists values' do
    store["\xAA\xBB\xCC"] = Value.new(:objval2)
    store.close
    @store = nil
    store["\xAA\xBB\xCC"].should == Value.new(:objval2)
  end
end

#################### null_objectkey_nilvalue ####################

shared_examples_for 'null_objectkey_nilvalue' do
  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = ''
    store[Value.new(:objkey2)] = nil
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = ''
    store[Value.new(:objkey1)] = nil
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = nil
    store[Value.new(:objkey2)] = ''
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = nil
    store[Value.new(:objkey1)] = ''
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey2)] = false
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = 0
    store[Value.new(:objkey1)] = false
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey2)] = 0
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey1)] = 0
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), false, options).should == false
  end
end

#################### store_objectkey_nilvalue ####################

shared_examples_for 'store_objectkey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = ''
    store[Value.new(:objkey1)].should == ''
    store.load(Value.new(:objkey1)).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = ''
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == ''
    store.load(Value.new(:objkey1)).should == ''
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = ''
    store[Value.new(:objkey2)] = nil
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = ''
    store[Value.new(:objkey1)].should == ''
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = ''
    store.delete(Value.new(:objkey1)).should == ''
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = ''
    store[Value.new(:objkey1)].should == ''
    store[Value.new(:objkey1)] = nil
    store[Value.new(:objkey1)].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == ''
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = ''
    store[Value.new(:objkey1)].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = ''
    store[Value.new(:objkey2)].should == ''
    store.load(Value.new(:objkey2)).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = ''
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == ''
    store.load(Value.new(:objkey2)).should == ''
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = ''
    store[Value.new(:objkey1)] = nil
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = ''
    store[Value.new(:objkey2)].should == ''
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = ''
    store.delete(Value.new(:objkey2)).should == ''
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = ''
    store[Value.new(:objkey2)].should == ''
    store[Value.new(:objkey2)] = nil
    store[Value.new(:objkey2)].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == ''
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = ''
    store[Value.new(:objkey2)].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = nil
    store[Value.new(:objkey1)].should == nil
    store.load(Value.new(:objkey1)).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = nil
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == nil
    store.load(Value.new(:objkey1)).should == nil
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = nil
    store[Value.new(:objkey2)] = ''
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = nil
    store[Value.new(:objkey1)].should == nil
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = nil
    store.delete(Value.new(:objkey1)).should == nil
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = nil
    store[Value.new(:objkey1)].should == nil
    store[Value.new(:objkey1)] = ''
    store[Value.new(:objkey1)].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == nil
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = nil
    store[Value.new(:objkey1)].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = nil
    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = nil
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == nil
    store.load(Value.new(:objkey2)).should == nil
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = nil
    store[Value.new(:objkey1)] = ''
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = nil
    store[Value.new(:objkey2)].should == nil
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = nil
    store.delete(Value.new(:objkey2)).should == nil
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = nil
    store[Value.new(:objkey2)].should == nil
    store[Value.new(:objkey2)] = ''
    store[Value.new(:objkey2)].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == nil
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = nil
    store[Value.new(:objkey2)].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey1)].should == 0
    store.load(Value.new(:objkey1)).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = 0
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == 0
    store.load(Value.new(:objkey1)).should == 0
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey2)] = false
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey1)].should == 0
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = 0
    store.delete(Value.new(:objkey1)).should == 0
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey1)].should == 0
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == 0
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = 0
    store[Value.new(:objkey1)].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = 0
    store[Value.new(:objkey2)].should == 0
    store.load(Value.new(:objkey2)).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = 0
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == 0
    store.load(Value.new(:objkey2)).should == 0
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = 0
    store[Value.new(:objkey1)] = false
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = 0
    store[Value.new(:objkey2)].should == 0
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = 0
    store.delete(Value.new(:objkey2)).should == 0
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = 0
    store[Value.new(:objkey2)].should == 0
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == 0
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = 0
    store[Value.new(:objkey2)].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
    store.load(Value.new(:objkey1)).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = false
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == false
    store.load(Value.new(:objkey1)).should == false
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey2)] = 0
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = false
    store.delete(Value.new(:objkey1)).should == false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
    store[Value.new(:objkey1)] = 0
    store[Value.new(:objkey1)].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == false
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = false
    store[Value.new(:objkey1)].should == false
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
    store.load(Value.new(:objkey2)).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = false
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == false
    store.load(Value.new(:objkey2)).should == false
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey1)] = 0
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = false
    store.delete(Value.new(:objkey2)).should == false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
    store[Value.new(:objkey2)] = 0
    store[Value.new(:objkey2)].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == false
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = false
    store[Value.new(:objkey2)].should == false
  end
end

#################### persist_objectkey_nilvalue ####################

shared_examples_for 'persist_objectkey_nilvalue' do
  it 'persists values' do
    store[Value.new(:objkey1)] = ''
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == ''
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = ''
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == ''
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = nil
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == nil
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = nil
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == nil
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = 0
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == 0
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = 0
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == 0
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = false
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == false
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = false
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == false
  end
end

#################### null_objectkey_integervalue ####################

shared_examples_for 'null_objectkey_integervalue' do
  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = 41
    store[Value.new(:objkey2)] = -12
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = 41
    store[Value.new(:objkey1)] = -12
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = -12
    store[Value.new(:objkey2)] = 41
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = -12
    store[Value.new(:objkey1)] = 41
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), -12, options).should == -12
  end
end

#################### store_objectkey_integervalue ####################

shared_examples_for 'store_objectkey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = 41
    store[Value.new(:objkey1)].should == 41
    store.load(Value.new(:objkey1)).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = 41
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == 41
    store.load(Value.new(:objkey1)).should == 41
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = 41
    store[Value.new(:objkey2)] = -12
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = 41
    store[Value.new(:objkey1)].should == 41
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = 41
    store.delete(Value.new(:objkey1)).should == 41
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = 41
    store[Value.new(:objkey1)].should == 41
    store[Value.new(:objkey1)] = -12
    store[Value.new(:objkey1)].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == 41
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = 41
    store[Value.new(:objkey1)].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = 41
    store.fetch(Value.new(:objkey1), -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = 41
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = 41
    store[Value.new(:objkey2)].should == 41
    store.load(Value.new(:objkey2)).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = 41
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == 41
    store.load(Value.new(:objkey2)).should == 41
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = 41
    store[Value.new(:objkey1)] = -12
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = 41
    store[Value.new(:objkey2)].should == 41
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = 41
    store.delete(Value.new(:objkey2)).should == 41
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = 41
    store[Value.new(:objkey2)].should == 41
    store[Value.new(:objkey2)] = -12
    store[Value.new(:objkey2)].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == 41
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = 41
    store[Value.new(:objkey2)].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = 41
    store.fetch(Value.new(:objkey2), -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = 41
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = -12
    store[Value.new(:objkey1)].should == -12
    store.load(Value.new(:objkey1)).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = -12
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == -12
    store.load(Value.new(:objkey1)).should == -12
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = -12
    store[Value.new(:objkey2)] = 41
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = -12
    store[Value.new(:objkey1)].should == -12
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = -12
    store.delete(Value.new(:objkey1)).should == -12
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = -12
    store[Value.new(:objkey1)].should == -12
    store[Value.new(:objkey1)] = 41
    store[Value.new(:objkey1)].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == -12
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = -12
    store[Value.new(:objkey1)].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = -12
    store.fetch(Value.new(:objkey1), 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = -12
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = -12
    store[Value.new(:objkey2)].should == -12
    store.load(Value.new(:objkey2)).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = -12
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == -12
    store.load(Value.new(:objkey2)).should == -12
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = -12
    store[Value.new(:objkey1)] = 41
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = -12
    store[Value.new(:objkey2)].should == -12
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = -12
    store.delete(Value.new(:objkey2)).should == -12
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = -12
    store[Value.new(:objkey2)].should == -12
    store[Value.new(:objkey2)] = 41
    store[Value.new(:objkey2)].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == -12
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = -12
    store[Value.new(:objkey2)].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = -12
    store.fetch(Value.new(:objkey2), 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = -12
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_objectkey_integervalue ####################

shared_examples_for 'persist_objectkey_integervalue' do
  it 'persists values' do
    store[Value.new(:objkey1)] = 41
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == 41
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = 41
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == 41
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = -12
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == -12
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = -12
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == -12
  end
end

#################### null_objectkey_numbervalue ####################

shared_examples_for 'null_objectkey_numbervalue' do
  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = 123.456
    store[Value.new(:objkey2)] = -98.7
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = 123.456
    store[Value.new(:objkey1)] = -98.7
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = -98.7
    store[Value.new(:objkey2)] = 123.456
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = -98.7
    store[Value.new(:objkey1)] = 123.456
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey2)] = 33
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey1)] = 33
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = 33
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = 33
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), 33, options).should == 33
  end
end

#################### store_objectkey_numbervalue ####################

shared_examples_for 'store_objectkey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = 123.456
    store[Value.new(:objkey1)].should == 123.456
    store.load(Value.new(:objkey1)).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = 123.456
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == 123.456
    store.load(Value.new(:objkey1)).should == 123.456
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = 123.456
    store[Value.new(:objkey2)] = -98.7
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = 123.456
    store[Value.new(:objkey1)].should == 123.456
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = 123.456
    store.delete(Value.new(:objkey1)).should == 123.456
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = 123.456
    store[Value.new(:objkey1)].should == 123.456
    store[Value.new(:objkey1)] = -98.7
    store[Value.new(:objkey1)].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == 123.456
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = 123.456
    store[Value.new(:objkey1)].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = 123.456
    store.fetch(Value.new(:objkey1), -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = 123.456
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = 123.456
    store[Value.new(:objkey2)].should == 123.456
    store.load(Value.new(:objkey2)).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = 123.456
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == 123.456
    store.load(Value.new(:objkey2)).should == 123.456
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = 123.456
    store[Value.new(:objkey1)] = -98.7
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = 123.456
    store[Value.new(:objkey2)].should == 123.456
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = 123.456
    store.delete(Value.new(:objkey2)).should == 123.456
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = 123.456
    store[Value.new(:objkey2)].should == 123.456
    store[Value.new(:objkey2)] = -98.7
    store[Value.new(:objkey2)].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == 123.456
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = 123.456
    store[Value.new(:objkey2)].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = 123.456
    store.fetch(Value.new(:objkey2), -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = 123.456
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = -98.7
    store[Value.new(:objkey1)].should == -98.7
    store.load(Value.new(:objkey1)).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = -98.7
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == -98.7
    store.load(Value.new(:objkey1)).should == -98.7
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = -98.7
    store[Value.new(:objkey2)] = 123.456
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = -98.7
    store[Value.new(:objkey1)].should == -98.7
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = -98.7
    store.delete(Value.new(:objkey1)).should == -98.7
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = -98.7
    store[Value.new(:objkey1)].should == -98.7
    store[Value.new(:objkey1)] = 123.456
    store[Value.new(:objkey1)].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == -98.7
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = -98.7
    store[Value.new(:objkey1)].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = -98.7
    store.fetch(Value.new(:objkey1), 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = -98.7
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = -98.7
    store[Value.new(:objkey2)].should == -98.7
    store.load(Value.new(:objkey2)).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = -98.7
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == -98.7
    store.load(Value.new(:objkey2)).should == -98.7
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = -98.7
    store[Value.new(:objkey1)] = 123.456
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = -98.7
    store[Value.new(:objkey2)].should == -98.7
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = -98.7
    store.delete(Value.new(:objkey2)).should == -98.7
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = -98.7
    store[Value.new(:objkey2)].should == -98.7
    store[Value.new(:objkey2)] = 123.456
    store[Value.new(:objkey2)].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == -98.7
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = -98.7
    store[Value.new(:objkey2)].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = -98.7
    store.fetch(Value.new(:objkey2), 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = -98.7
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey1)].should == 340282366920938463463374607431768211456
    store.load(Value.new(:objkey1)).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == 340282366920938463463374607431768211456
    store.load(Value.new(:objkey1)).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey2)] = 33
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey1)].should == 340282366920938463463374607431768211456
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store.delete(Value.new(:objkey1)).should == 340282366920938463463374607431768211456
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey1)].should == 340282366920938463463374607431768211456
    store[Value.new(:objkey1)] = 33
    store[Value.new(:objkey1)].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = 340282366920938463463374607431768211456
    store[Value.new(:objkey1)].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store.fetch(Value.new(:objkey1), 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey2)].should == 340282366920938463463374607431768211456
    store.load(Value.new(:objkey2)).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == 340282366920938463463374607431768211456
    store.load(Value.new(:objkey2)).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey1)] = 33
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey2)].should == 340282366920938463463374607431768211456
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store.delete(Value.new(:objkey2)).should == 340282366920938463463374607431768211456
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey2)].should == 340282366920938463463374607431768211456
    store[Value.new(:objkey2)] = 33
    store[Value.new(:objkey2)].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = 340282366920938463463374607431768211456
    store[Value.new(:objkey2)].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store.fetch(Value.new(:objkey2), 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = 33
    store[Value.new(:objkey1)].should == 33
    store.load(Value.new(:objkey1)).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = 33
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == 33
    store.load(Value.new(:objkey1)).should == 33
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = 33
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = 33
    store[Value.new(:objkey1)].should == 33
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = 33
    store.delete(Value.new(:objkey1)).should == 33
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = 33
    store[Value.new(:objkey1)].should == 33
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey1)].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == 33
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = 33
    store[Value.new(:objkey1)].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = 33
    store.fetch(Value.new(:objkey1), 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = 33
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = 33
    store[Value.new(:objkey2)].should == 33
    store.load(Value.new(:objkey2)).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = 33
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == 33
    store.load(Value.new(:objkey2)).should == 33
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = 33
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = 33
    store[Value.new(:objkey2)].should == 33
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = 33
    store.delete(Value.new(:objkey2)).should == 33
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = 33
    store[Value.new(:objkey2)].should == 33
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store[Value.new(:objkey2)].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == 33
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = 33
    store[Value.new(:objkey2)].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = 33
    store.fetch(Value.new(:objkey2), 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = 33
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_objectkey_numbervalue ####################

shared_examples_for 'persist_objectkey_numbervalue' do
  it 'persists values' do
    store[Value.new(:objkey1)] = 123.456
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == 123.456
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = 123.456
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == 123.456
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = -98.7
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == -98.7
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = -98.7
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == -98.7
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = 33
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == 33
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = 33
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == 33
  end
end

#################### null_objectkey_booleanvalue ####################

shared_examples_for 'null_objectkey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey2)] = false
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = true
    store[Value.new(:objkey1)] = false
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey2)] = true
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey1)] = true
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), false, options).should == false
  end
end

#################### store_objectkey_booleanvalue ####################

shared_examples_for 'store_objectkey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey1)].should == true
    store.load(Value.new(:objkey1)).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = true
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == true
    store.load(Value.new(:objkey1)).should == true
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey2)] = false
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey1)].should == true
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = true
    store.delete(Value.new(:objkey1)).should == true
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey1)].should == true
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == true
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = true
    store[Value.new(:objkey1)].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = true
    store.fetch(Value.new(:objkey1), false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = true
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = true
    store[Value.new(:objkey2)].should == true
    store.load(Value.new(:objkey2)).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = true
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == true
    store.load(Value.new(:objkey2)).should == true
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = true
    store[Value.new(:objkey1)] = false
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = true
    store[Value.new(:objkey2)].should == true
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = true
    store.delete(Value.new(:objkey2)).should == true
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = true
    store[Value.new(:objkey2)].should == true
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == true
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = true
    store[Value.new(:objkey2)].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = true
    store.fetch(Value.new(:objkey2), false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = true
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
    store.load(Value.new(:objkey1)).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = false
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == false
    store.load(Value.new(:objkey1)).should == false
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey2)] = true
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = false
    store.delete(Value.new(:objkey1)).should == false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = false
    store[Value.new(:objkey1)].should == false
    store[Value.new(:objkey1)] = true
    store[Value.new(:objkey1)].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == false
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = false
    store[Value.new(:objkey1)].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = false
    store.fetch(Value.new(:objkey1), true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = false
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
    store.load(Value.new(:objkey2)).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = false
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == false
    store.load(Value.new(:objkey2)).should == false
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey1)] = true
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = false
    store.delete(Value.new(:objkey2)).should == false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = false
    store[Value.new(:objkey2)].should == false
    store[Value.new(:objkey2)] = true
    store[Value.new(:objkey2)].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == false
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = false
    store[Value.new(:objkey2)].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = false
    store.fetch(Value.new(:objkey2), true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = false
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_objectkey_booleanvalue ####################

shared_examples_for 'persist_objectkey_booleanvalue' do
  it 'persists values' do
    store[Value.new(:objkey1)] = true
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == true
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = true
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == true
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = false
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == false
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = false
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == false
  end
end

#################### null_objectkey_stringvalue ####################

shared_examples_for 'null_objectkey_stringvalue' do
  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey2)] = "strval2"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = "strval1"
    store[Value.new(:objkey1)] = "strval2"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = "strval2"
    store[Value.new(:objkey2)] = "strval1"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = "strval2"
    store[Value.new(:objkey1)] = "strval1"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), "strval2", options).should == "strval2"
  end
end

#################### store_objectkey_stringvalue ####################

shared_examples_for 'store_objectkey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey1)].should == "strval1"
    store.load(Value.new(:objkey1)).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = "strval1"
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == "strval1"
    store.load(Value.new(:objkey1)).should == "strval1"
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey2)] = "strval2"
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey1)].should == "strval1"
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = "strval1"
    store.delete(Value.new(:objkey1)).should == "strval1"
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey1)].should == "strval1"
    store[Value.new(:objkey1)] = "strval2"
    store[Value.new(:objkey1)].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == "strval1"
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = "strval1"
    store[Value.new(:objkey1)].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = "strval1"
    store.fetch(Value.new(:objkey1), "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = "strval1"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = "strval1"
    store[Value.new(:objkey2)].should == "strval1"
    store.load(Value.new(:objkey2)).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = "strval1"
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == "strval1"
    store.load(Value.new(:objkey2)).should == "strval1"
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = "strval1"
    store[Value.new(:objkey1)] = "strval2"
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = "strval1"
    store[Value.new(:objkey2)].should == "strval1"
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = "strval1"
    store.delete(Value.new(:objkey2)).should == "strval1"
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = "strval1"
    store[Value.new(:objkey2)].should == "strval1"
    store[Value.new(:objkey2)] = "strval2"
    store[Value.new(:objkey2)].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == "strval1"
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = "strval1"
    store[Value.new(:objkey2)].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = "strval1"
    store.fetch(Value.new(:objkey2), "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = "strval1"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = "strval2"
    store[Value.new(:objkey1)].should == "strval2"
    store.load(Value.new(:objkey1)).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = "strval2"
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == "strval2"
    store.load(Value.new(:objkey1)).should == "strval2"
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = "strval2"
    store[Value.new(:objkey2)] = "strval1"
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = "strval2"
    store[Value.new(:objkey1)].should == "strval2"
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = "strval2"
    store.delete(Value.new(:objkey1)).should == "strval2"
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = "strval2"
    store[Value.new(:objkey1)].should == "strval2"
    store[Value.new(:objkey1)] = "strval1"
    store[Value.new(:objkey1)].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == "strval2"
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = "strval2"
    store[Value.new(:objkey1)].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = "strval2"
    store.fetch(Value.new(:objkey1), "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = "strval2"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = "strval2"
    store[Value.new(:objkey2)].should == "strval2"
    store.load(Value.new(:objkey2)).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = "strval2"
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == "strval2"
    store.load(Value.new(:objkey2)).should == "strval2"
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = "strval2"
    store[Value.new(:objkey1)] = "strval1"
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = "strval2"
    store[Value.new(:objkey2)].should == "strval2"
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = "strval2"
    store.delete(Value.new(:objkey2)).should == "strval2"
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = "strval2"
    store[Value.new(:objkey2)].should == "strval2"
    store[Value.new(:objkey2)] = "strval1"
    store[Value.new(:objkey2)].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == "strval2"
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = "strval2"
    store[Value.new(:objkey2)].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = "strval2"
    store.fetch(Value.new(:objkey2), "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = "strval2"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_objectkey_stringvalue ####################

shared_examples_for 'returndifferent_objectkey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should_not be_equal(value)
  end
end

#################### returnsame_objectkey_stringvalue ####################

shared_examples_for 'returnsame_objectkey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should be_equal(value)
  end
end

#################### persist_objectkey_stringvalue ####################

shared_examples_for 'persist_objectkey_stringvalue' do
  it 'persists values' do
    store[Value.new(:objkey1)] = "strval1"
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == "strval1"
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = "strval1"
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == "strval1"
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = "strval2"
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == "strval2"
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = "strval2"
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == "strval2"
  end
end

#################### null_objectkey_binaryvalue ####################

shared_examples_for 'null_objectkey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = "ber"
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = "ber"
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)] = "ber"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)] = "ber"
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_objectkey_binaryvalue ####################

shared_examples_for 'store_objectkey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = "ber"
    store[Value.new(:objkey1)].should == "ber"
    store.load(Value.new(:objkey1)).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = "ber"
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == "ber"
    store.load(Value.new(:objkey1)).should == "ber"
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = "ber"
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = "ber"
    store[Value.new(:objkey1)].should == "ber"
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = "ber"
    store.delete(Value.new(:objkey1)).should == "ber"
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = "ber"
    store[Value.new(:objkey1)].should == "ber"
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == "ber"
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = "ber"
    store[Value.new(:objkey1)].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = "ber"
    store.fetch(Value.new(:objkey1), "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = "ber"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = "ber"
    store[Value.new(:objkey2)].should == "ber"
    store.load(Value.new(:objkey2)).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = "ber"
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == "ber"
    store.load(Value.new(:objkey2)).should == "ber"
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = "ber"
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = "ber"
    store[Value.new(:objkey2)].should == "ber"
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = "ber"
    store.delete(Value.new(:objkey2)).should == "ber"
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = "ber"
    store[Value.new(:objkey2)].should == "ber"
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == "ber"
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = "ber"
    store[Value.new(:objkey2)].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = "ber"
    store.fetch(Value.new(:objkey2), "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = "ber"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)].should == "\xAA\xBB\xCC"
    store.load(Value.new(:objkey1)).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == "\xAA\xBB\xCC"
    store.load(Value.new(:objkey1)).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)] = "ber"
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)].should == "\xAA\xBB\xCC"
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store.delete(Value.new(:objkey1)).should == "\xAA\xBB\xCC"
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)].should == "\xAA\xBB\xCC"
    store[Value.new(:objkey1)] = "ber"
    store[Value.new(:objkey1)].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store.fetch(Value.new(:objkey1), "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)].should == "\xAA\xBB\xCC"
    store.load(Value.new(:objkey2)).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == "\xAA\xBB\xCC"
    store.load(Value.new(:objkey2)).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)] = "ber"
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)].should == "\xAA\xBB\xCC"
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store.delete(Value.new(:objkey2)).should == "\xAA\xBB\xCC"
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)].should == "\xAA\xBB\xCC"
    store[Value.new(:objkey2)] = "ber"
    store[Value.new(:objkey2)].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store.fetch(Value.new(:objkey2), "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_objectkey_binaryvalue ####################

shared_examples_for 'returndifferent_objectkey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should_not be_equal(value)
  end
end

#################### returnsame_objectkey_binaryvalue ####################

shared_examples_for 'returnsame_objectkey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should be_equal(value)
  end
end

#################### persist_objectkey_binaryvalue ####################

shared_examples_for 'persist_objectkey_binaryvalue' do
  it 'persists values' do
    store[Value.new(:objkey1)] = "ber"
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == "ber"
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = "ber"
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == "ber"
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == "\xAA\xBB\xCC"
  end
end

#################### null_objectkey_hashvalue ####################

shared_examples_for 'null_objectkey_hashvalue' do
  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_objectkey_hashvalue ####################

shared_examples_for 'store_objectkey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store.load(Value.new(:objkey1)).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store.load(Value.new(:objkey1)).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.delete(Value.new(:objkey1)).should == {"hashval1"=>["array1", 1]}
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.fetch(Value.new(:objkey1), {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)].should == {"hashval1"=>["array1", 1]}
    store.load(Value.new(:objkey2)).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == {"hashval1"=>["array1", 1]}
    store.load(Value.new(:objkey2)).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)].should == {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store.delete(Value.new(:objkey2)).should == {"hashval1"=>["array1", 1]}
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)].should == {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store.fetch(Value.new(:objkey2), {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(Value.new(:objkey1)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(Value.new(:objkey1)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(Value.new(:objkey1)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(Value.new(:objkey1), {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(Value.new(:objkey2)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load(Value.new(:objkey2)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete(Value.new(:objkey2)).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(Value.new(:objkey2), {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_objectkey_hashvalue ####################

shared_examples_for 'returndifferent_objectkey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should_not be_equal(value)
  end
end

#################### returnsame_objectkey_hashvalue ####################

shared_examples_for 'returnsame_objectkey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should be_equal(value)
  end
end

#################### persist_objectkey_hashvalue ####################

shared_examples_for 'persist_objectkey_hashvalue' do
  it 'persists values' do
    store[Value.new(:objkey1)] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_objectkey_objectvalue ####################

shared_examples_for 'null_objectkey_objectvalue' do
  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey1)].should be_nil
    store.load(Value.new(:objkey1)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[Value.new(:objkey1)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey1)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(Value.new(:objkey1)).should be_false
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey1), Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey1)
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey1), options).should be_false
    store.load(Value.new(:objkey1), options).should be_nil
    store.fetch(Value.new(:objkey1), 42, options).should == 42
    store.fetch(Value.new(:objkey1), options) { 42 }.should == 42
    store.delete(Value.new(:objkey1), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey1), Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store[Value.new(:objkey2)].should be_nil
    store.load(Value.new(:objkey2)).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[Value.new(:objkey2)] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete(Value.new(:objkey2)).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?(Value.new(:objkey2)).should be_false
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch(Value.new(:objkey2), Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = Value.new(:objkey2)
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?(Value.new(:objkey2), options).should be_false
    store.load(Value.new(:objkey2), options).should be_nil
    store.fetch(Value.new(:objkey2), 42, options).should == 42
    store.fetch(Value.new(:objkey2), options) { 42 }.should == 42
    store.delete(Value.new(:objkey2), options).should be_nil
    store.clear(options).should equal(store)
    store.store(Value.new(:objkey2), Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_objectkey_objectvalue ####################

shared_examples_for 'store_objectkey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store.load(Value.new(:objkey1)).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store.load(Value.new(:objkey1)).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.delete(Value.new(:objkey1)).should == Value.new(:objval1)
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store[Value.new(:objkey1)].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = Value.new(:objval1)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.fetch(Value.new(:objkey1), Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store[Value.new(:objkey2)].should == Value.new(:objval1)
    store.load(Value.new(:objkey2)).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == Value.new(:objval1)
    store.load(Value.new(:objkey2)).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store[Value.new(:objkey2)].should == Value.new(:objval1)
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store.delete(Value.new(:objkey2)).should == Value.new(:objval1)
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store[Value.new(:objkey2)].should == Value.new(:objval1)
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = Value.new(:objval1)
    store[Value.new(:objkey2)].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store.fetch(Value.new(:objkey2), Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store[Value.new(:objkey1)].should == Value.new(:objval2)
    store.load(Value.new(:objkey1)).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store.key?(Value.new(:objkey1)).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(Value.new(:objkey1), value).should equal(value)
    store[Value.new(:objkey1)].should == Value.new(:objval2)
    store.load(Value.new(:objkey1)).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store.clear.should equal(store)
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store[Value.new(:objkey1)].should == Value.new(:objval2)
    store[Value.new(:objkey2)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store.delete(Value.new(:objkey1)).should == Value.new(:objval2)
    store.key?(Value.new(:objkey1)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store[Value.new(:objkey1)].should == Value.new(:objval2)
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store[Value.new(:objkey1)].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[Value.new(:objkey1)] = value).should equal(value)
    store[Value.new(:objkey1)].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey1).freeze
    store[key] = Value.new(:objval2)
    store[Value.new(:objkey1)].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store.fetch(Value.new(:objkey1), Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey1)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
    store.load(Value.new(:objkey2)).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.key?(Value.new(:objkey2)).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store(Value.new(:objkey2), value).should equal(value)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
    store.load(Value.new(:objkey2)).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.clear.should equal(store)
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
    store[Value.new(:objkey1)].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.delete(Value.new(:objkey2)).should == Value.new(:objval2)
    store.key?(Value.new(:objkey2)).should be_false
  end

  it 'overwrites existing values' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store[Value.new(:objkey2)].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[Value.new(:objkey2)] = value).should equal(value)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = Value.new(:objkey2).freeze
    store[key] = Value.new(:objval2)
    store[Value.new(:objkey2)].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.fetch(Value.new(:objkey2), Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch(Value.new(:objkey2)) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_objectkey_objectvalue ####################

shared_examples_for 'returndifferent_objectkey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should_not be_equal(value)
  end
end

#################### returnsame_objectkey_objectvalue ####################

shared_examples_for 'returnsame_objectkey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[Value.new(:objkey1)] = value
    store[Value.new(:objkey1)].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[Value.new(:objkey2)] = value
    store[Value.new(:objkey2)].should be_equal(value)
  end
end

#################### persist_objectkey_objectvalue ####################

shared_examples_for 'persist_objectkey_objectvalue' do
  it 'persists values' do
    store[Value.new(:objkey1)] = Value.new(:objval1)
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = Value.new(:objval1)
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[Value.new(:objkey1)] = Value.new(:objval2)
    store.close
    @store = nil
    store[Value.new(:objkey1)].should == Value.new(:objval2)
  end

  it 'persists values' do
    store[Value.new(:objkey2)] = Value.new(:objval2)
    store.close
    @store = nil
    store[Value.new(:objkey2)].should == Value.new(:objval2)
  end
end

#################### null_hashkey_nilvalue ####################

shared_examples_for 'null_hashkey_nilvalue' do
  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = ''
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = ''
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = ''
    store[{"hashkey1"=>"hashkey2"}] = nil
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, '').should == ''
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = ''
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, '', options).should == ''
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = nil
    store[{"hashkey3"=>"hashkey4"}] = ''
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = nil
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = nil
    store[{"hashkey1"=>"hashkey2"}] = ''
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, nil).should == nil
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = nil
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, nil, options).should == nil
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey3"=>"hashkey4"}] = false
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 0
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = 0
    store[{"hashkey1"=>"hashkey2"}] = false
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, 0).should == 0
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = 0
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, 0, options).should == 0
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey3"=>"hashkey4"}] = 0
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey1"=>"hashkey2"}] = 0
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, false, options).should == false
  end
end

#################### store_hashkey_nilvalue ####################

shared_examples_for 'store_hashkey_nilvalue' do
  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = ''
    store[{"hashkey1"=>"hashkey2"}].should == ''
    store.load({"hashkey1"=>"hashkey2"}).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = ''
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == ''
    store.load({"hashkey1"=>"hashkey2"}).should == ''
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = ''
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = ''
    store[{"hashkey1"=>"hashkey2"}].should == ''
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = ''
    store.delete({"hashkey1"=>"hashkey2"}).should == ''
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = ''
    store[{"hashkey1"=>"hashkey2"}].should == ''
    store[{"hashkey1"=>"hashkey2"}] = nil
    store[{"hashkey1"=>"hashkey2"}].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == ''
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = ''
    store[{"hashkey1"=>"hashkey2"}].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = ''
    store[{"hashkey3"=>"hashkey4"}].should == ''
    store.load({"hashkey3"=>"hashkey4"}).should == ''
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = ''
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = ''
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == ''
    store.load({"hashkey3"=>"hashkey4"}).should == ''
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = ''
    store[{"hashkey1"=>"hashkey2"}] = nil
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = ''
    store[{"hashkey3"=>"hashkey4"}].should == ''
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = ''
    store.delete({"hashkey3"=>"hashkey4"}).should == ''
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = ''
    store[{"hashkey3"=>"hashkey4"}].should == ''
    store[{"hashkey3"=>"hashkey4"}] = nil
    store[{"hashkey3"=>"hashkey4"}].should == nil
  end

  it 'stores frozen values' do
    value = ''.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == ''
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = ''
    store[{"hashkey3"=>"hashkey4"}].should == ''
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = nil
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store.load({"hashkey1"=>"hashkey2"}).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = nil
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store.load({"hashkey1"=>"hashkey2"}).should == nil
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = nil
    store[{"hashkey3"=>"hashkey4"}] = ''
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = nil
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = nil
    store.delete({"hashkey1"=>"hashkey2"}).should == nil
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = nil
    store[{"hashkey1"=>"hashkey2"}].should == nil
    store[{"hashkey1"=>"hashkey2"}] = ''
    store[{"hashkey1"=>"hashkey2"}].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == nil
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = nil
    store[{"hashkey1"=>"hashkey2"}].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = nil
    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = nil
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == nil
    store.load({"hashkey3"=>"hashkey4"}).should == nil
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = nil
    store[{"hashkey1"=>"hashkey2"}] = ''
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = nil
    store[{"hashkey3"=>"hashkey4"}].should == nil
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.delete({"hashkey3"=>"hashkey4"}).should == nil
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = nil
    store[{"hashkey3"=>"hashkey4"}].should == nil
    store[{"hashkey3"=>"hashkey4"}] = ''
    store[{"hashkey3"=>"hashkey4"}].should == ''
  end

  it 'stores frozen values' do
    value = nil.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == nil
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = nil
    store[{"hashkey3"=>"hashkey4"}].should == nil
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store.load({"hashkey1"=>"hashkey2"}).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store.load({"hashkey1"=>"hashkey2"}).should == 0
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey3"=>"hashkey4"}] = false
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store.delete({"hashkey1"=>"hashkey2"}).should == 0
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey1"=>"hashkey2"}].should == 0
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 0
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = 0
    store[{"hashkey1"=>"hashkey2"}].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = 0
    store[{"hashkey3"=>"hashkey4"}].should == 0
    store.load({"hashkey3"=>"hashkey4"}).should == 0
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 0
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = 0
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 0
    store.load({"hashkey3"=>"hashkey4"}).should == 0
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = 0
    store[{"hashkey1"=>"hashkey2"}] = false
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = 0
    store[{"hashkey3"=>"hashkey4"}].should == 0
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = 0
    store.delete({"hashkey3"=>"hashkey4"}).should == 0
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = 0
    store[{"hashkey3"=>"hashkey4"}].should == 0
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
  end

  it 'stores frozen values' do
    value = 0.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 0
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = 0
    store[{"hashkey3"=>"hashkey4"}].should == 0
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
    store.load({"hashkey1"=>"hashkey2"}).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == false
    store.load({"hashkey1"=>"hashkey2"}).should == false
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey3"=>"hashkey4"}] = 0
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store.delete({"hashkey1"=>"hashkey2"}).should == false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
    store[{"hashkey1"=>"hashkey2"}] = 0
    store[{"hashkey1"=>"hashkey2"}].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == false
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
    store.load({"hashkey3"=>"hashkey4"}).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == false
    store.load({"hashkey3"=>"hashkey4"}).should == false
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey1"=>"hashkey2"}] = 0
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store.delete({"hashkey3"=>"hashkey4"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
    store[{"hashkey3"=>"hashkey4"}] = 0
    store[{"hashkey3"=>"hashkey4"}].should == 0
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == false
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
  end
end

#################### persist_hashkey_nilvalue ####################

shared_examples_for 'persist_hashkey_nilvalue' do
  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = ''
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == ''
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = ''
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == ''
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = nil
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == nil
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = nil
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == nil
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = 0
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == 0
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = 0
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == 0
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == false
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == false
  end
end

#################### null_hashkey_integervalue ####################

shared_examples_for 'null_hashkey_integervalue' do
  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    store[{"hashkey3"=>"hashkey4"}] = -12
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 41
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    store[{"hashkey1"=>"hashkey2"}] = -12
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, 41).should == 41
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = 41
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, 41, options).should == 41
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    store[{"hashkey3"=>"hashkey4"}] = 41
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, -12, options).should == -12
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -12
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    store[{"hashkey1"=>"hashkey2"}] = 41
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, -12).should == -12
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = -12
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, -12, options).should == -12
  end
end

#################### store_hashkey_integervalue ####################

shared_examples_for 'store_hashkey_integervalue' do
  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    store[{"hashkey1"=>"hashkey2"}].should == 41
    store.load({"hashkey1"=>"hashkey2"}).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 41
    store.load({"hashkey1"=>"hashkey2"}).should == 41
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    store[{"hashkey3"=>"hashkey4"}] = -12
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = 41
    store[{"hashkey1"=>"hashkey2"}].should == 41
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    store.delete({"hashkey1"=>"hashkey2"}).should == 41
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    store[{"hashkey1"=>"hashkey2"}].should == 41
    store[{"hashkey1"=>"hashkey2"}] = -12
    store[{"hashkey1"=>"hashkey2"}].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 41
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = 41
    store[{"hashkey1"=>"hashkey2"}].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    store.fetch({"hashkey1"=>"hashkey2"}, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    store[{"hashkey3"=>"hashkey4"}].should == 41
    store.load({"hashkey3"=>"hashkey4"}).should == 41
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = 41
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 41
    store.load({"hashkey3"=>"hashkey4"}).should == 41
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    store[{"hashkey1"=>"hashkey2"}] = -12
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = 41
    store[{"hashkey3"=>"hashkey4"}].should == 41
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    store.delete({"hashkey3"=>"hashkey4"}).should == 41
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    store[{"hashkey3"=>"hashkey4"}].should == 41
    store[{"hashkey3"=>"hashkey4"}] = -12
    store[{"hashkey3"=>"hashkey4"}].should == -12
  end

  it 'stores frozen values' do
    value = 41.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 41
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = 41
    store[{"hashkey3"=>"hashkey4"}].should == 41
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    store.fetch({"hashkey3"=>"hashkey4"}, -12).should == 41
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    store[{"hashkey1"=>"hashkey2"}].should == -12
    store.load({"hashkey1"=>"hashkey2"}).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == -12
    store.load({"hashkey1"=>"hashkey2"}).should == -12
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    store[{"hashkey3"=>"hashkey4"}] = 41
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = -12
    store[{"hashkey1"=>"hashkey2"}].should == -12
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    store.delete({"hashkey1"=>"hashkey2"}).should == -12
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    store[{"hashkey1"=>"hashkey2"}].should == -12
    store[{"hashkey1"=>"hashkey2"}] = 41
    store[{"hashkey1"=>"hashkey2"}].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == -12
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = -12
    store[{"hashkey1"=>"hashkey2"}].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    store.fetch({"hashkey1"=>"hashkey2"}, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    store[{"hashkey3"=>"hashkey4"}].should == -12
    store.load({"hashkey3"=>"hashkey4"}).should == -12
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = -12
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == -12
    store.load({"hashkey3"=>"hashkey4"}).should == -12
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    store[{"hashkey1"=>"hashkey2"}] = 41
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = -12
    store[{"hashkey3"=>"hashkey4"}].should == -12
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    store.delete({"hashkey3"=>"hashkey4"}).should == -12
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    store[{"hashkey3"=>"hashkey4"}].should == -12
    store[{"hashkey3"=>"hashkey4"}] = 41
    store[{"hashkey3"=>"hashkey4"}].should == 41
  end

  it 'stores frozen values' do
    value = -12.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == -12
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = -12
    store[{"hashkey3"=>"hashkey4"}].should == -12
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    store.fetch({"hashkey3"=>"hashkey4"}, 41).should == -12
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_hashkey_integervalue ####################

shared_examples_for 'persist_hashkey_integervalue' do
  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = 41
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == 41
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = 41
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == 41
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = -12
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == -12
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = -12
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == -12
  end
end

#################### null_hashkey_numbervalue ####################

shared_examples_for 'null_hashkey_numbervalue' do
  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 123.456
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, 123.456).should == 123.456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = 123.456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, 123.456, options).should == 123.456
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = -98.7
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, -98.7).should == -98.7
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = -98.7
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, -98.7, options).should == -98.7
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}] = 33
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 340282366920938463463374607431768211456
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}] = 33
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, 340282366920938463463374607431768211456).should == 340282366920938463463374607431768211456
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = 340282366920938463463374607431768211456
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, 340282366920938463463374607431768211456, options).should == 340282366920938463463374607431768211456
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, 33, options).should == 33
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = 33
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, 33).should == 33
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = 33
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, 33, options).should == 33
  end
end

#################### store_hashkey_numbervalue ####################

shared_examples_for 'store_hashkey_numbervalue' do
  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store[{"hashkey1"=>"hashkey2"}].should == 123.456
    store.load({"hashkey1"=>"hashkey2"}).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 123.456
    store.load({"hashkey1"=>"hashkey2"}).should == 123.456
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store[{"hashkey1"=>"hashkey2"}].should == 123.456
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store.delete({"hashkey1"=>"hashkey2"}).should == 123.456
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store[{"hashkey1"=>"hashkey2"}].should == 123.456
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store[{"hashkey1"=>"hashkey2"}].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 123.456
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = 123.456
    store[{"hashkey1"=>"hashkey2"}].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store.fetch({"hashkey1"=>"hashkey2"}, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store[{"hashkey3"=>"hashkey4"}].should == 123.456
    store.load({"hashkey3"=>"hashkey4"}).should == 123.456
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = 123.456
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 123.456
    store.load({"hashkey3"=>"hashkey4"}).should == 123.456
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store[{"hashkey3"=>"hashkey4"}].should == 123.456
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store.delete({"hashkey3"=>"hashkey4"}).should == 123.456
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store[{"hashkey3"=>"hashkey4"}].should == 123.456
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store[{"hashkey3"=>"hashkey4"}].should == -98.7
  end

  it 'stores frozen values' do
    value = 123.456.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 123.456
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = 123.456
    store[{"hashkey3"=>"hashkey4"}].should == 123.456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store.fetch({"hashkey3"=>"hashkey4"}, -98.7).should == 123.456
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store[{"hashkey1"=>"hashkey2"}].should == -98.7
    store.load({"hashkey1"=>"hashkey2"}).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == -98.7
    store.load({"hashkey1"=>"hashkey2"}).should == -98.7
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store[{"hashkey1"=>"hashkey2"}].should == -98.7
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store.delete({"hashkey1"=>"hashkey2"}).should == -98.7
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store[{"hashkey1"=>"hashkey2"}].should == -98.7
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store[{"hashkey1"=>"hashkey2"}].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == -98.7
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = -98.7
    store[{"hashkey1"=>"hashkey2"}].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store.fetch({"hashkey1"=>"hashkey2"}, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store[{"hashkey3"=>"hashkey4"}].should == -98.7
    store.load({"hashkey3"=>"hashkey4"}).should == -98.7
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = -98.7
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == -98.7
    store.load({"hashkey3"=>"hashkey4"}).should == -98.7
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store[{"hashkey3"=>"hashkey4"}].should == -98.7
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store.delete({"hashkey3"=>"hashkey4"}).should == -98.7
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store[{"hashkey3"=>"hashkey4"}].should == -98.7
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store[{"hashkey3"=>"hashkey4"}].should == 123.456
  end

  it 'stores frozen values' do
    value = -98.7.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == -98.7
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = -98.7
    store[{"hashkey3"=>"hashkey4"}].should == -98.7
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store.fetch({"hashkey3"=>"hashkey4"}, 123.456).should == -98.7
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}].should == 340282366920938463463374607431768211456
    store.load({"hashkey1"=>"hashkey2"}).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 340282366920938463463374607431768211456
    store.load({"hashkey1"=>"hashkey2"}).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}] = 33
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}].should == 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store.delete({"hashkey1"=>"hashkey2"}).should == 340282366920938463463374607431768211456
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}].should == 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}] = 33
    store[{"hashkey1"=>"hashkey2"}].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store.fetch({"hashkey1"=>"hashkey2"}, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}].should == 340282366920938463463374607431768211456
    store.load({"hashkey3"=>"hashkey4"}).should == 340282366920938463463374607431768211456
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = 340282366920938463463374607431768211456
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 340282366920938463463374607431768211456
    store.load({"hashkey3"=>"hashkey4"}).should == 340282366920938463463374607431768211456
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}] = 33
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}].should == 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store.delete({"hashkey3"=>"hashkey4"}).should == 340282366920938463463374607431768211456
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}].should == 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}] = 33
    store[{"hashkey3"=>"hashkey4"}].should == 33
  end

  it 'stores frozen values' do
    value = 340282366920938463463374607431768211456.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}].should == 340282366920938463463374607431768211456
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store.fetch({"hashkey3"=>"hashkey4"}, 33).should == 340282366920938463463374607431768211456
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    store[{"hashkey1"=>"hashkey2"}].should == 33
    store.load({"hashkey1"=>"hashkey2"}).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 33
    store.load({"hashkey1"=>"hashkey2"}).should == 33
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = 33
    store[{"hashkey1"=>"hashkey2"}].should == 33
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    store.delete({"hashkey1"=>"hashkey2"}).should == 33
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    store[{"hashkey1"=>"hashkey2"}].should == 33
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store[{"hashkey1"=>"hashkey2"}].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == 33
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = 33
    store[{"hashkey1"=>"hashkey2"}].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    store.fetch({"hashkey1"=>"hashkey2"}, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    store[{"hashkey3"=>"hashkey4"}].should == 33
    store.load({"hashkey3"=>"hashkey4"}).should == 33
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = 33
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 33
    store.load({"hashkey3"=>"hashkey4"}).should == 33
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = 33
    store[{"hashkey3"=>"hashkey4"}].should == 33
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    store.delete({"hashkey3"=>"hashkey4"}).should == 33
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    store[{"hashkey3"=>"hashkey4"}].should == 33
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store[{"hashkey3"=>"hashkey4"}].should == 340282366920938463463374607431768211456
  end

  it 'stores frozen values' do
    value = 33.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == 33
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = 33
    store[{"hashkey3"=>"hashkey4"}].should == 33
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    store.fetch({"hashkey3"=>"hashkey4"}, 340282366920938463463374607431768211456).should == 33
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_hashkey_numbervalue ####################

shared_examples_for 'persist_hashkey_numbervalue' do
  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = 123.456
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == 123.456
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = 123.456
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == 123.456
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = -98.7
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == -98.7
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = -98.7
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == -98.7
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = 340282366920938463463374607431768211456
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == 340282366920938463463374607431768211456
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = 33
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == 33
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = 33
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == 33
  end
end

#################### null_hashkey_booleanvalue ####################

shared_examples_for 'null_hashkey_booleanvalue' do
  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey3"=>"hashkey4"}] = false
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = true
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = true
    store[{"hashkey1"=>"hashkey2"}] = false
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, true).should == true
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = true
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, true, options).should == true
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey3"=>"hashkey4"}] = true
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, false, options).should == false
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = false
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey1"=>"hashkey2"}] = true
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, false).should == false
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = false
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, false, options).should == false
  end
end

#################### store_hashkey_booleanvalue ####################

shared_examples_for 'store_hashkey_booleanvalue' do
  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey1"=>"hashkey2"}].should == true
    store.load({"hashkey1"=>"hashkey2"}).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = true
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == true
    store.load({"hashkey1"=>"hashkey2"}).should == true
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey3"=>"hashkey4"}] = false
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey1"=>"hashkey2"}].should == true
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = true
    store.delete({"hashkey1"=>"hashkey2"}).should == true
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey1"=>"hashkey2"}].should == true
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == true
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = true
    store[{"hashkey1"=>"hashkey2"}].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = true
    store.fetch({"hashkey1"=>"hashkey2"}, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = true
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = true
    store[{"hashkey3"=>"hashkey4"}].should == true
    store.load({"hashkey3"=>"hashkey4"}).should == true
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = true
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = true
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == true
    store.load({"hashkey3"=>"hashkey4"}).should == true
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = true
    store[{"hashkey1"=>"hashkey2"}] = false
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = true
    store[{"hashkey3"=>"hashkey4"}].should == true
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = true
    store.delete({"hashkey3"=>"hashkey4"}).should == true
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = true
    store[{"hashkey3"=>"hashkey4"}].should == true
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
  end

  it 'stores frozen values' do
    value = true.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == true
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = true
    store[{"hashkey3"=>"hashkey4"}].should == true
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = true
    store.fetch({"hashkey3"=>"hashkey4"}, false).should == true
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = true
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
    store.load({"hashkey1"=>"hashkey2"}).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == false
    store.load({"hashkey1"=>"hashkey2"}).should == false
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey3"=>"hashkey4"}] = true
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store.delete({"hashkey1"=>"hashkey2"}).should == false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
    store[{"hashkey1"=>"hashkey2"}] = true
    store[{"hashkey1"=>"hashkey2"}].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == false
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = false
    store[{"hashkey1"=>"hashkey2"}].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store.fetch({"hashkey1"=>"hashkey2"}, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = false
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
    store.load({"hashkey3"=>"hashkey4"}).should == false
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = false
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == false
    store.load({"hashkey3"=>"hashkey4"}).should == false
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey1"=>"hashkey2"}] = true
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store.delete({"hashkey3"=>"hashkey4"}).should == false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
    store[{"hashkey3"=>"hashkey4"}] = true
    store[{"hashkey3"=>"hashkey4"}].should == true
  end

  it 'stores frozen values' do
    value = false.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == false
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = false
    store[{"hashkey3"=>"hashkey4"}].should == false
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store.fetch({"hashkey3"=>"hashkey4"}, true).should == false
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = false
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### persist_hashkey_booleanvalue ####################

shared_examples_for 'persist_hashkey_booleanvalue' do
  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = true
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == true
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = true
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == true
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = false
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == false
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = false
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == false
  end
end

#################### null_hashkey_stringvalue ####################

shared_examples_for 'null_hashkey_stringvalue' do
  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval1"
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, "strval1").should == "strval1"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = "strval1"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, "strval1", options).should == "strval1"
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, "strval2", options).should == "strval2"
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "strval2"
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, "strval2").should == "strval2"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = "strval2"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, "strval2", options).should == "strval2"
  end
end

#################### store_hashkey_stringvalue ####################

shared_examples_for 'store_hashkey_stringvalue' do
  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store.load({"hashkey1"=>"hashkey2"}).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store.load({"hashkey1"=>"hashkey2"}).should == "strval1"
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.delete({"hashkey1"=>"hashkey2"}).should == "strval1"
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.fetch({"hashkey1"=>"hashkey2"}, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}].should == "strval1"
    store.load({"hashkey3"=>"hashkey4"}).should == "strval1"
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = "strval1"
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "strval1"
    store.load({"hashkey3"=>"hashkey4"}).should == "strval1"
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}].should == "strval1"
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store.delete({"hashkey3"=>"hashkey4"}).should == "strval1"
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}].should == "strval1"
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
  end

  it 'stores frozen values' do
    value = "strval1".freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "strval1"
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = "strval1"
    store[{"hashkey3"=>"hashkey4"}].should == "strval1"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store.fetch({"hashkey3"=>"hashkey4"}, "strval2").should == "strval1"
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
    store.load({"hashkey1"=>"hashkey2"}).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
    store.load({"hashkey1"=>"hashkey2"}).should == "strval2"
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store.delete({"hashkey1"=>"hashkey2"}).should == "strval2"
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = "strval2"
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store.fetch({"hashkey1"=>"hashkey2"}, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
    store.load({"hashkey3"=>"hashkey4"}).should == "strval2"
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = "strval2"
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
    store.load({"hashkey3"=>"hashkey4"}).should == "strval2"
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.delete({"hashkey3"=>"hashkey4"}).should == "strval2"
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store[{"hashkey3"=>"hashkey4"}].should == "strval1"
  end

  it 'stores frozen values' do
    value = "strval2".freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = "strval2"
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.fetch({"hashkey3"=>"hashkey4"}, "strval1").should == "strval2"
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_hashkey_stringvalue ####################

shared_examples_for 'returndifferent_hashkey_stringvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval1"
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "strval2"
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(value)
  end
end

#################### returnsame_hashkey_stringvalue ####################

shared_examples_for 'returnsame_hashkey_stringvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval1"
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "strval2"
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should be_equal(value)
  end
end

#################### persist_hashkey_stringvalue ####################

shared_examples_for 'persist_hashkey_stringvalue' do
  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = "strval1"
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == "strval1"
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = "strval1"
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == "strval1"
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = "strval2"
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == "strval2"
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = "strval2"
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == "strval2"
  end
end

#################### null_hashkey_binaryvalue ####################

shared_examples_for 'null_hashkey_binaryvalue' do
  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "ber"
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, "ber").should == "ber"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = "ber"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, "ber", options).should == "ber"
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = "\xAA\xBB\xCC"
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, "\xAA\xBB\xCC").should == "\xAA\xBB\xCC"
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = "\xAA\xBB\xCC"
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, "\xAA\xBB\xCC", options).should == "\xAA\xBB\xCC"
  end
end

#################### store_hashkey_binaryvalue ####################

shared_examples_for 'store_hashkey_binaryvalue' do
  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store[{"hashkey1"=>"hashkey2"}].should == "ber"
    store.load({"hashkey1"=>"hashkey2"}).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "ber"
    store.load({"hashkey1"=>"hashkey2"}).should == "ber"
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store[{"hashkey1"=>"hashkey2"}].should == "ber"
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store.delete({"hashkey1"=>"hashkey2"}).should == "ber"
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store[{"hashkey1"=>"hashkey2"}].should == "ber"
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "ber"
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = "ber"
    store[{"hashkey1"=>"hashkey2"}].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store.fetch({"hashkey1"=>"hashkey2"}, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store[{"hashkey3"=>"hashkey4"}].should == "ber"
    store.load({"hashkey3"=>"hashkey4"}).should == "ber"
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = "ber"
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "ber"
    store.load({"hashkey3"=>"hashkey4"}).should == "ber"
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store[{"hashkey3"=>"hashkey4"}].should == "ber"
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store.delete({"hashkey3"=>"hashkey4"}).should == "ber"
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store[{"hashkey3"=>"hashkey4"}].should == "ber"
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen values' do
    value = "ber".freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "ber"
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = "ber"
    store[{"hashkey3"=>"hashkey4"}].should == "ber"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store.fetch({"hashkey3"=>"hashkey4"}, "\xAA\xBB\xCC").should == "ber"
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}].should == "\xAA\xBB\xCC"
    store.load({"hashkey1"=>"hashkey2"}).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "\xAA\xBB\xCC"
    store.load({"hashkey1"=>"hashkey2"}).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}].should == "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store.delete({"hashkey1"=>"hashkey2"}).should == "\xAA\xBB\xCC"
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}].should == "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store[{"hashkey1"=>"hashkey2"}].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store.fetch({"hashkey1"=>"hashkey2"}, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}].should == "\xAA\xBB\xCC"
    store.load({"hashkey3"=>"hashkey4"}).should == "\xAA\xBB\xCC"
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = "\xAA\xBB\xCC"
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "\xAA\xBB\xCC"
    store.load({"hashkey3"=>"hashkey4"}).should == "\xAA\xBB\xCC"
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}].should == "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store.delete({"hashkey3"=>"hashkey4"}).should == "\xAA\xBB\xCC"
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}].should == "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store[{"hashkey3"=>"hashkey4"}].should == "ber"
  end

  it 'stores frozen values' do
    value = "\xAA\xBB\xCC".freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == "\xAA\xBB\xCC"
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}].should == "\xAA\xBB\xCC"
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store.fetch({"hashkey3"=>"hashkey4"}, "ber").should == "\xAA\xBB\xCC"
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_hashkey_binaryvalue ####################

shared_examples_for 'returndifferent_hashkey_binaryvalue' do
  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "ber"
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(value)
  end
end

#################### returnsame_hashkey_binaryvalue ####################

shared_examples_for 'returnsame_hashkey_binaryvalue' do
  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "ber"
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = "\xAA\xBB\xCC"
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should be_equal(value)
  end
end

#################### persist_hashkey_binaryvalue ####################

shared_examples_for 'persist_hashkey_binaryvalue' do
  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = "ber"
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == "ber"
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = "ber"
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == "ber"
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == "\xAA\xBB\xCC"
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = "\xAA\xBB\xCC"
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == "\xAA\xBB\xCC"
  end
end

#################### null_hashkey_hashvalue ####################

shared_examples_for 'null_hashkey_hashvalue' do
  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval1"=>["array1", 1]}
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, {"hashval1"=>["array1", 1]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = {"hashval1"=>["array1", 1]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, {"hashval1"=>["array1", 1]}, options).should == {"hashval1"=>["array1", 1]}
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, {"hashval3"=>["array2", {"hashval4"=>42}]}, options).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### store_hashkey_hashvalue ####################

shared_examples_for 'store_hashkey_hashvalue' do
  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store.load({"hashkey1"=>"hashkey2"}).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store.load({"hashkey1"=>"hashkey2"}).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.delete({"hashkey1"=>"hashkey2"}).should == {"hashval1"=>["array1", 1]}
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.fetch({"hashkey1"=>"hashkey2"}, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval1"=>["array1", 1]}
    store.load({"hashkey3"=>"hashkey4"}).should == {"hashval1"=>["array1", 1]}
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval1"=>["array1", 1]}
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval1"=>["array1", 1]}
    store.load({"hashkey3"=>"hashkey4"}).should == {"hashval1"=>["array1", 1]}
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store.delete({"hashkey3"=>"hashkey4"}).should == {"hashval1"=>["array1", 1]}
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen values' do
    value = {"hashval1"=>["array1", 1]}.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval1"=>["array1", 1]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store.fetch({"hashkey3"=>"hashkey4"}, {"hashval3"=>["array2", {"hashval4"=>42}]}).should == {"hashval1"=>["array1", 1]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load({"hashkey1"=>"hashkey2"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load({"hashkey1"=>"hashkey2"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete({"hashkey1"=>"hashkey2"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch({"hashkey1"=>"hashkey2"}, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load({"hashkey3"=>"hashkey4"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.load({"hashkey3"=>"hashkey4"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.delete({"hashkey3"=>"hashkey4"}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval1"=>["array1", 1]}
  end

  it 'stores frozen values' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}.freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.fetch({"hashkey3"=>"hashkey4"}, {"hashval1"=>["array1", 1]}).should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_hashkey_hashvalue ####################

shared_examples_for 'returndifferent_hashkey_hashvalue' do
  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(value)
  end
end

#################### returnsame_hashkey_hashvalue ####################

shared_examples_for 'returnsame_hashkey_hashvalue' do
  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval1"=>["array1", 1]}
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should be_equal(value)
  end
end

#################### persist_hashkey_hashvalue ####################

shared_examples_for 'persist_hashkey_hashvalue' do
  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval1"=>["array1", 1]}
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval1"=>["array1", 1]}
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = {"hashval3"=>["array2", {"hashval4"=>42}]}
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == {"hashval3"=>["array2", {"hashval4"=>42}]}
  end
end

#################### null_hashkey_objectvalue ####################

shared_examples_for 'null_hashkey_objectvalue' do
  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval1)
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, Value.new(:objval1)).should == Value.new(:objval1)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = Value.new(:objval1)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, Value.new(:objval1), options).should == Value.new(:objval1)
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey1"=>"hashkey2"}].should be_nil
    store.load({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey1"=>"hashkey2"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey1"=>"hashkey2"}, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey1"=>"hashkey2"}
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey1"=>"hashkey2"}, options).should be_false
    store.load({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.fetch({"hashkey1"=>"hashkey2"}, 42, options).should == 42
    store.fetch({"hashkey1"=>"hashkey2"}, options) { 42 }.should == 42
    store.delete({"hashkey1"=>"hashkey2"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey1"=>"hashkey2"}, Value.new(:objval2), options).should == Value.new(:objval2)
  end

  it 'reads from keys like a Hash' do
    store[{"hashkey3"=>"hashkey4"}].should be_nil
    store.load({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'guarantees that the same value is returned when setting a key' do
    value = Value.new(:objval2)
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
  end

  it 'returns false from #key? if a key is not available' do
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'returns nil from delete if a value for a key does not exist' do
    store.delete({"hashkey3"=>"hashkey4"}).should be_nil
  end

  it 'removes all keys from the store with clear' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.clear.should equal(store)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'fetches a key with a default value with fetch, if the key is not available' do
    store.fetch({"hashkey3"=>"hashkey4"}, Value.new(:objval2)).should == Value.new(:objval2)
  end

  it 'fetches a key with a block with fetch, if the key is not available' do
    key = {"hashkey3"=>"hashkey4"}
    value = Value.new(:objval2)
    store.fetch(key) do |k|
      k.should equal(key)
      value
    end.should equal(value)
  end

  it 'accepts frozen options' do
    options = {:option1 => 1, :options2 => 2}
    options.freeze
    store.key?({"hashkey3"=>"hashkey4"}, options).should be_false
    store.load({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.fetch({"hashkey3"=>"hashkey4"}, 42, options).should == 42
    store.fetch({"hashkey3"=>"hashkey4"}, options) { 42 }.should == 42
    store.delete({"hashkey3"=>"hashkey4"}, options).should be_nil
    store.clear(options).should equal(store)
    store.store({"hashkey3"=>"hashkey4"}, Value.new(:objval2), options).should == Value.new(:objval2)
  end
end

#################### store_hashkey_objectvalue ####################

shared_examples_for 'store_hashkey_objectvalue' do
  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store.load({"hashkey1"=>"hashkey2"}).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store.load({"hashkey1"=>"hashkey2"}).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.delete({"hashkey1"=>"hashkey2"}).should == Value.new(:objval1)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.fetch({"hashkey1"=>"hashkey2"}, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval1)
    store.load({"hashkey3"=>"hashkey4"}).should == Value.new(:objval1)
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval1)
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval1)
    store.load({"hashkey3"=>"hashkey4"}).should == Value.new(:objval1)
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store.delete({"hashkey3"=>"hashkey4"}).should == Value.new(:objval1)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
  end

  it 'stores frozen values' do
    value = Value.new(:objval1).freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval1)
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval1)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store.fetch({"hashkey3"=>"hashkey4"}, Value.new(:objval2)).should == Value.new(:objval1)
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
    store.load({"hashkey1"=>"hashkey2"}).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store.key?({"hashkey1"=>"hashkey2"}).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store({"hashkey1"=>"hashkey2"}, value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
    store.load({"hashkey1"=>"hashkey2"}).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store.clear.should equal(store)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store.delete({"hashkey1"=>"hashkey2"}).should == Value.new(:objval2)
    store.key?({"hashkey1"=>"hashkey2"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[{"hashkey1"=>"hashkey2"}] = value).should equal(value)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = {"hashkey1"=>"hashkey2"}.freeze
    store[key] = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store.fetch({"hashkey1"=>"hashkey2"}, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch({"hashkey1"=>"hashkey2"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end

  it 'writes values to keys that like a Hash' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
    store.load({"hashkey3"=>"hashkey4"}).should == Value.new(:objval2)
  end

  it 'returns true from #key? if a key is available' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.key?({"hashkey3"=>"hashkey4"}).should be_true
  end

  it 'stores values with #store' do
    value = Value.new(:objval2)
    store.store({"hashkey3"=>"hashkey4"}, value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
    store.load({"hashkey3"=>"hashkey4"}).should == Value.new(:objval2)
  end

  it 'stores values after clear' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.clear.should equal(store)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}].should be_nil
  end

  it 'removes and returns a value from the backing store via delete if it exists' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.delete({"hashkey3"=>"hashkey4"}).should == Value.new(:objval2)
    store.key?({"hashkey3"=>"hashkey4"}).should be_false
  end

  it 'overwrites existing values' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval1)
  end

  it 'stores frozen values' do
    value = Value.new(:objval2).freeze
    (store[{"hashkey3"=>"hashkey4"}] = value).should equal(value)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
  end

  it 'stores frozen keys' do
    key = {"hashkey3"=>"hashkey4"}.freeze
    store[key] = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
  end
  it 'fetches a key with a default value with fetch, if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.fetch({"hashkey3"=>"hashkey4"}, Value.new(:objval1)).should == Value.new(:objval2)
  end

  it 'does not run the block in fetch if the key is available' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    unaltered = 'unaltered'
    store.fetch({"hashkey3"=>"hashkey4"}) { unaltered = 'altered' }
    unaltered.should == 'unaltered'
  end
end

#################### returndifferent_hashkey_objectvalue ####################

shared_examples_for 'returndifferent_hashkey_objectvalue' do
  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should_not be_equal(value)
  end

  it 'guarantees that a different value is retrieved' do
    value = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should_not be_equal(value)
  end
end

#################### returnsame_hashkey_objectvalue ####################

shared_examples_for 'returnsame_hashkey_objectvalue' do
  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval1)
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[{"hashkey1"=>"hashkey2"}] = value
    store[{"hashkey1"=>"hashkey2"}].should be_equal(value)
  end

  it 'guarantees that the same value is retrieved' do
    value = Value.new(:objval2)
    store[{"hashkey3"=>"hashkey4"}] = value
    store[{"hashkey3"=>"hashkey4"}].should be_equal(value)
  end
end

#################### persist_hashkey_objectvalue ####################

shared_examples_for 'persist_hashkey_objectvalue' do
  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval1)
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval1)
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval1)
  end

  it 'persists values' do
    store[{"hashkey1"=>"hashkey2"}] = Value.new(:objval2)
    store.close
    @store = nil
    store[{"hashkey1"=>"hashkey2"}].should == Value.new(:objval2)
  end

  it 'persists values' do
    store[{"hashkey3"=>"hashkey4"}] = Value.new(:objval2)
    store.close
    @store = nil
    store[{"hashkey3"=>"hashkey4"}].should == Value.new(:objval2)
  end
end

#################### store_large ####################

shared_examples_for 'store_large' do
  it 'should store values up to 32k' do
    value = 'x' * (32 * 1024)
    store['large'] = value
    store['large'].should == value
  end

  it 'should store keys up to 128 bytes' do
    key = 'x' * 128
    store[key] = 'value'
    store[key].should == 'value'
  end
end

#################### not_persist ####################

shared_examples_for 'not_persist' do
  it 'does not persist values' do
    store['key'] = 'val'
    store.close
    @store = nil

    store['key'].should be_nil
  end
end

#################### multiprocess ####################

shared_examples_for 'multiprocess' do
  it 'supports access by multiple instances/processes' do
    store['key'] = 'val'
    store2 = new_store
    store2['key'].should == 'val'
    store2.close
  end
end

#################### expires ####################

shared_examples_for 'expires' do
  it 'supports expires on store and []', :retry => 3 do
    store.store('key1', 'val1', :expires => 3)
    store['key1'].should == 'val1'
    sleep 1
    store['key1'].should == 'val1'
    sleep 3
    store['key1'].should be_nil
  end

  it 'supports strict expires on store and []' do
    store.store('key1', 'val1', :expires => 2)
    store['key1'].should == 'val1'
    sleep 3 # Sleep 3 seconds because after 2 seconds the value can still exist!
    store['key1'].should be_nil
  end

  it 'supports expires on store and fetch', :retry => 3 do
    store.store('key1', 'val1', :expires => 3)
    store.fetch('key1').should == 'val1'
    sleep 1
    store.fetch('key1').should == 'val1'
    sleep 3
    store.fetch('key1').should be_nil
  end

  it 'supports strict expires on store and fetch' do
    store.store('key1', 'val1', :expires => 2)
    store.fetch('key1').should == 'val1'
    sleep 3 # Sleep 3 seconds because after 2 seconds the value can still exist!
    store.fetch('key1').should be_nil
  end

  it 'supports 0 as no-expires on store and []' do
    store.store('key1', 'val1', :expires => 0)
    store['key1'].should == 'val1'
    sleep 2
    store['key1'].should == 'val1'
  end

  it 'supports false as no-expires on store and []' do
    store.store('key1', 'val1', :expires => false)
    store['key1'].should == 'val1'
    sleep 2
    store['key1'].should == 'val1'
  end

  it 'supports expires on store and load', :retry => 3 do
    store.store('key1', 'val1', :expires => 3)
    store.load('key1').should == 'val1'
    sleep 1
    store.load('key1').should == 'val1'
    sleep 3
    store.load('key1').should be_nil
  end

  it 'supports strict expires on store and load' do
    store.store('key1', 'val1', :expires => 2)
    store.load('key1').should == 'val1'
    sleep 3 # Sleep 3 seconds because after 2 seconds the value can still exist!
    store.load('key1').should be_nil
  end

  it 'supports expires on store and #key?', :retry => 3 do
    store.store('key1', 'val1', :expires => 3)
    store.key?('key1').should be_true
    sleep 1
    store.key?('key1').should be_true
    sleep 3
    store.key?('key1').should be_false
  end

  it 'supports strict expires on store and #key?' do
    store.store('key1', 'val1', :expires => 2)
    store.key?('key1').should be_true
    sleep 3 # Sleep 3 seconds because after 2 seconds the value can still exist!
    store.key?('key1').should be_false
  end

  it 'supports updating the expiration time in load', :retry => 3 do
    store.store('key2', 'val2', :expires => 3)
    store['key2'].should == 'val2'
    sleep 1
    store.load('key2', :expires => 5).should == 'val2'
    store['key2'].should == 'val2'
    sleep 3
    store['key2'].should == 'val2'
    sleep 3
    store['key2'].should be_nil
  end

  it 'supports 0 as no-expires in load' do
    store.store('key1', 'val1', :expires => 2)
    store.load('key1', :expires => 0).should == 'val1'
    sleep 3
    store.load('key1').should == 'val1'
  end

  it 'supports false as no-expires in load' do
    store.store('key1', 'val1', :expires => 2)
    store.load('key1', :expires => false).should == 'val1'
    sleep 3
    store.load('key1').should == 'val1'
  end

  it 'supports updating the expiration time in #key?', :retry => 3 do
    store.store('key2', 'val2', :expires => 3)
    store['key2'].should == 'val2'
    sleep 1
    store.key?('key2', :expires => 5).should be_true
    store['key2'].should == 'val2'
    sleep 3
    store['key2'].should == 'val2'
    sleep 3
    store['key2'].should be_nil
  end

  it 'supports 0 as no-expires in #key?' do
    store.store('key1', 'val1', :expires => 2)
    store.key?('key1', :expires => 0).should be_true
    sleep 3
    store['key1'].should == 'val1'
  end

  it 'supports false as no-expires in #key?' do
    store.store('key1', 'val1', :expires => 2)
    store.key?('key1', :expires => false ).should be_true
    sleep 3
    store['key1'].should == 'val1'
  end

  it 'supports updating the expiration time in fetch', :retry => 3 do
    store.store('key1', 'val1', :expires => 3)
    store['key1'].should == 'val1'
    sleep 1
    store.fetch('key1', nil, :expires => 5).should == 'val1'
    store['key1'].should == 'val1'
    sleep 3
    store['key1'].should == 'val1'
    sleep 3
    store['key1'].should be_nil
  end

  it 'supports 0 as no-expires in fetch' do
    store.store('key1', 'val1', :expires => 2)
    store.fetch('key1', nil, :expires => 0).should == 'val1'
    sleep 3
    store.load('key1').should == 'val1'
  end

  it 'supports false as no-expires in fetch' do
    store.store('key1', 'val1', :expires => 2)
    store.fetch('key1', nil, :expires => false).should == 'val1'
    sleep 3
    store.load('key1').should == 'val1'
  end

  it 'strictly respects expires in delete' do
    store.store('key2', 'val2', :expires => 2)
    store['key2'].should == 'val2'
    sleep 3 # Sleep 3 seconds because after 2 seconds the value can still exist!
    store.delete('key2').should be_nil
  end

  it 'respects expires in delete', :retry => 3 do
    store.store('key2', 'val2', :expires => 3)
    store['key2'].should == 'val2'
    sleep 1
    store['key2'].should == 'val2'
    sleep 3
    store.delete('key2').should be_nil
  end

  it 'supports the #expires syntactic sugar', :retry => 3 do
    store.store('persistent_key', 'persistent_value', :expires => 0)
    store.expires(1).store('key2', 'val2')
    store['key2'].should == 'val2'
    sleep 2
    store.delete('key2').should be_nil
    store['persistent_key'].should == 'persistent_value'
  end

  it 'supports false as no-expires on store and []' do
    store.store('key1', 'val1', :expires => false)
    store['key1'].should == 'val1'
    sleep 2
    store['key1'].should == 'val1'
  end

  it 'does not update the expiration time in #key? when not asked to do so', :retry => 3 do
    store.store('key1', 'val1', :expires => 1)
    store.key?('key1').should be_true
    store.key?('key1', :expires => nil).should be_true
    sleep 2
    store.key?('key1').should be_false
  end

  it 'does not update the expiration time in fetch when not asked to do so', :retry => 3 do
    store.store('key1', 'val1', :expires => 1)
    store.fetch('key1').should == 'val1'
    store.fetch('key1', :expires => nil).should == 'val1'
    sleep 2
    store.fetch('key1').should be_nil
  end

  it 'does not update the expiration time in load when not asked to do so', :retry => 3 do
    store.store('key1', 'val1', :expires => 1)
    store.load('key1').should == 'val1'
    store.load('key1', :expires => nil).should == 'val1'
    sleep 2
    store.load('key1').should be_nil
  end
end

#################### default_expires ####################

shared_examples_for 'default_expires' do
  it 'does set default expiration time' do
    store['key1'] = 'val1'
    store.key?('key1').should be_true
    store.fetch('key1').should == 'val1'
    store.load('key1').should == 'val1'
    sleep 2
    store.key?('key1').should be_false
    store.fetch('key1').should be_nil
    store.load('key1').should be_nil
  end
end

#################### not_increment ####################

shared_examples_for 'not_increment' do
  it 'does not support #increment' do
    expect do
      store.increment('inckey')
    end.to raise_error(NotImplementedError)
  end

  it 'does not support #decrement' do
    expect do
      store.increment('inckey')
    end.to raise_error(NotImplementedError)
  end
end

#################### concurrent_increment ####################

shared_examples_for 'concurrent_increment' do
  def increment_thread(name)
    Thread.new do
      s = new_store
      100.times do |i|
        100.times do |j|
          s.increment("counter#{j}", 1, :expires => false)
          Thread.pass if rand(1000) >= 995
        end
        s.store("#{name}#{i}", i.to_s, :expires => false)
      end
      s.close
    end
  end

  it 'have atomic increment across multiple processes' do
    a = increment_thread('a')
    b = increment_thread('b')
    c = increment_thread('c')
    a.join
    b.join
    c.join
    100.times do |i|
      store["a#{i}"].should == i.to_s
      store["b#{i}"].should == i.to_s
      store["c#{i}"].should == i.to_s
    end
    100.times do |j|
      store.raw["counter#{j}"].should == 300.to_s
    end
  end
end

#################### concurrent_create ####################

shared_examples_for 'concurrent_create' do
  def create_thread(name)
    Thread.new do
      s = new_store
      1000.times do |i|
        s[i.to_s].should == name if s.create(i.to_s, name, :expires => false)
        Thread.pass if rand(100) >= 99
      end
      s.close
    end
  end

  it 'have atomic create across multiple processes' do
    a = create_thread('a')
    b = create_thread('b')
    c = create_thread('c')
    a.join
    b.join
    c.join
  end
end

#################### increment ####################

shared_examples_for 'increment' do
  it 'initializes in #increment with 1' do
    store.key?('inckey').should be_false
    store.increment('inckey').should == 1
    store.key?('inckey').should be_true
    store.raw['inckey'].should == '1'
    store.raw.load('inckey').should == '1'
    store.load('inckey', :raw => true).should == '1'

    store.delete('inckey', :raw => true).should == '1'
    store.key?('inckey').should be_false
  end

  it 'initializes in #increment with higher value' do
    store.increment('inckey', 42).should == 42
    store.key?('inckey').should be_true
    store.raw['inckey'].should == '42'
    store.delete('inckey', :raw => true).should == '42'
  end

  it 'initializes in #increment with 0' do
    store.increment('inckey', 0).should == 0
    store.key?('inckey').should be_true
    store.raw['inckey'].should == '0'
    store.delete('inckey', :raw => true).should == '0'
  end

  it 'initializes in #decrement with 0' do
    store.decrement('inckey', 0).should == 0
    store.raw['inckey'].should == '0'
  end

  it 'initializes in #decrement with negative value' do
    store.decrement('inckey', -42).should == 42
    store.raw['inckey'].should == '42'
  end

  it 'supports incrementing existing value by value' do
    store.increment('inckey').should == 1
    store.increment('inckey', 42).should == 43
    store.raw['inckey'].should == '43'
  end

  it 'supports decrementing existing value by value' do
    store.increment('inckey').should == 1
    store.decrement('inckey').should == 0
    store.increment('inckey', 42).should == 42
    store.decrement('inckey', 2).should == 40
    store.raw['inckey'].should == '40'
  end

  it 'supports incrementing existing value by 0' do
    store.increment('inckey').should == 1
    store.increment('inckey', 0).should == 1
    store.raw['inckey'].should == '1'
  end

  it 'supports decrementing existing value' do
    store.increment('inckey', 10).should == 10
    store.increment('inckey', -5).should == 5
    store.raw['inckey'].should == '5'
    store.increment('inckey', -5).should == 0
    store.raw['inckey'].should == '0'
  end

  it 'interprets raw value as integer' do
    store.store('inckey', '42', :raw => true)
    store.increment('inckey').should == 43
    store.raw['inckey'].should == '43'
  end

  it 'raises error in #increment on non integer value' do
    store['strkey'] = 'value'
    expect do
      store.increment('strkey')
    end.to raise_error
  end

  it 'raises error in #decrement on non integer value' do
    store['strkey'] = 'value'
    expect do
      store.decrement('strkey')
    end.to raise_error
  end

  it 'supports Semaphore' do
    a = Moneta::Semaphore.new(store, 'semaphore', 2)
    b = Moneta::Semaphore.new(store, 'semaphore', 2)
    c = Moneta::Semaphore.new(store, 'semaphore', 2)
    a.synchronize do
      a.locked?.should be_true
      b.synchronize do
        b.locked?.should be_true
        c.try_lock.should be_false
      end
    end
  end

end

#################### create ####################

shared_examples_for 'create' do
  it 'creates the given key' do
    store.create('key','value').should be_true
    store['key'].should == 'value'
  end

  it 'creates raw value with the given key' do
    store.raw.create('key','value').should be_true
    store.raw['key'].should == 'value'
  end

  it 'does not create a key if it exists' do
    store['key'] = 'value'
    store.create('key','another value').should be_false
    store['key'].should == 'value'
  end

  it 'supports Mutex' do
    a = Moneta::Mutex.new(store, 'mutex')
    b = Moneta::Mutex.new(store, 'mutex')
    a.lock.should be_true
    b.try_lock.should be_false
    a.unlock.should be_nil
  end

end

#################### not_create ####################

shared_examples_for 'not_create' do
  it 'does not support #create' do
    expect do
      store.create('key','value')
    end.to raise_error(NotImplementedError)
  end
end

#################### create_expires ####################

shared_examples_for 'create_expires' do
  it 'creates the given key and expires it' do
    store.create('key','value', :expires => 1).should be_true
    store['key'].should == 'value'
    sleep 2
    store.key?('key').should be_false
  end

  it 'does not change expires if the key exists' do
    store.store('key', 'value', :expires => false).should == 'value'
    store.create('key','another value', :expires => 1).should be_false
    store['key'].should == 'value'
    sleep 2
    store['key'].should == 'value'
    store.key?('key').should be_true
  end
end

#################### marshallable_key ####################

shared_examples_for 'marshallable_key' do
  it 'refuses to #[] from keys that cannot be marshalled' do
    expect do
      store[Struct.new(:foo).new(:bar)]
    end.to raise_error(marshal_error)
  end

  it 'refuses to load from keys that cannot be marshalled' do
    expect do
      store.load(Struct.new(:foo).new(:bar))
    end.to raise_error(marshal_error)
  end

  it 'refuses to fetch from keys that cannot be marshalled' do
    expect do
      store.fetch(Struct.new(:foo).new(:bar), true)
    end.to raise_error(marshal_error)
  end

  it 'refuses to #[]= to keys that cannot be marshalled' do
    expect do
      store[Struct.new(:foo).new(:bar)] = 'value'
    end.to raise_error(marshal_error)
  end

  it 'refuses to store to keys that cannot be marshalled' do
    expect do
      store.store Struct.new(:foo).new(:bar), 'value'
    end.to raise_error(marshal_error)
  end

  it 'refuses to check for #key? if the key cannot be marshalled' do
    expect do
      store.key? Struct.new(:foo).new(:bar)
    end.to raise_error(marshal_error)
  end

  it 'refuses to delete a key if the key cannot be marshalled' do
    expect do
      store.delete Struct.new(:foo).new(:bar)
    end.to raise_error(marshal_error)
  end
end

#################### marshallable_value ####################

shared_examples_for 'marshallable_value' do
  it 'refuses to store values that cannot be marshalled' do
    expect do
      store.store 'key', Struct.new(:foo).new(:bar)
    end.to raise_error(marshal_error)
  end
end

#################### transform_value ####################

shared_examples_for 'transform_value' do
  it 'allows to bypass transformer with :raw' do
    store['key'] = 'value'
    load_value(store.load('key', :raw => true)).should == 'value'

    store.store('key', 'value', :raw => true)
    store.load('key', :raw => true).should == 'value'
    store.delete('key', :raw => true).should == 'value'
  end

  it 'allows to bypass transformer with raw syntactic sugar' do
    store['key'] = 'value'
    load_value(store.raw.load('key')).should == 'value'

    store.raw.store('key', 'value')
    store.raw['key'].should == 'value'
    store.raw.load('key').should == 'value'
    store.raw.delete('key').should == 'value'

    store.raw['key'] = 'value2'
    store.raw['key'].should == 'value2'
  end

  it 'returns unmarshalled value' do
    store.store('key', 'unmarshalled value', :raw => true)
    store.load('key', :raw => true).should == 'unmarshalled value'
  end

  it 'might raise exception on invalid value' do
    store.store('key', 'unmarshalled value', :raw => true)

    begin
      store['key'].should == load_value('unmarshalled value')
      store.delete('key').should == load_value('unmarshalled value')
    rescue Exception => ex
      expect do
        store['key']
      end.to raise_error
      expect do
        store.delete('key')
      end.to raise_error
    end
  end
end

#################### transform_value_expires ####################

shared_examples_for 'transform_value_expires' do
  it 'allows to bypass transformer with :raw' do
    store['key'] = 'value'
    load_value(store.load('key', :raw => true)).should == 'value'
    store['key'] = [1,2,3]
    load_value(store.load('key', :raw => true)).should == [[1,2,3]]
    store['key'] = nil
    load_value(store.load('key', :raw => true)).should == [nil]
    store['key'] = false
    load_value(store.load('key', :raw => true)).should be_false

    store.store('key', 'value', :expires => 10)
    load_value(store.load('key', :raw => true)).first.should == 'value'
    load_value(store.load('key', :raw => true)).last.should respond_to(:to_int)

    store.store('key', 'value', :raw => true)
    store.load('key', :raw => true).should == 'value'
    store.delete('key', :raw => true).should == 'value'
  end

  it 'returns unmarshalled value' do
    store.store('key', 'unmarshalled value', :raw => true)
    store.load('key', :raw => true).should == 'unmarshalled value'
  end

  it 'might raise exception on invalid value' do
    store.store('key', 'unmarshalled value', :raw => true)

    begin
      store['key'].should == load_value('unmarshalled value')
      store.delete('key').should == load_value('unmarshalled value')
    rescue Exception => ex
      expect do
        store['key']
      end.to raise_error
      expect do
        store.delete('key')
      end.to raise_error
    end
  end
end

#################### features ####################

shared_examples_for 'features' do
  it 'should report correct features' do
    store.features.sort_by(&:to_s).should == features
  end

  it 'should have frozen features' do
    store.features.frozen?.should be_true
  end

  it 'should have #supports?' do
    features.each do |f|
      store.supports?(f).should be_true
    end
    store.supports?(:unknown).should be_false
  end
end

